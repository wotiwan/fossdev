%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,russian]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}





\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsrussian{\renewcommand{\contentsname}{Культура и интструменты разработки}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{toolchain}
\date{мая 20, 2024}
\release{1.0}
\author{Artem Vesnin}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Выпуск}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Терминология}
\label{\detokenize{index:id2}}
\sphinxstepscope


\section{Терминология}
\label{\detokenize{educational_materials/terms/content:id1}}\label{\detokenize{educational_materials/terms/content::doc}}
\sphinxAtStartPar
В данном курсе мы будем использовать терминологию, связанную с разработкой программного обеспечения, поэтому полезно собрать все термины в одном месте. Ниже мы будем приводить русский и английский варианты терминов, так как последние будут полезны при поиске информации. Мы не претендуем на полноту списка терминов, используемых для разработки приложений, но постарались собрать те из них, которые важны в рамках данного курса, и по возможности снабдить их примерами.


\subsection{Приложение (англ. Application)}
\label{\detokenize{educational_materials/terms/content:application}}
\sphinxAtStartPar
По\sphinxhyphen{}английски это Application, или app. Последнее часто используется при написании приложений. Например, при написании \sphinxstylestrong{бэкэнда} используется именно это имя для того, чтобы обозначить главное приложение.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fastapi} \PYG{k+kn}{import} \PYG{n}{FastAPI}

\PYG{n}{app} \PYG{o}{=} \PYG{n}{FastAPI}\PYG{p}{(}\PYG{p}{)}

\PYG{n+nd}{@app}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{root}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Модуль/Пакет/Библиотека/Фреймворк (англ. Module/Package/Library/Framework)}
\label{\detokenize{educational_materials/terms/content:module-package-library-framework}}
\sphinxAtStartPar
Эти термины связаны с организацией кода и с тем, как он функционирует. Если мы хотим, чтобы наш проект можно было читать и, как следствие, он был интересен другим разработчикам, которые могли бы его развивать, мы должны позаботиться о структуре проекта. Все начинается с \sphinxstylestrong{модуля}, модуль — это файл с кодом, который объединен общим смыслом. Например, если у нас есть код для генерации данных и их визуализации, будет неплохой идеей разделить его на два файла\sphinxhyphen{}модуля. \sphinxstyleemphasis{Примечание: если модулей генерации данных и визуализации несколько, мы уже будем объединять их в пакеты, о которых речь пойдет ниже.} Python\sphinxhyphen{}модули имеют расширение \sphinxcode{\sphinxupquote{.py}}.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}From module genearating data\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}arithmetic\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}geometric}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}From module plotting data\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}lines}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}dots}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Модули привносят множество преимуществ в наш код:}
\label{\detokenize{educational_materials/terms/content:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Улучшенный процесс разработки. Модули Python помогают вам сосредоточиться на одной небольшой части задачи, не держа в голове весь контекст проекта. Кроме того, модули обычно пишутся таким образом, чтобы свести к минимуму зависимость друга от друга. Почти всегда, когда возникает желание использовать код одного модуля в другом и наоборот, можно выделить взаимный код в третий модуль и использовать его в двух первых. Также мы уменьшаем количество конфликтов при слиянии кода (\sphinxcode{\sphinxupquote{merge conflict}}).

\item {} 
\sphinxAtStartPar
Уменьшение количества кода. Функциональность, которую мы определяем в одном модуле, можем использоваться в разных частях приложения, сводя к минимуму дублирование кода.

\item {} 
\sphinxAtStartPar
Отдельные пространства имен. С модулями Python вы можете определить отдельные пространства имен, чтобы избежать конфликтов между идентификаторами в разных частях вашего приложения.

\end{itemize}

\sphinxAtStartPar
Термин \sphinxstylestrong{пакет} является достаточно перегруженным, и его значение может меняться в зависимости от контекста. Так как в курсе мы в основном работаем с Python, будем придерживаться терминологии, принятой в нем. \sphinxstylestrong{Пакет} — это следующий уровень в организации кода после модулей. Если модули содержали функции и классы, то пакет уже содержит сами модули. Для того, чтобы каталог был воспринят как пакет, он должен содержать файл \sphinxcode{\sphinxupquote{\_\_init\_\_.py}}. \sphinxhref{https://www.includehelp.com/python/packages.aspx}{Пример} пакета:

\sphinxAtStartPar
\sphinxincludegraphics{{package_structure}.png}

\sphinxAtStartPar
\sphinxstylestrong{Пакеты} могу содержать внутри себя каталоги, которые, в свою очередь, тоже являются пакетами.

\sphinxAtStartPar
\sphinxstylestrong{Библиотека}  — это общий термин для кода, который можно переиспользовать. Мы все пишем код и собираем его в модули и пакеты, но это не значит, что наш код можно считать библиотекой. Для этого он должен обладать некоторой долей универсальности, определенным оформлением и другими элементами, например, покрытием тестами. Т.е. библиотека обязательно является пакетом, но не каждый пакет можно считать библиотекой. Например, на сайте \sphinxhref{https://numpy.org/}{numpy} указано, что это пакет:
\begin{quote}

\sphinxAtStartPar
NumPy is the fundamental Python package for scientific computing
\end{quote}

\sphinxAtStartPar
При этом на сайте другого популярного проекта \sphinxhref{https://matplotlib.org/}{matplotlib} говорится, что это библиотека:
\begin{quote}

\sphinxAtStartPar
Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python
\end{quote}

\sphinxAtStartPar
Поэтому есть мнение, что библиотека — это \sphinxstyleemphasis{пакет с пакетами}, т.е. что\sphinxhyphen{}то, что обладает более разносторонней функциональностью, чем пакет.

\sphinxAtStartPar
Итак, мы подобрались к самым сложным объектам — \sphinxstylestrong{фреймворкам}. Наиболее подходящий перевод с английского — \sphinxstyleemphasis{основа} или \sphinxstyleemphasis{каркас}, т.е. что\sphinxhyphen{}то, на чем мы строим или на что навешиваем свой функционал. Идея фреймворков появилась, когда программисты поняли, что часто используют библиотеки почти одинаковым способом. Например, нам нужно принять данные от пользователя, валидировать их и сохранить в базе данных. Можно «поднять» все необходимые компоненты и написать все это вручную, а можно взять готовый \sphinxstylestrong{фреймворк}, где уже будет реализованы базовый поток данных и архитектура приложения, и нам нужно будет только написать код, который относится к нашей задаче. Поэтому распространенное определение, что фреймворк — это набор библиотек, не совсем верно. Можно думать о \sphinxhref{https://www.interviewbit.com/blog/framework-vs-library/}{различии} \sphinxstylestrong{библиотеки} и \sphinxstylestrong{фреймворка} так: если мы не напишем ни одной строчки кода, \sphinxstylestrong{фреймворк} все равно будет работать и поддерживать базовый поток. Поэтому тот код, который напишет программист, используя фреймворк, будет выполняться и контролироваться этим фреймворком. Еще один способ думать о фреймворках — это насколько полным является его функционал для решения задачи, т.е. мы можем ли решить бизнес\sphinxhyphen{}задачу, не выходя за пределы какого\sphinxhyphen{}то инструмента. Мы часто слышим про фреймворки в \sphinxhref{https://fastapi.tiangolo.com/}{контексте web\sphinxhyphen{}приложений}, но этим \sphinxhref{https://www.qt.io/product/framework}{не ограничивается} их применение.


\subsection{Парадигма программирования (англ. programming paradigm)}
\label{\detokenize{educational_materials/terms/content:programming-paradigm}}
\sphinxAtStartPar
Способ, как мы смотрим на то, что происходит при разработке. Например, с точки зрения водителя улица, через которую он едет \sphinxstyleemphasis{транзитом}, это ширина проезжей части дороги, количество светофоров и прочее. Но улица, на которой расположен пункт назначения, уже рассматривается водителем с точки зрения удобства парковки, хотя на транзитной улице тоже есть парковочные места. Т.е. на одну и туже сущность \sphinxstyleemphasis{улица} мы можем смотреть под разными углами, в зависимости от того, что сейчас для нас важно. \sphinxstyleemphasis{Парадигма программирования} — это способ описать задачу, например, данные и действия над ними.
Рассмотрим на примере процедурной и объектно\sphinxhyphen{}ориентированной парадигм. \sphinxstylestrong{Процедурное} программирование описывает список действий (процедур), которые мы предпринимаем для достижения цели. \sphinxstylestrong{Объектно\sphinxhyphen{}ориентированное} программирование строится вокруг объектов и их свойств, здесь мы применяем такие термины как Класс, Экземпляр (Объект), Поле (Аттрибут), Метод. \sphinxstylestrong{Объектно\sphinxhyphen{}ориентированное} программирование — наиболее часто используемый подход, хотя существуют задачи (\sphinxhref{https://www.techtarget.com/searchapparchitecture/definition/reactive-programming}{1}, \sphinxhref{https://docs.confluent.io/platform/current/tutorials/examples/microservices-orders/docs/index.html}{2}), где решение лучше описывается в других парадигмах. Подробнее об ООП на примере Python читайте в \sphinxhref{https://towardsdatascience.com/python-procedural-or-object-oriented-programming-42c66a008676}{статье}. На практике мы можем смешивать парадигмы, если это не вредит поддерживаемости кода. Ниже приведен пример решения одной и той же задачи с использованием разных парадигм:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} PROCEDURAL}
\PYG{k}{def} \PYG{n+nf}{average\PYGZus{}age}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{average} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{table}\PYG{p}{:}
        \PYG{n}{average} \PYG{o}{=} \PYG{n}{average} \PYG{o}{+} \PYG{n}{item}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{count} \PYG{o}{=} \PYG{n}{count} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{average} \PYG{o}{/} \PYG{n}{count}

\PYG{n}{people} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ivan}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mary}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sara}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{29}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average age:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{average\PYGZus{}age}\PYG{p}{(}\PYG{n}{people}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} OOP}
\PYG{k}{class} \PYG{n+nc}{Person}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{age}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{name}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{age} \PYG{o}{=} \PYG{n}{age}

\PYG{k}{class} \PYG{n+nc}{Workers}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{workers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{worker}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{workers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{worker}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}average\PYGZus{}age}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{age\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{worker} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{workers}\PYG{p}{:}
            \PYG{n}{age\PYGZus{}sum} \PYG{o}{=} \PYG{n}{age\PYGZus{}sum} \PYG{o}{+} \PYG{n}{worker}\PYG{o}{.}\PYG{n}{age}
        \PYG{k}{return} \PYG{n}{age\PYGZus{}sum} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{workers}\PYG{p}{)}

\PYG{n}{workers} \PYG{o}{=} \PYG{n}{Workers}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{workers}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Person}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ivan}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{age} \PYG{o}{=} \PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{workers}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Person}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mary}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{age} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{workers}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Person}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{age} \PYG{o}{=} \PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{workers}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Person}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sara}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{age} \PYG{o}{=} \PYG{l+m+mi}{29}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average age:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{.}\PYG{n}{get\PYGZus{}average\PYGZus{}age}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Что такое? Почему в ООП больше кода, когда это такая классная парадигма? Все верно, кода больше, но он лучше структурирован, и нужно думать не о количестве кода, а о том, насколько его легко читать и насколько его легко поддерживать. Например, средний возраст — это характеристика группы людей, поэтому мы пишем метод в \sphinxcode{\sphinxupquote{Workers}}, а если мы хотим написать метод, который увеличит возраст сотрудника в день его рождения, мы идем в класс \sphinxcode{\sphinxupquote{Person}}. Также в \sphinxstylestrong{процедурном} программировании часто возникают конструкции типа \sphinxcode{\sphinxupquote{item{[}1{]}}}, и мы должны помнить, что возраст — это индекс 1 (а не 0, индексы нумеруются от нуля). В \sphinxstylestrong{объектно\sphinxhyphen{}ориентированном} мы не работаем с большой таблицей данных, а структурируем информацию в том виде, с которым принято работать в той или иной сфере. Подумайте, как бы вы решили следующие задачи:
\begin{itemize}
\item {} 
\sphinxAtStartPar
храним не возраст, а дату рождения, и нужно по\sphinxhyphen{}прежнему знать возраст;

\item {} 
\sphinxAtStartPar
хотим уволить :( человека.

\end{itemize}


\subsection{Статическое и динамическое типизирование}
\label{\detokenize{educational_materials/terms/content:id3}}
\sphinxAtStartPar
В Python мы можем объявить переменную без указания типа, интерпретатор сам определит тип переменной. Это называется \sphinxstylestrong{динамическая типизация}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{magic\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mf}{42.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
С другой стороны, когда в описании переменной необходимо указывать тип, мы имеем дело со статической типизацией. Она применяется как в C++, так и во многих других языках.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{magic\PYGZus{}number}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{42.}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{magic\PYGZus{}number}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь посмотрим не со стороны языка программирования, а со стороны разработчика. При объявлении переменной ее тип может быть понятен из значения, которое в ней хранится. Но при использовании функции мы не можем понять, что именно мы должны передать без использования документации. Поэтому мы можем использовать аннотацию типов и в таких языках как Python:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fib\PYGZus{}nohint}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{a}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{fib\PYGZus{}hint}\PYG{p}{(}\PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Iterator}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{a}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}

\end{sphinxVerbatim}

\sphinxAtStartPar
Функцию, где указаны типы аргументов и тип возвращаемого значения, проще использовать. Кроме удобства при чтении кода, можно добавить также и \sphinxhref{https://docs.pydantic.dev/usage/validators/}{валидацию} значений переменных, используя библиотеку \sphinxhref{https://docs.pydantic.dev/}{pydantic}. Проводить проверку своего кода на наличие аннотирования можно, используя такие инструменты как \sphinxhref{https://mypy-lang.org/}{mypy}.


\subsection{Тестирование}
\label{\detokenize{educational_materials/terms/content:id4}}
\sphinxAtStartPar
Оно должно быть. Рассмотрим здесь несколько важных терминов: \sphinxstylestrong{Покрытие тестами} (англ. Test Coverage) — доля кода, которая покрыта тестами, т.е. та часть кода, которую мы действительно выполняем с использованием тестовых данных. Ниже приведен пример на C++: код скомпилируется, но при этом его нельзя выполнить без ошибки. Если бы функция \sphinxcode{\sphinxupquote{foo}} была покрыта тестами, мы бы увидели ошибку сразу.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n+nf}{foo}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mf}{42.}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Разработка через тестирование} (англ. Test\sphinxhyphen{}driven development) — подход, при котором мы сначала пишем тесты, и только потом разрабатываем саму функциональность. На практике это не всегда достижимо и не всегда удобно, поэтому в написании тестов после разработки функциональности нет ничего плохого.

\sphinxAtStartPar
\sphinxstylestrong{Юнит\sphinxhyphen{}тестирование} (англ. Unit Testing) — разбиение программы на мелкие блоки, каждый из которых может быть протестирован отдельно. Пример ниже содержит простой класс, который умеет только добавлять 10 и умножать на 10. Мы можем подумать над тестами заранее (\sphinxstylestrong{Разработка через тестирование}) или написать тесты потом, в любом случае, нам нужно добиться прохождения тестов. На практике вы будете использовать библиотеки типа \sphinxcode{\sphinxupquote{unittest}}, пример ниже специально написан без использования сторонних библиотек, чтобы показать концепцию тестирования и не отвлекаться на изучение конкретных инструментов. Позже в курсе тестированию будут посвящены отдельные занятия.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Calculator}\PYG{p}{:}
    
    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}10}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{10}
    
    \PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}by\PYGZus{}10}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{l+m+mi}{10}
        
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} testing code}
    \PYG{k}{assert} \PYG{n}{Calculator}\PYG{o}{.}\PYG{n}{add\PYGZus{}10}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{22}          \PYG{c+c1}{\PYGZsh{}test 1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pass test 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{Calculator}\PYG{o}{.}\PYG{n}{multiply\PYGZus{}by\PYGZus{}10}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{120} \PYG{c+c1}{\PYGZsh{}test 2}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pass test 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{try}\PYG{p}{:}                                        \PYG{c+c1}{\PYGZsh{}test 3}
        \PYG{n}{Calculator}\PYG{o}{.}\PYG{n}{add\PYGZus{}10}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{asda}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fail test 3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pass test 3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
    \PYG{k}{try}\PYG{p}{:}                                        \PYG{c+c1}{\PYGZsh{}test 4}
        \PYG{n}{Calculator}\PYG{o}{.}\PYG{n}{multiply\PYGZus{}by\PYGZus{}10}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{asda}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fail test 4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pass test 4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Подумайте, почему четвертый тест не прошел и как сделать так, чтобы он отработал. Оцените, насколько удобно иметь тесты.}


\subsection{Логирование (англ. Logging)}
\label{\detokenize{educational_materials/terms/content:logging}}
\sphinxAtStartPar
Ведение журнала событий, в котором записывается информация, облегчающая отслеживание событий, которые нельзя отнести к нормальной работе кода или системы в целом.


\subsection{Язык разметки (англ. Markup Language)}
\label{\detokenize{educational_materials/terms/content:markup-language}}
\sphinxAtStartPar
\sphinxstylestrong{Язык разметки} позволяет снабдить текст специальными символами, которые регулируют его отображение. Например, этот документ написан с помощью языка разметки \sphinxstyleemphasis{Markdown}, а GitHub или Gitlab собрал из него красивый документ, который вы сейчас и читаете. Популярность \sphinxstyleemphasis{Markdown} породила \sphinxhref{https://habr.com/ru/post/672266/}{множество} инструментов написания текста в нем и компиляции итогового документа. Данный раздел выглядит вот так (редактор ReText):

\sphinxAtStartPar
\sphinxincludegraphics{{markdown_source}.png}


\subsection{Система контроля версий (англ. Version Control System)}
\label{\detokenize{educational_materials/terms/content:version-control-system}}
\sphinxAtStartPar
\sphinxstylestrong{Система контроля версий} позволяет облегчить работу над приложением, даже при работе в одиночку. При работе в команде она практически незаменима. В курсе мы будем использовать \sphinxstylestrong{git}, которому посвящено несколько занятий. На основе git построены такие системы как GitLab и GitHub, которые предоставляют удаленный репозиторий git и привносят дополнительную функциональность, такую как отслеживание багов через *\sphinxstylestrong{Задачи/Проблемы} (англ. Issues), визуализацию и многое другое.


\subsection{Ошибка (англ. bug)}
\label{\detokenize{educational_materials/terms/content:bug}}
\sphinxAtStartPar
Ошибка или непонятное поведение программы, в общем, все, что нельзя отнести к нормальному поведению программы. Часто используется прямая транскрипция с английского — \sphinxstylestrong{баг}. Баг может приводить к сбоям при использовании определенного места в программе, и это хороший сценарий, поскольку сразу понятно, где ошибка. \sphinxstyleemphasis{В примере ниже в print\_value() идет обращение к переменной, которую ранее нигде не инициализировали, это можно исправить, написав \sphinxcode{\sphinxupquote{self.value}} вместо \sphinxcode{\sphinxupquote{value}}}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ClassWithBugFailFast}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{print\PYGZus{}value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{set\PYGZus{}value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{value}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n+nb+bp}{cls} \PYG{o}{=} \PYG{n}{ClassWithBugFailFast}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{set\PYGZus{}value}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}
    \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{print\PYGZus{}value}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Часто бывает, что ошибки не происходит, но поведение программы неочевидно.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ClassWithBugNoFail}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{print\PYGZus{}value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{set\PYGZus{}value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{value}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n+nb+bp}{cls} \PYG{o}{=} \PYG{n}{ClassWithBugNoFail}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{set\PYGZus{}value}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}
    \PYG{n+nb+bp}{cls}\PYG{o}{.}\PYG{n}{print\PYGZus{}value}\PYG{p}{(}\PYG{l+m+mi}{456}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задачи/Проблемы (англ. Issues)}
\label{\detokenize{educational_materials/terms/content:issues}}
\sphinxAtStartPar
Одна из целей, которые преследуют Issues, — документирование багов и отслеживание их решения. Однако они используется гораздо \sphinxhref{https://docs.gitlab.com/ee/user/project/issues/}{шире} и, как многие другие инструменты, призваны повысить эффективность разработки приложений.


\subsection{Fail\sphinxhyphen{}fast}
\label{\detokenize{educational_materials/terms/content:fail-fast}}
\sphinxAtStartPar
В примере выше мы посмотрели, что неправильно написанный код, который сразу приводит к ошибке, лучше, чем код, который приводит не к ошибке, а к непонятным результатам. Понятно, что мы не планируем писать баги, но поведение, при котором мы вызываем ошибку (кидаем исключение) при непонятной ситуации, получило название \sphinxstylestrong{fail\sphinxhyphen{}fast}. Подход \sphinxstylestrong{fail\sphinxhyphen{}fast} является предпочтительным при написании кода, так как позволяет определить место, где произошла ошибка. Другим подходом при обработке непредвиденной ситуации является подход \sphinxstylestrong{forgive}, при котором мы пытаемся уменьшить негативные последствия и стараемся не кидать ошибки. Подробнее про два подхода можно почитать в \sphinxhref{https://habr.com/ru/post/218325/}{статье}


\subsection{Исключение (англ. Exceptions)}
\label{\detokenize{educational_materials/terms/content:exceptions}}
\sphinxAtStartPar
Исключительная ситуация требует исключительных мер. При работе приложения мы стараемся предусмотреть возможные варианты его использования, например, варианты входных данных, которые приходят в приложение от пользователя. Данные от пользователя могут быть недопустимыми, и мы можем попробовать исправить это. Например, конвертировать строку, содержащую число, в целое число, используя \sphinxcode{\sphinxupquote{int()}}, а если не получится, то \sphinxcode{\sphinxupquote{float()}}. \sphinxstyleemphasis{Для данного примера считаем, что это приемлемый вариант}.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Validator}\PYG{p}{:}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}int\PYGZus{}number}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{result} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Could convert to int, try via float:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{result} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{result}
        
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Validator}\PYG{o}{.}\PYG{n}{get\PYGZus{}int\PYGZus{}number}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}input} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aaa}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{Validator}\PYG{o}{.}\PYG{n}{get\PYGZus{}int\PYGZus{}number}\PYG{p}{(}\PYG{n}{user\PYGZus{}input}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}input}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is not a number, please enter proper data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Unknow error ask developers }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Если не получается конвертировать в число в принципе, как в случае со строкой \sphinxcode{\sphinxupquote{\textquotesingle{}aaa\textquotesingle{}}}, мы можем попросить пользователя повторить ввод. Если же происходит что\sphinxhyphen{}то, что мы не можем идентифицировать, то тоже должны «поймать» это на верхнем уровне (в примере выше это \sphinxcode{\sphinxupquote{except Exception as e}}) и зафиксировать: можно, например, записать сообщение об ошибке в лог.


\chapter{Командная строка}
\label{\detokenize{index:id3}}
\sphinxstepscope


\section{Работа в командной строке}
\label{\detokenize{educational_materials/bash/content:id1}}\label{\detokenize{educational_materials/bash/content::doc}}
\sphinxAtStartPar
Команды bash являются неотъемлемой частью разработки. Командная строка, не только bash, но и другие, дает бОльшие возможности по сравнению с любым графическим интерфейсом. Любой интерфейс полагается на эти команды и вызывает их с соответствующими параметрами.


\subsection{Мотивация}
\label{\detokenize{educational_materials/bash/content:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Относитесь к \sphinxcode{\sphinxupquote{bash}} как универсальному скриптовому языку, который покажет одинаковое поведение на разных системах Линукс. С помощью bash и различных утилит мы можем получать доступ к «железу» машины, на которой работаем, и настраивать автоматические сценарии. Это можно осуществить и с использованием языков программирования, но сделать это будет сложнее, и реализация будет зависеть от конкретного языка программирования. Но если мы напишем \sphinxcode{\sphinxupquote{bash}}, то «дернуть» его из любого языка программирования не составит труда, так как большинство из них поддерживает системные вызовы. Если же вызов системных функций невозможен или неудобен, обмен информацией всегда доступен через файлы, куда можно записать информацию из \sphinxcode{\sphinxupquote{bash}}\sphinxhyphen{}скрипта, а прочитать из \sphinxcode{\sphinxupquote{python}}.

\item {} 
\sphinxAtStartPar
При работе на своей компьютере вы можете не оценить все достоинства командной строки, однако она точно понадобится, чтобы настроить работу вашего приложения на удаленном сервере, физическом или виртуальном, к которому вы будете подключаться по ssh и на котором может быть в принципе не установлен оконный интерфейс.

\end{enumerate}

\sphinxAtStartPar
Ниже будут описаны команды, которые помогут ходить по файловой системе, создавать, копировать и перемещать файлы, изменять разрешения для файлов, передавать владельца у файла, просматривать запущенные процессы и открытые порты.
Предположим, у нас есть пользователь с именем \sphinxstylestrong{artem}, на машине, которая называется \sphinxstylestrong{pc}. Тогда при запуске командной строки мы увидим предложение ввода команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:/\PYGZdl{}\PYG{+w}{ }
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что здесь указаны имя пользователя и имя компьютера через символ \sphinxcode{\sphinxupquote{@}}. Далее после двоеточия (\sphinxcode{\sphinxupquote{:}}) указан текущий путь, сейчас мы находимся в корневой директории, далее символ \sphinxcode{\sphinxupquote{\$}} для отделения команды. Начнем изучение командной строки с команды, которая позволяет ходить по файловой системе.

\sphinxAtStartPar
\sphinxstylestrong{Hint: при нажатии на стрелку вверх в командную строку будет подставлена предыдущая команда. Стрелку можно нажимать несколько раз}

\sphinxAtStartPar
\sphinxstylestrong{Hint: Дополнительные информацию и опции по каждой команде можно увидеть вызвав} \sphinxcode{\sphinxupquote{man command}} \sphinxstylestrong{или} \sphinxcode{\sphinxupquote{command \sphinxhyphen{}\sphinxhyphen{}help}}, \sphinxcode{\sphinxupquote{man}} \sphinxstylestrong{сокращенно от manual}

\sphinxAtStartPar
Мы надеемся, что это было достаточно убедительно, чтобы не пройти мимо темы \sphinxcode{\sphinxupquote{bash}}.


\subsection{cd \sphinxhyphen{} change directory}
\label{\detokenize{educational_materials/bash/content:cd-change-directory}}
\sphinxAtStartPar
Команда для смены директории. При вызове происходит переход в директорию, которая указана после команды \sphinxcode{\sphinxupquote{cd /path/to/destination}}. Предположим, у нас есть пользователь с именем artem. Следующие команды можно выполнить, чтобы перейти сначала в директорию \sphinxcode{\sphinxupquote{home}}, а затем в домашнюю директорию пользователя \sphinxcode{\sphinxupquote{/home/artem}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:/\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/home
artem@pc:/home\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }./artem
artem@pc:\PYGZti{}\PYGZdl{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Заметьте, что во втором случае мы использовали \sphinxcode{\sphinxupquote{./}} для перехода по относительному пути. Также видно, что меняется текущий путь, в котором мы находимся: в первой строке это была корневая директория (\sphinxcode{\sphinxupquote{/}}), во второй — директория, в которой содержатся все домашние директории всех пользователей данной системы (\sphinxcode{\sphinxupquote{/home}}). В третьей строке вместо пути мы видим символ \sphinxcode{\sphinxupquote{\textasciitilde{}}}, который является сокращением для домашней папки конкретного пользователя. Две команды выше эквиваленты одной команде с указанием абсолютного пути:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:/\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/home/artem
\end{sphinxVerbatim}

\sphinxAtStartPar
Команда \sphinxcode{\sphinxupquote{cd /artem}} вызовет ошибку, так как будет происходить поиск в корневой директории, а в ней \sphinxstylestrong{НЕ} содержится директории \sphinxcode{\sphinxupquote{artem}}.
При использовании \sphinxcode{\sphinxupquote{cd}} можно использовать сокращения, которые позволяют переходить по определенным путям, не прописывая полный путь (в примерах ниже \sphinxcode{\sphinxupquote{\#}} означает начало комментария):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{    }\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZti{}\PYG{+w}{        }\PYG{c+c1}{\PYGZsh{} переход в домашнюю папку}
\PYG{+w}{    }\PYG{n+nb}{cd}\PYG{+w}{ }../\PYG{+w}{      }\PYG{c+c1}{\PYGZsh{} переход на один уровень выше}
\PYG{+w}{    }\PYG{n+nb}{cd}\PYG{+w}{ }../../\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} переход на два уровня выше, чтобы уйти еще выше, можно добавлять ../}
\PYG{+w}{    }\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZhy{}\PYG{+w}{        }\PYG{c+c1}{\PYGZsh{} возврат в предыдущую директорию}
\PYG{+w}{    }\PYG{n+nb}{cd}\PYG{+w}{ }.\PYG{+w}{        }\PYG{c+c1}{\PYGZsh{} текущий каталог}
\end{sphinxVerbatim}

\sphinxAtStartPar
На рисунке ниже представлено использование описанных команд.

\sphinxAtStartPar
\sphinxincludegraphics{{cd_path}.png}

\sphinxAtStartPar
При использовании команды \sphinxcode{\sphinxupquote{cd}} необязательно помнить полное наименование директории. Можно начать писать путь и затем нажать на TAB для автодополнения.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:/\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/usr/loc\PYG{+w}{     }\PYG{c+c1}{\PYGZsh{} нажимаем TAB}
artem@pc:/\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/usr/local/
\end{sphinxVerbatim}

\sphinxAtStartPar
Если написанного пользователем будет недостаточно для того, чтобы однозначно определить путь, командная строка выдаст все возможные варианты:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user\PYGZsh{}pc:\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/usr/l\PYG{+w}{     }\PYG{c+c1}{\PYGZsh{} нажимаем TAB}
lib/\PYG{+w}{    }libexec/\PYG{+w}{    }local/
user\PYGZsh{}pc:\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }/usr/l
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{cd_tab}.png}

\sphinxAtStartPar
Вопросы для проверки:

\sphinxAtStartPar
\sphinxstyleemphasis{Что можно указать после команды cd?}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Абсолютный путь (верно)

\item {} 
\sphinxAtStartPar
Относительный путь (верно)

\item {} 
\sphinxAtStartPar
Адрес веб\sphinxhyphen{}сайта (НЕверно)

\item {} 
\sphinxAtStartPar
Один из специальных наборов символов, например, \sphinxcode{\sphinxupquote{../}} (верно)

\end{itemize}


\subsection{ls \sphinxhyphen{} list}
\label{\detokenize{educational_materials/bash/content:ls-list}}
\sphinxAtStartPar
Для просмотра содержимого директории можно использовать \sphinxstylestrong{ls}. При вызове без параметров будет показано содержимое \sphinxstyleemphasis{текущей директории}. Также можно указать путь \sphinxcode{\sphinxupquote{ls /path/to/dir}}, в этом случае будет показано содержимое \sphinxstyleemphasis{указанной директории}.

\sphinxAtStartPar
\sphinxincludegraphics{{ls}.png}

\sphinxAtStartPar
Мы видим, что разные имена подкрашены по\sphinxhyphen{}разному, на картинке выше три вида разметки. В вашей командой строке цвета могут отличаться. На картинке синий обозначает директорию, черный — обычный файл и зеленый — исполняемый файл. Но как понять это без цветовой индикации? Для этого вызовите \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l}}:

\sphinxAtStartPar
\sphinxincludegraphics{{ls_list}.png}

\sphinxAtStartPar
Теперь мы видим больше информации по каждому файлу и директории в \sphinxcode{\sphinxupquote{project}}. Среди этой информации: разрешение, владелец, группа, размер, дата последнего изменения, имя файла. Как видите, директория имеет букву \sphinxcode{\sphinxupquote{d}} в разрешениях, а исполняемый файл, в отличие от неисполняемого, имеет атрибут \sphinxcode{\sphinxupquote{x}}.

\sphinxAtStartPar
Для просмотра скрытых файлов нужно указать параметр \sphinxcode{\sphinxupquote{a}}. К скрытым файлам относятся директории, которые создаются при инициализации репозитория git.

\sphinxAtStartPar
\sphinxincludegraphics{{ls_all}.png}

\sphinxAtStartPar
Вопросы для проверки:

\sphinxAtStartPar
\sphinxstyleemphasis{Можно ли указывать ls без параметров?}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Да (верно)

\item {} 
\sphinxAtStartPar
Нет (НЕверно)

\end{itemize}


\subsection{clear}
\label{\detokenize{educational_materials/bash/content:clear}}
\sphinxAtStartPar
Командой \sphinxstylestrong{clear} можно очистить терминал от вывода. При этом история команд останется, и их по\sphinxhyphen{}прежнему можно доставать, нажимая на стрелку вверх.

\sphinxAtStartPar
\sphinxincludegraphics{{clear_all}.png}

\sphinxAtStartPar
При использовании clear мы увидим пустой терминал:

\sphinxAtStartPar
\sphinxincludegraphics{{clear_done}.png}
\begin{quote}

\sphinxAtStartPar
PS: для скриншотов данного материала \sphinxcode{\sphinxupquote{clear}} использовалось ооочень много раз :)
\end{quote}


\subsection{mkdir \sphinxhyphen{} make directory}
\label{\detokenize{educational_materials/bash/content:mkdir-make-directory}}
\sphinxAtStartPar
Для создания директорий мы используем команду \sphinxstylestrong{mkdir}. Так же, как в случае с \sphinxstylestrong{cd} и \sphinxstylestrong{ls}, мы можем использовать относительный путь. Если директория уже существует, будет выдано сообщение об ошибке.

\sphinxAtStartPar
\sphinxincludegraphics{{mkdir}.png}


\subsection{touch}
\label{\detokenize{educational_materials/bash/content:touch}}
\sphinxAtStartPar
Представьте ситуацию: нужно узнать время, когда последний раз запускалось то или иное приложение, которое запускается в фоне. Существует множество способов это сделать: запись в базе данных, анализ логов и так далее. Самой простой способ для bash\sphinxhyphen{}скрипта — изменение времени последнего изменения какого\sphinxhyphen{}либо файла. Это можно сделать, записав что\sphinxhyphen{}то в файл. Если такой вариант не подходит, воспользуйтесь командой \sphinxcode{\sphinxupquote{touch}}, которая как раз предназначена для изменения времени обращения к файлу на текущее, при этом открытие файла не происходит.

\sphinxAtStartPar
\sphinxincludegraphics{{touch_timestamp}.png}

\sphinxAtStartPar
Если файл не существует, он будет создан пустым, если не указан аргумент \sphinxcode{\sphinxupquote{\sphinxhyphen{}с}}.

\sphinxAtStartPar
\sphinxincludegraphics{{touch_no_create}.png}


\subsection{cat \sphinxhyphen{} concatenate}
\label{\detokenize{educational_materials/bash/content:cat-concatenate}}
\sphinxAtStartPar
Читает содержимое файлов и выводит его. Добавим в project директорию \sphinxcode{\sphinxupquote{data}} и два файла \sphinxcode{\sphinxupquote{items\_part1.txt}} и \sphinxcode{\sphinxupquote{items\_part2.txt}}.

\sphinxAtStartPar
\sphinxincludegraphics{{cat_files}.png}

\sphinxAtStartPar
Можно использовать \sphinxcode{\sphinxupquote{cat}} для склеивания содержимого нескольких файлов: укажите несколько файлов после cat, затем \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} и имя файла, в который нужно слить данные. Символы \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} означают перенаправление потока, т.е. мы делаем вывод не в стандартный поток, а, например, в файл.

\sphinxAtStartPar
\sphinxincludegraphics{{cat_wiring}.png}

\sphinxAtStartPar
С помощью cat можно пронумеровать строки в файлах сквозной нумерацией.

\sphinxAtStartPar
\sphinxincludegraphics{{cat_numbering}.png}

\sphinxAtStartPar
\sphinxstylestrong{Hint: посмотрите также команды \sphinxcode{\sphinxupquote{head}} и \sphinxcode{\sphinxupquote{tail}}, они выводят начало и конец файлов. \sphinxcode{\sphinxupquote{tail}} будет удобен для просмотра журнала логов.}

\sphinxAtStartPar
\sphinxstylestrong{Hint: \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} и \sphinxcode{\sphinxupquote{\textgreater{}}} перенаправляют поток и создают файл, если его нет. Отличие состоит в том, что \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} добавляет новое содержимое в конец файла, а \sphinxcode{\sphinxupquote{\textgreater{}}} перезаписывает файл, удаляя предыдущее содержимое этого файла.}


\subsection{echo}
\label{\detokenize{educational_materials/bash/content:echo}}
\sphinxAtStartPar
Обычно используется в скриптах для вывода информации (как \sphinxcode{\sphinxupquote{print}} в \sphinxcode{\sphinxupquote{python}}). Также с помощью \sphinxstylestrong{echo} можно записать строку в файл, если файла не было, он будет создан.

\sphinxAtStartPar
\sphinxincludegraphics{{echo}.png}


\subsection{export}
\label{\detokenize{educational_materials/bash/content:export}}
\sphinxAtStartPar
Используется для установки переменных среды. Команда \sphinxcode{\sphinxupquote{export}} отмечает переменную окружения для экспорта с любым новым дочерним процессом, и это позволяет дочернему процессу наследовать все отмеченные переменные. Они нам понадобятся для того, чтобы использовать ту информацию, которую мы не хотим прописывать в коде приложения, например, параметры доступа. Хардкодить такие значения неудобно, так как можно случайно закоммитить их, и придется все менять. Например, так сделано в проекте по созданию \sphinxhref{https://github.com/gcatanese/SampleTelegramQuiz}{чат\sphinxhyphen{}бота}, посмотрите секцию \sphinxstylestrong{Setup} в README. Ниже приведен пример использования \sphinxcode{\sphinxupquote{export}}.

\sphinxAtStartPar
\sphinxincludegraphics{{export}.png}

\sphinxAtStartPar
Подробнее с вариантами использования \sphinxcode{\sphinxupquote{export}} можно ознакомиться \sphinxhref{https://www.digitalocean.com/community/tutorials/export-command-linux}{здесь}.


\subsection{\$}
\label{\detokenize{educational_materials/bash/content:id3}}
\sphinxAtStartPar
Есть несколько конструкций, в которые входит \sphinxcode{\sphinxupquote{\$}}. Это может путать, но если относиться к этим конструкциям, как к обособленными элементам \sphinxcode{\sphinxupquote{bash}}, так их легче воспринимать.

\sphinxAtStartPar
Символ \sphinxcode{\sphinxupquote{\$}} ставится перед переменной для того, чтобы получить ее значение. По умолчанию любое имя считается строкой.

\sphinxAtStartPar
\sphinxincludegraphics{{variable_value}.png}

\sphinxAtStartPar
При этом использование \sphinxcode{\sphinxupquote{\$}} внутри двойных кавычек и без них может вызвать разное поведение, если в значении переменной содержатся специальные символы. Если \sphinxcode{\sphinxupquote{\$}} используется в двойных кавычках, то значение переменной будет выдено как есть. Если \sphinxcode{\sphinxupquote{\$}} используется без кавычек, то \sphinxcode{\sphinxupquote{bash}} проведет интерпретацию специальных символов, например, как ниже с \sphinxcode{\sphinxupquote{*}}, которую мы использовали для поиска файлов по шаблону.

\sphinxAtStartPar
Другое использование \sphinxcode{\sphinxupquote{\$}} — запись вывода команды в переменную. В этом случае \sphinxcode{\sphinxupquote{\$}} используется совместно со скобками.

\sphinxAtStartPar
\sphinxincludegraphics{{command_output_save}.png}

\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{bash}} нельзя просто так взять и выполнить математическую операцию. Для этого используется \sphinxcode{\sphinxupquote{\$}} совместно с двойными скобками.

\sphinxAtStartPar
\sphinxincludegraphics{{math_operations}.png}

\sphinxAtStartPar
Также \sphinxcode{\sphinxupquote{\$}} используется для получения значений аргументов, переданных в скрипт. Можно считать, что сама оболочка присваивает номера переменным вместо того, чтобы именовать их. Это похоже на то, как мы используем \sphinxcode{\sphinxupquote{sys.argv{[}N{]}}} в \sphinxcode{\sphinxupquote{python}}, когда хотим получить то, что передано при вызове нашей программы.

\sphinxAtStartPar
\sphinxincludegraphics{{arguments_numbering}.png}

\sphinxAtStartPar
Первая команда на скриншоте выше используется для того, чтобы создать код скрипта. Вы также можете взять код из двойных кавычек \sphinxcode{\sphinxupquote{echo "First is \$1 and second is \$2"}} и сохранить его в файл \sphinxcode{\sphinxupquote{script.bash}}, используя любой текстовый редактор. Описание \sphinxcode{\sphinxupquote{chmod}} смотрите ниже.

\sphinxAtStartPar
Есть еще один вариант использования \sphinxcode{\sphinxupquote{\$}}, но на этот раз с фигурными скобками. Это назвается parameter expansion и позволяет произвести операции над значениями переменной и передать результат дальше. Ниже пример со строкой \sphinxcode{\sphinxupquote{name=ArtemVesnin}} и срезами, а также со списком \sphinxcode{\sphinxupquote{name=(Artem Vesnin)}} и обращением к элементам списка.

\sphinxAtStartPar
\sphinxincludegraphics{{parameter_expansion}.png}

\sphinxAtStartPar
Также существует специальная переменная \sphinxcode{\sphinxupquote{\$?}}, куда записывается статус выполнения последней команды.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls\PYG{+w}{ }non\PYGZus{}existent\PYGZus{}file.txt
\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}?}\PYG{+w}{ }\PYGZhy{}ne\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{  }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Error: File not found or other issue occurred.\PYGZdq{}}
\PYG{k}{fi}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{command_output_status}.png}

\sphinxAtStartPar
Здесь мы использовали \sphinxcode{\sphinxupquote{test}} для проведения операций сравнения. \sphinxcode{\sphinxupquote{\sphinxhyphen{}eq}} сокращенно от equal.


\subsection{rm — remove}
\label{\detokenize{educational_materials/bash/content:rm-remove}}
\sphinxAtStartPar
Для удаления файлов используется команда \sphinxstylestrong{rm}. Удалить можно один файл, указав путь до него, или несколько, указав ту часть пути, которая может меняться через \sphinxcode{\sphinxupquote{*}}, т.е. задав шаблон, в который должны вписаться пути.

\sphinxAtStartPar
\sphinxincludegraphics{{rm}.png}

\sphinxAtStartPar
Удаление каталогов требует дополнительных опций, так как удаляются не отдельные файлы, а все содержимое каталога, поэтому нужно делать это рекурсивно, заходя во все вложенные каталоги.

\sphinxAtStartPar
\sphinxincludegraphics{{rm_dir_content}.png}


\subsection{rmdir — remove directory}
\label{\detokenize{educational_materials/bash/content:rmdir-remove-directory}}
\sphinxAtStartPar
Удаление пустых директорий или группы вложенных пустых директорий.

\sphinxAtStartPar
\sphinxincludegraphics{{rmdir}.png}

\sphinxAtStartPar
Обратите внимание на сообщение об ошибке (вообще всегда смотрите на результат ваших действий, чтобы понимать, выполнилась ли команда). Часть работы была сделана: удалены директории \sphinxcode{\sphinxupquote{./a/b}} и \sphinxcode{\sphinxupquote{./a}}. А самый верхний уровень этого пути (\sphinxcode{\sphinxupquote{.}}) — это, как мы помним, текущая директория, т.е. \sphinxcode{\sphinxupquote{\textasciitilde{}/project/data}}, и rmdir сам не дает пользователю удалить директорию, в которой он находится. Правильным будет \sphinxcode{\sphinxupquote{mkdir \sphinxhyphen{}p a/b}}, хотя в большинстве случаев ./a/b и a/b равнозначны.

\sphinxAtStartPar
\sphinxincludegraphics{{rmdir_level}.png}


\subsection{cp — copy}
\label{\detokenize{educational_materials/bash/content:cp-copy}}
\sphinxAtStartPar
Копирует один или несколько файлов из одного места в другое. Так же, как и в случае с \sphinxcode{\sphinxupquote{rm}}, можно указывать шаблон, которому должны соответствовать пути.

\sphinxAtStartPar
\sphinxincludegraphics{{cp}.png}


\subsection{mv — move}
\label{\detokenize{educational_materials/bash/content:mv-move}}
\sphinxAtStartPar
Перемещает один или несколько файлов из одного места в другое. Так же, как и в случае с \sphinxcode{\sphinxupquote{rm}}, можно указывать шаблон, которому должны соответствовать пути.

\sphinxAtStartPar
\sphinxincludegraphics{{move}.png}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mv}} можно использовать для переименования файлов.

\sphinxAtStartPar
\sphinxincludegraphics{{rename}.png}


\subsection{chmod — change mode}
\label{\detokenize{educational_materials/bash/content:chmod-change-mode}}
\sphinxAtStartPar
Изменяет разрешения файлов и директорий. Помните, на рисунке, который уже был выше, \sphinxcode{\sphinxupquote{script.bash}} подсвечивался зеленым? Это означало, что у него есть разрешение на исполнение. Давайте удалим его. Создадим скрипт заново и запишем туда строку \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l}} с помощью \sphinxcode{\sphinxupquote{echo}}, попробуем выполнить, получим ошибку, потом попробуем дать разрешение на исполнение и выполним еще раз.

\sphinxAtStartPar
\sphinxincludegraphics{{chmod}.png}

\sphinxAtStartPar
Разрешения делятся на три категории:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{r}}} \sphinxstyleemphasis{(read)} — чтение;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{w}}} \sphinxstyleemphasis{(write)} — запись;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{x}}} \sphinxstyleemphasis{(execute)} — исполнение.

\end{itemize}

\sphinxAtStartPar
А также на три уровня:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Владелец файла или директории.

\item {} 
\sphinxAtStartPar
Группа пользователей, к которой принадлежит владелец.

\item {} 
\sphinxAtStartPar
Все остальные.

\end{enumerate}

\sphinxAtStartPar
К примеру, права доступа \sphinxcode{\sphinxupquote{{[}drwxrwxrwx{]}}} дают полный доступ на чтение, редактирование и запуск абсолютно всем пользователям. Рассмотрим этот случай подробнее. Ключи доступа из примера можно поделить на 4 секции: 1 — \sphinxcode{\sphinxupquote{{[}d{]}}}, 2 — \sphinxcode{\sphinxupquote{{[}rwx{]}}}, 3 — \sphinxcode{\sphinxupquote{{[}rwx{]}}}, 4 — \sphinxcode{\sphinxupquote{{[}rwx{]}}}.

\sphinxAtStartPar
1 секция может быть либо «d» — директория, либо «\sphinxhyphen{}» — файл.
2 секция показывает права доступа владельца файла или директории (r — чтение, w — запись, x — выполнение).
3 секция показывает права доступа группы, в которой находится владелец, rwx — аналогично.
4 секция показывает права доступа всех остальных пользователей системы.

\sphinxAtStartPar
Например, \sphinxcode{\sphinxupquote{\sphinxhyphen{}rwxr\sphinxhyphen{}xr\sphinxhyphen{}\sphinxhyphen{}}} означает, что владелец может читать, писать и исполнять файл, пользователи из группы — только читать и исполнять, все остальные — только читать. Можно вообще не давать разрешений, например, \sphinxcode{\sphinxupquote{\sphinxhyphen{}rwxr\sphinxhyphen{}x\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}}} запретит доступ к файлу всем пользователям, кроме его владельца (того, кто создал этот файл) и участникам группы, к которой он относится.
\begin{quote}

\sphinxAtStartPar
Все группы, созданные в системе, находятся в файле /etc/group. Посмотрев содержимое этого файла, вы увидите список групп linux, которые уже есть в вашей системе. Этот список может быть большим и малоинформативным для рядового пользователя. Чтобы вывести список всех групп, членом которых является текущий пользователь, можно использовать команду \sphinxcode{\sphinxupquote{groups}}.
\end{quote}


\subsection{sudo — superuser do}
\label{\detokenize{educational_materials/bash/content:sudo-superuser-do}}
\sphinxAtStartPar
В большинстве случае для выполнения команд описанных, выше достаточно обычных прав, которые имеются у пользователя. Но в ряде случаев, при использовании системных утилит или смене владельца у файла (см. \sphinxcode{\sphinxupquote{chown}} ниже), необходимо использовать права суперпользователя. Первый способ — авторизоваться, используя аккаунт суперпользователя в системе. Но такой сценарий не является предпочтительным, так может привести к случайному выполнению команды, которая может нанести вред системе. Более широкое применение получил способ, при котором для выполнения команды с правами суперпользователя перед командой добавляется \sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo}}}. Ниже представлен пример передачи владения скрипта пользователю root, после этого мы сможем выполнять скрипт только от имени нового владельца, т.е. \sphinxcode{\sphinxupquote{root}} (для текущих разрешений скрипта \sphinxcode{\sphinxupquote{\sphinxhyphen{}rwxrwxr\sphinxhyphen{}\sphinxhyphen{}}}).

\sphinxAtStartPar
\sphinxincludegraphics{{sudo}.png}


\subsection{chown — change owner}
\label{\detokenize{educational_materials/bash/content:chown-change-owner}}
\sphinxAtStartPar
Изменяет владельца файла или директории. При этом, если вы хотите сделать это рекурсивно, для всех файлов внутри директории, нужно указать специальный флаг \sphinxcode{\sphinxupquote{\sphinxhyphen{}R}} для рекурсивной работы. При использовании мы указываем имя пользователя и группу через двоеточие \sphinxcode{\sphinxupquote{username:group}}. Каждый пользователь может состоять в одной или нескольких группах. Можно менять владельца и не менять группу. В примере ниже мы вернули владение группе \sphinxcode{\sphinxupquote{artem}}, и теперь можем запускать файл от обычного пользователя (для текущих разрешений скрипта \sphinxcode{\sphinxupquote{\sphinxhyphen{}rwxrwxr\sphinxhyphen{}\sphinxhyphen{}}}).

\sphinxAtStartPar
\sphinxincludegraphics{{chown}.png}


\subsection{history}
\label{\detokenize{educational_materials/bash/content:history}}
\sphinxAtStartPar
Выводит историю выполненных команд.

\sphinxAtStartPar
\sphinxincludegraphics{{history}.png}


\subsection{grep — global regular expression print}
\label{\detokenize{educational_materials/bash/content:grep-global-regular-expression-print}}
\sphinxAtStartPar
Производит поиск в тексте строки, содержащей определенную подстроку. При этом текст можно получить прямо из стандартного вывода или из файла. Бывает полезным, чтобы вспомнить, как выполнялась та или иная команда в \sphinxcode{\sphinxupquote{bash}}.

\sphinxAtStartPar
\sphinxincludegraphics{{grep_history}.png}

\sphinxAtStartPar
Также можно облегчить себе поиск документации по \sphinxcode{\sphinxupquote{man}}, если примерно помнить термин.

\sphinxAtStartPar
\sphinxincludegraphics{{grep_man}.png}

\sphinxAtStartPar
Или найти что\sphinxhyphen{}нибудь в документе, который вы читаете:

\sphinxAtStartPar
\sphinxincludegraphics{{grep_file}.png}

\sphinxAtStartPar
\sphinxstylestrong{Hint: \sphinxcode{\sphinxupquote{|}} перенаправляет выходной поток от одной команды к входу другой. Можно использовать, чтобы миновать запись в файл на диске.}


\subsection{top — table of process}
\label{\detokenize{educational_materials/bash/content:top-table-of-process}}
\sphinxAtStartPar
Выводит активные процессы, а также информацию по загрузке процессора и памяти. Информация будет обновляться в терминале. Чтобы выйти из этого режима, нажмите \sphinxcode{\sphinxupquote{Ctrl\sphinxhyphen{}C}}.

\sphinxAtStartPar
\sphinxincludegraphics{{top}.png}

\sphinxAtStartPar
\sphinxstylestrong{Hint: \sphinxcode{\sphinxupquote{htop}} дополняет функциональность \sphinxcode{\sphinxupquote{top}}. Поставьте \sphinxcode{\sphinxupquote{htop}} через менеджер пакетов, который используется в вашем дистрибутиве (\sphinxcode{\sphinxupquote{sudo apt install htop}} в Ubuntu).}


\subsection{Практические примеры}
\label{\detokenize{educational_materials/bash/content:id4}}
\sphinxAtStartPar
Ниже мы рассмотрим несколько примеров использования \sphinxcode{\sphinxupquote{bash}} и еще раз повторим написанное в мотивации к этому уроку: рассматривайте \sphinxcode{\sphinxupquote{bash}} как дополнительный инструмент, который может облегчить решение некоторых задач. Ради тренировки можно написать, например, калькулятор, но его легко сделать на вашем любимом языке программирования гораздо быстрее, поэтому ниже мы рассмотрим примеры, которые используют доступ к системным утилитам и позволяют нам получить информацию о подключенных устройствах и их состоянии.


\subsubsection{Мониторинг подключения usb\sphinxhyphen{}устройств}
\label{\detokenize{educational_materials/bash/content:usb}}
\sphinxAtStartPar
Ниже приведены примеры скрипта, отслеживающего подключение и отключение usb\sphinxhyphen{}устройства (\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Define the log file path}
\PYG{n+nv}{LOG\PYGZus{}FILE}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}./usb\PYGZhy{}monitor.log\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Get the initial list of connected USB devices}
\PYG{n+nv}{initial\PYGZus{}devices}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}lsusb\PYG{k}{)}

\PYG{c+c1}{\PYGZsh{} Function to log the events}
log\PYGZus{}event\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{event\PYGZus{}time}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{\PYGZdl{}(}date\PYG{+w}{ }+\PYG{l+s+s1}{\PYGZsq{}\PYGZpc{}Y\PYGZhy{}\PYGZpc{}m\PYGZhy{}\PYGZpc{}d \PYGZpc{}H:\PYGZpc{}M:\PYGZpc{}S\PYGZsq{}}\PYG{k}{)}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{event\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{device\PYGZus{}id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}2}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}event\PYGZus{}time}\PYG{l+s+s2}{ | }\PYG{n+nv}{\PYGZdl{}event\PYGZus{}type}\PYG{l+s+s2}{ | }\PYG{n+nv}{\PYGZdl{}device\PYGZus{}id}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}LOG\PYGZus{}FILE}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{o}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Function to check for new devices}
check\PYGZus{}devices\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{do}
\PYG{+w}{        }\PYG{n+nv}{current\PYGZus{}devices}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}lsusb\PYG{k}{)}
\PYG{+w}{        }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}initial\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }sort\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./idev.txt\PYGZdq{}}
\PYG{+w}{        }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}current\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }sort\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./cdev.txt\PYGZdq{}}
\PYG{+w}{        }\PYG{n+nv}{new\PYGZus{}devices}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}comm\PYG{+w}{ }\PYGZhy{}13\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./idev.txt\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./cdev.txt\PYGZdq{}}\PYG{k}{)}
\PYG{+w}{        }\PYG{n+nv}{removed\PYGZus{}devices}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}comm\PYG{+w}{ }\PYGZhy{}13\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./cdev.txt\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}./idev.txt\PYGZdq{}}\PYG{k}{)}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}new\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }!\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{+w}{        }\PYG{k}{then}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }device\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}new\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{                }log\PYGZus{}event\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}connected\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}device}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{            }\PYG{k}{done}
\PYG{+w}{        }\PYG{k}{fi}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}removed\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }!\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{+w}{        }\PYG{k}{then}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }device\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}removed\PYGZus{}devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{                }log\PYGZus{}event\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}disconnected\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}device}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{            }\PYG{k}{done}
\PYG{+w}{        }\PYG{k}{fi}
\PYG{+w}{        }\PYG{n+nv}{initial\PYGZus{}devices}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}current\PYGZus{}devices}
\PYG{+w}{        }sleep\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{} Adjust the update interval as needed}
\PYG{+w}{    }\PYG{k}{done}
\PYG{o}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Start monitoring, just call check\PYGZus{}devices()}
check\PYGZus{}devices
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим ряд конструкций, которые доступны в обычном языке программирования, например, условные операторы, циклы, функции. Реализация их в \sphinxcode{\sphinxupquote{bash}} имеет свои особенности, но понять их синтаксис несложно, если вы знаете хотя бы один язык программирования. Вызов функции также имеет особенности, например, мы передаем аргументы не в скобках, а после вызова функции. Особенности использования \sphinxcode{\sphinxupquote{\$}} мы рассмотрели выше.

\sphinxAtStartPar
В скрипте мы используем новую команду \sphinxcode{\sphinxupquote{comm}}, которая сравнивает два файла и выводит результат в три колонки, вторая из которых — строки, уникальные для второго файла (что находится в других колонках, можно посмотреть в документации \sphinxcode{\sphinxupquote{man comm}}). Аргументы \sphinxcode{\sphinxupquote{\sphinxhyphen{}13}} удаляют колонки 1 и 3, оставляя только вторую. Поэтому мы меняем файлы местами, чтобы определить \sphinxcode{\sphinxupquote{new\_devices}} и \sphinxcode{\sphinxupquote{removed\_devices}}. Функция \sphinxcode{\sphinxupquote{log\_event()}} записывает информацию о новых или отключенных устройствах в файл. Обратите внимание на вызов \sphinxcode{\sphinxupquote{check\_devices}} в конце скрипта.

\sphinxAtStartPar
Мы проверяем устройства каждую секунду \sphinxcode{\sphinxupquote{sleep 1}}, поэтому при быстром подключении и отключении можем потерять информацию о событии. Далее мы рассмотрим пример того, как этого избежать.

\sphinxAtStartPar
Также мы использовали команду \sphinxcode{\sphinxupquote{test}}, которая производит сравнение аргументов с использовании логических операторов. Вы можете встреть \sphinxcode{\sphinxupquote{{[}"\$new\_devices" != ""{]}}} вместо \sphinxcode{\sphinxupquote{test "\$new\_devices" != ""}}, это одно и то же.


\subsubsection{Мониторинг подключения устройств с помощью dmesg}
\label{\detokenize{educational_materials/bash/content:dmesg}}
\sphinxAtStartPar
Выше мы рассмотрели скрипт для мониторинга usb\sphinxhyphen{}устройств с помощью \sphinxcode{\sphinxupquote{lsusb}}. В Линукс есть команда для мониторинга всех сообщений, которые появляются в системе. Мы можем настроить шаблоны, которые позволят нам отфильтровать нужные нам сообщения. Ниже приведен пример, которые позволит отловить все сообщения, где встречается подстрока «usb». При этом, в отличие от скрипта с \sphinxcode{\sphinxupquote{lsusb}}, мы лучше защищены от потери события, так как dmesg выводит сообщения из буфера, который хранит не только последнее сообщение, но и историю сообщений (\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{n+nv}{prev\PYGZus{}records}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}dmesg\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tail\PYG{+w}{ }\PYGZhy{}20\PYG{k}{)}
\PYG{+w}{ }
monitor\PYGZus{}devices\PYGZus{}records\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}

\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{n+nb}{true}
\PYG{+w}{    }\PYG{k}{do}
\PYG{+w}{        }\PYG{n+nv}{curr\PYGZus{}records}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}dmesg\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tail\PYG{+w}{ }\PYGZhy{}20\PYG{k}{)}
\PYG{+w}{        }\PYG{n+nv}{new\PYGZus{}records}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}comm\PYG{+w}{ }\PYGZhy{}13\PYG{+w}{ }\PYGZlt{}\PYG{o}{(}\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}prev\PYGZus{}records}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}\PYG{+w}{ }\PYGZlt{}\PYG{o}{(}\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}curr\PYGZus{}records}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{)}\PYG{o}{)}
\PYG{+w}{        }\PYG{n+nv}{usb\PYGZus{}records}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}new\PYGZus{}records}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }grep\PYG{+w}{ }usb\PYG{k}{)}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}usb\PYGZus{}records}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }!\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{+w}{        }\PYG{k}{then}
\PYG{+w}{            }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}usb\PYGZus{}records}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{        }\PYG{k}{fi}
\PYG{+w}{        }\PYG{n+nv}{prev\PYGZus{}records}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}curr\PYGZus{}records}
\PYG{+w}{    }\PYG{k}{done}
\PYG{o}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} Start monitoring}
monitor\PYGZus{}devices\PYGZus{}records
\end{sphinxVerbatim}


\subsubsection{Мониторинг оставшегося места на диске}
\label{\detokenize{educational_materials/bash/content:id5}}
\sphinxAtStartPar
Скрипт, приведенный ниже мониторит доступное на диске место и предупреждает, когда процент занятого места превышен. Конструкцию \sphinxcode{\sphinxupquote{\$\{\}}} мы описывали выше. Из нового мы видим конструкцию \sphinxcode{\sphinxupquote{(\$df\_record)}}, которая позволяет создать список из значения переменной \sphinxcode{\sphinxupquote{df\_record}}, например, «one two three» \(\rightarrow\) («one», «two», «three») (\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{n+nv}{monitor\PYGZus{}device}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{}device to monitor eg. /dev/sdc1}
\PYG{n+nv}{alert\PYGZus{}level}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}2}\PYG{+w}{     }\PYG{c+c1}{\PYGZsh{}available percentage to alert eg. 1}
\PYG{+w}{ }
monitor\PYGZus{}space\PYGZus{}usage\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}

\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{n+nb}{true}
\PYG{+w}{    }\PYG{k}{do}
\PYG{+w}{        }\PYG{n+nv}{df\PYGZus{}record}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}df\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }grep\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}monitor\PYGZus{}device}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}
\PYG{+w}{        }\PYG{n+nv}{df\PYGZus{}record\PYGZus{}array}\PYG{o}{=}\PYG{o}{(}\PYG{n+nv}{\PYGZdl{}df\PYGZus{}record}\PYG{o}{)}
\PYG{+w}{        }\PYG{n+nv}{avail}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{df\PYGZus{}record\PYGZus{}array}\PYG{p}{[3]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n+nv}{total}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{df\PYGZus{}record\PYGZus{}array}\PYG{p}{[1]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYG{k}{\PYGZdl{}((}\PYG{+w}{ }\PYG{l+m}{100}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}avail}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}total}\PYG{k}{))}\PYG{+w}{ }\PYGZhy{}le\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}alert\PYGZus{}level}
\PYG{+w}{        }\PYG{k}{then}
\PYG{+w}{            }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Alert disk is almost full\PYGZdq{}}
\PYG{+w}{        }\PYG{k}{fi}
\PYG{+w}{        }sleep\PYG{+w}{ }\PYG{l+m}{1}
\PYG{+w}{    }\PYG{k}{done}
\PYG{o}{\PYGZcb{}}

monitor\PYGZus{}space\PYGZus{}usage
\end{sphinxVerbatim}

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/bash/exercises:id1}}\label{\detokenize{educational_materials/bash/exercises::doc}}
\sphinxAtStartPar
В описании задач дается название утилит, которые можно использовать для ее решения. Предполагается, что вы самостоятельно найдете правильные параметры, используя документацию \sphinxcode{\sphinxupquote{man имя\_утилиты}} или поиск в сети.


\subsection{Задача 1}
\label{\detokenize{educational_materials/bash/exercises:id2}}
\sphinxAtStartPar
Напишите скрипт, который будет делать резервную копию файла. Резервный файл должен содержать дату создания в имени.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{n+nv}{file\PYGZus{}to\PYGZus{}backup}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}myfile.txt\PYGZdq{}}
\PYG{n+nv}{backup\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{backup\PYGZus{}}\PYG{k}{\PYGZdl{}(}date\PYG{+w}{ }+\PYG{l+s+s1}{\PYGZsq{}\PYGZpc{}Y\PYGZpc{}m\PYGZpc{}d\PYGZpc{}H\PYGZpc{}M\PYGZpc{}S\PYGZsq{}}\PYG{k}{)}\PYG{l+s+s2}{.txt}\PYG{l+s+s2}{\PYGZdq{}}
cp\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}file\PYGZus{}to\PYGZus{}backup}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}backup\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Backup created: }\PYG{n+nv}{\PYGZdl{}backup\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/bash/exercises:id3}}
\sphinxAtStartPar
Напишите скрипт, который удaлит файлы старше 30 дней в выбранной директории. Используйте утилиту \sphinxcode{\sphinxupquote{find}} для поиска файлов. В пути до файлов, включая имя файлов, не должно быть пробелов и специальных символов. В этой задаче предполагается, что пути содержат только латинские буквы, цифры, тире и подчеркивания.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Define the directory to search in and the days threshold}
\PYG{n+nv}{directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/path/to/directory\PYGZdq{}}
\PYG{n+nv}{days\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m}{30}

\PYG{c+c1}{\PYGZsh{} Store the output of the find command in a variable}
\PYG{n+nv}{found\PYGZus{}paths}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}find\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}directory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}type\PYG{+w}{ }f\PYG{+w}{ }\PYGZhy{}mtime\PYG{+w}{ }+\PYG{n+nv}{\PYGZdl{}days\PYGZus{}threshold}\PYG{k}{)}

\PYG{c+c1}{\PYGZsh{} Iterate through the paths and remove each file}
\PYG{k}{for}\PYG{+w}{ }path\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}found\PYGZus{}paths}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{    }rm\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}path}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Deleted: }\PYG{n+nv}{\PYGZdl{}path}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{done}
\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/bash/exercises:id4}}
\sphinxAtStartPar
Напишите скрипт, который будет мониторить использование памяти определенным процессом, например, вашей программой, и ежесекундно записывать в файл объем использованной памяти. Используйте утилиту \sphinxcode{\sphinxupquote{ps}} для получения информации о процессе и \sphinxcode{\sphinxupquote{awk}} для получения суммарного объема использованной памяти.

\sphinxAtStartPar
Cкрипт \sphinxcode{\sphinxupquote{memory\_monitor.sh}} написать так, чтобы его можно было использовать, как показано ниже:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Launch your program (replace \PYGZdq{}./my\PYGZus{}program\PYGZdq{} with the actual command to run your program)}
./my\PYGZus{}program\PYG{+w}{ }\PYG{p}{\PYGZam{}}

\PYG{c+c1}{\PYGZsh{} Capture the PID of the launched program}
\PYG{n+nv}{program\PYGZus{}pid}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}!}

\PYG{c+c1}{\PYGZsh{} Start the monitoring script with the captured PID as an argument}
./memory\PYGZus{}monitor.sh\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}program\PYGZus{}pid}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} File to store the memory usage data}
\PYG{n+nv}{output\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}memory\PYGZus{}usage\PYGZus{}log.txt\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Header for the output file (if it doesn\PYGZsq{}t exist)}
\PYG{k}{if}\PYG{+w}{ }\PYG{o}{[}\PYG{+w}{ }!\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}output\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Datetime Memory\PYGZus{}Usage(KB)\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}output\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{fi}

\PYG{c+c1}{\PYGZsh{} Function to get memory usage of the process by PID}
get\PYGZus{}memory\PYGZus{}usage\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{pid}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{memory\PYGZus{}usage}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}ps\PYG{+w}{ }\PYGZhy{}o\PYG{+w}{ }\PYG{n+nv}{rss}\PYG{o}{=}\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}pid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }awk\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZob{} sum+=\PYGZdl{}1 \PYGZcb{} END \PYGZob{} print sum \PYGZcb{}\PYGZsq{}}\PYG{k}{)}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}memory\PYGZus{}usage}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{o}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Check if a process ID was provided as an argument}
\PYG{k}{if}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }\PYGZhy{}z\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Usage: }\PYG{n+nv}{\PYGZdl{}0}\PYG{l+s+s2}{ \PYGZlt{}process\PYGZus{}id\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nb}{exit}\PYG{+w}{ }\PYG{l+m}{1}
\PYG{k}{fi}

\PYG{c+c1}{\PYGZsh{} Main loop to monitor and log memory usage}
\PYG{k}{while}\PYG{+w}{ }true\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{    }\PYG{n+nv}{datetime}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}date\PYG{+w}{ }+\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}Y\PYGZhy{}\PYGZpc{}m\PYGZhy{}\PYGZpc{}d \PYGZpc{}H:\PYGZpc{}M:\PYGZpc{}S\PYGZdq{}}\PYG{k}{)}
\PYG{+w}{    }\PYG{n+nv}{pid}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nv}{memory\PYGZus{}usage}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}get\PYGZus{}memory\PYGZus{}usage\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}pid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}

\PYG{+w}{    }\PYG{c+c1}{\PYGZsh{} Append data to the output file}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}datetime}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}memory\PYGZus{}usage}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}output\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{+w}{    }\PYG{c+c1}{\PYGZsh{} Wait for 1 second before the next iteration}
\PYG{+w}{    }sleep\PYG{+w}{ }\PYG{l+m}{1}
\PYG{k}{done}
\end{sphinxVerbatim}


\subsection{Задача 4}
\label{\detokenize{educational_materials/bash/exercises:id5}}
\sphinxAtStartPar
Напишите скрипт, который будет проверять доступность cайта. Это может пригодиться во многих приложениях, когда происходит отправка данных или работоспособность одного приложения зависит от другого, расположенного на другом сервере. Используйте утилиту \sphinxcode{\sphinxupquote{curl}}, которая позволяет делать запросы.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{n+nv}{website}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}https://example.com\PYGZdq{}}
\PYG{n+nv}{response}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}curl\PYG{+w}{ }\PYGZhy{}Is\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}website}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }head\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{k}{)}
\PYG{k}{if}\PYG{+w}{ }\PYG{o}{[}\PYG{o}{[}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}response}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }*\PYG{l+s+s2}{\PYGZdq{}200 OK\PYGZdq{}}*\PYG{+w}{ }\PYG{o}{]}\PYG{o}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Website is reachable.\PYGZdq{}}
\PYG{k}{else}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Website is down or unreachable.\PYGZdq{}}
\PYG{k}{fi}
\end{sphinxVerbatim}


\subsection{Задача 5}
\label{\detokenize{educational_materials/bash/exercises:id6}}
\sphinxAtStartPar
Напишите скрипт для мониторинга портов, открытых на удаленной машине. Для этого используйте утилиту \sphinxcode{\sphinxupquote{nc}}.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Remote website to check (replace example.com and 80 with the appropriate values)}
\PYG{n+nv}{remote\PYGZus{}host}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}example.com\PYGZdq{}}
\PYG{n+nv}{port}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}80\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Function to check if the port is open on the remote site}
check\PYGZus{}port\PYGZus{}open\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{host}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}
\PYG{+w}{    }\PYG{n+nb}{local}\PYG{+w}{ }\PYG{n+nv}{port}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}2}
\PYG{+w}{    }nc\PYG{+w}{ }\PYGZhy{}z\PYG{+w}{ }\PYGZhy{}w5\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}host}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}port}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}/dev/null\PYG{+w}{ }\PYG{l+m}{2}\PYGZgt{}\PYG{p}{\PYGZam{}}\PYG{l+m}{1}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{o}{[}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}?}\PYG{+w}{ }\PYGZhy{}eq\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }\PYG{o}{]}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{        }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Port }\PYG{n+nv}{\PYGZdl{}port}\PYG{l+s+s2}{ is open on }\PYG{n+nv}{\PYGZdl{}host}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{        }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Port }\PYG{n+nv}{\PYGZdl{}port}\PYG{l+s+s2}{ is closed or unreachable on }\PYG{n+nv}{\PYGZdl{}host}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{k}{fi}
\PYG{o}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Call the function to check the port}
check\PYGZus{}port\PYGZus{}open\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}remote\PYGZus{}host}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}port}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/bash/quiz:id1}}\label{\detokenize{educational_materials/bash/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что означает \#!/bin/bash в начале bash\sphinxhyphen{}скрипта?

\item {} 
\sphinxAtStartPar
Как вы объявляете и используете переменные в bash?

\item {} 
\sphinxAtStartPar
Какова цель оператора if в bash?

\item {} 
\sphinxAtStartPar
Как написать цикл for в bash для перебора списка элементов?

\item {} 
\sphinxAtStartPar
Каково значение \$0, \$1, \$2 и т. д. в bash\sphinxhyphen{}скрипте?

\item {} 
\sphinxAtStartPar
Как вы выполняете арифметические операции в bash?

\item {} 
\sphinxAtStartPar
Как использовать условные операторы (например, if, elif, else) в bash?

\item {} 
\sphinxAtStartPar
Как вы перенаправляете ввод и вывод в bash?

\item {} 
\sphinxAtStartPar
В чем разница между \sphinxcode{\sphinxupquote{\textgreater{}}} и \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}}?

\item {} 
\sphinxAtStartPar
Что такое подстановка команд и как вы их используете в bash? \sphinxstylestrong{Ответ}: способ записать вывод команды в переменную, например: \sphinxcode{\sphinxupquote{current\_date=\$(date +"\%Y\sphinxhyphen{}\%m\sphinxhyphen{}\%d")}} или \sphinxcode{\sphinxupquote{current\_date=\$(date +"\%Y\sphinxhyphen{}\%m\sphinxhyphen{}\%d")}}.

\item {} 
\sphinxAtStartPar
Как вы используете grep для обработки текста в bash?

\item {} 
\sphinxAtStartPar
Что такое функции в bash и как их определить и вызвать?

\item {} 
\sphinxAtStartPar
Как вы обрабатываете аргументы командной строки в сценарии bash?

\item {} 
\sphinxAtStartPar
Как вы можете проверить, существует ли файл или каталог в bash?

\item {} 
\sphinxAtStartPar
Как вы создаете и используете массивы в bash?

\item {} 
\sphinxAtStartPar
Как запустить сценарий bash в фоновом режиме и отключить его от терминала?

\end{enumerate}


\chapter{Система контроля версий Git}
\label{\detokenize{index:git}}
\sphinxstepscope


\section{Git}
\label{\detokenize{educational_materials/git_base/content:git}}\label{\detokenize{educational_materials/git_base/content::doc}}

\subsection{Система контроля версий Git}
\label{\detokenize{educational_materials/git_base/content:id1}}
\sphinxAtStartPar
Трудно определить точное количество людей, использующих Git. Тем не менее, Git широко применяется разработчиками и организациями по всему миру и считается самой популярной системой контроля версий.

\sphinxAtStartPar
\sphinxincludegraphics{{Git-Logo-2Color}.png}

\sphinxAtStartPar
\sphinxstylestrong{Git} — это система управления версиями (\sphinxstyleemphasis{Version Control System, VCS}) с распределенным контролем состояния репозитория. Это значит, что каждый разработчик имеет полную копию репозитория (директория, содержащая все файлы проекта и историю изменений этих файлов) на локальном компьютере. Это позволяет команде разработчиков работать с кодом проекта одновременно и без конфликтов.


\subsection{Краткий исторический экскурс}
\label{\detokenize{educational_materials/git_base/content:id2}}
\sphinxAtStartPar
Git — это система контроля версий, созданная Линусом Торвальдсом в 2005 году. Она была разработана как средство для обслуживания ядра Linux, но в настоящее время широко используется в различных проектах и доменах. Основная цель Git — предоставить быстрый и надежный способ хранения и контроля версий кода, чтобы разработчики могли легко отслеживать изменения, откатывать их и работать в команде.

\sphinxAtStartPar
Согласно отчету GitHub Octoverse за 2019 год, на GitHub было более 40 миллионов пользователей, и большинство из них используют Git в качестве своей системы контроля версий. Кроме того, в отчете говорится, что на GitHub было более 100 миллионов репозиториев, и только в 2019 году в эти репозитории было внесено более 2,1 миллиарда материалов.

\sphinxAtStartPar
Помимо \sphinxstyleemphasis{\sphinxstylestrong{GitHub}}, \sphinxstyleemphasis{\sphinxstylestrong{Git}} также используется на других платформах, таких как \sphinxstyleemphasis{\sphinxstylestrong{GitLab}} и \sphinxstyleemphasis{\sphinxstylestrong{Bitbucket}}, а также разработчиками, которые размещают свои собственные репозитории \sphinxstyleemphasis{\sphinxstylestrong{Git}}. Поэтому можно с уверенностью сказать, что миллионы разработчиков используют Git для контроля версий и совместной работы. В целом, использование \sphinxstyleemphasis{Git} постоянно растет, поскольку он широко применяется разработчиками, различными организациями и корпорациями по всему миру, став негласным стандартом.

\sphinxAtStartPar
Выполним несколько простых действий, чтобы начать работать с этим крутым инструментом. Для начала нужно определиться с целью: поскольку \sphinxstyleemphasis{\sphinxstylestrong{Git}} — это прежде всего инструмент для удобной и эффективной работы команды разработчиков с кодом, мы сформулируем следующую задачу:
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{Мы команда IT стартапа. У нас есть исходный код нашего продукта. Мы планируем его развивать, а также добавлять новый функционал, расширяя его возможности. Также мы планируем постепенно подключать к работе новых разработчиков. Делиться кодом в соцсетях, как и с помощью облачных сервисов, ненадежно и опасно как для нашего проекта, так и для пользователей нашего продукта. В таком случае всегда есть риск «порчи кода», кражи интеллектуальной собственности, роста ошибок и уязвимостей в коде из\sphinxhyphen{}за отсутствия единой системы контроля версий. Мы будем использовать тестовый код, представленный ниже.}
\end{quote}


\subsection{Приступаем к использованию Git}
\label{\detokenize{educational_materials/git_base/content:id3}}
\sphinxAtStartPar
Скачаем приложение \sphinxstyleemphasis{\sphinxstylestrong{Git}} c официального сайта: https://git\sphinxhyphen{}scm.com и установим его на компьютер.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_git_download}.png}

\sphinxAtStartPar
В случае, если вы используете ОС Windows, выберите подходящий вариант, соответствующий разрядности вашей ОС (x64, x32).

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_git_download_windows64}.png}

\sphinxAtStartPar
Запустите установочный файл и следуйте инструкциям.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_install_git_windows}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_install_progress}.png}

\sphinxAtStartPar
В результате у вас должно отобразиться следующее окно, сообщающее об успешной установке Git на ваш компьютер.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_finish_install}.png}

\sphinxAtStartPar
После завершения установки убедимся в том, что \sphinxstyleemphasis{\sphinxstylestrong{Git}} корректно установился на компьютер и мы можем приступать к работе. Для этого откроем командную строку в Windows и введем команду \sphinxstylestrong{git}, как это показано на рисунке 2.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_command_git_console}.png}

\sphinxAtStartPar
Рисунок 2 — Командная строка Windows с введенной командой git

\sphinxAtStartPar
В окне консоли должна отобразиться информация о командах \sphinxstylestrong{Git}, как показано на риcунке 2.
\begin{quote}

\sphinxAtStartPar
Если у вас возникли проблемы, попробуйте удалить git из системы и повторить процесс установки, внимательно следуя инструкциям и указаниям программы\sphinxhyphen{}установщика git.
\end{quote}


\subsection{Тестовый код программы}
\label{\detokenize{educational_materials/git_base/content:id4}}
\sphinxAtStartPar
В качестве примера будем использовать код тестовой программы, разработанной на языке Python, для наглядной работы с системой контроля версий git. Тестовая программа выполняет запрос на сервис погоды \sphinxstyleemphasis{OpenWeatherMap}, используя обращение к сервису по API, затем полученный результат записывается в базу данных SQLite.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{requests}
\PYG{k+kn}{import} \PYG{n+nn}{sqlite3}
\PYG{c+c1}{\PYGZsh{} Connect to the SQLite database}
\PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.db}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{cursor} \PYG{o}{=} \PYG{n}{conn}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create a table to store the data}
\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{CREATE TABLE IF NOT EXISTS weather (}
\PYG{l+s+s2}{id INTEGER PRIMARY KEY,}
\PYG{l+s+s2}{city TEXT,}
\PYG{l+s+s2}{temperature REAL}
\PYG{l+s+s2}{)}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Make a request to the API}
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{https://api.openweathermap.org/data/2.5/weather? }
\PYG{l+s+s2}{q=London\PYGZam{}appid=your\PYGZus{}api\PYGZus{}key}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{response} \PYG{o}{=} \PYG{n}{requests}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{response}\PYG{o}{.}\PYG{n}{json}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Extract the relevant data}
\PYG{n}{city} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{temperature} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{main}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{temp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Insert the data into the table}
\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO weather (city, temperature) VALUES (?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} 
               \PYG{p}{(}\PYG{n}{city}\PYG{p}{,} \PYG{n}{temperature}\PYG{p}{)}
              \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Commit the changes to the database}
\PYG{n}{conn}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Close the connection to the database}
\PYG{n}{conn}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Описание тестовой программы}
\label{\detokenize{educational_materials/git_base/content:id5}}
\sphinxAtStartPar
Эта программа сначала подключается к базе данных SQLite с именем \sphinxstyleemphasis{\sphinxstylestrong{example.db}} и создает таблицу с именем \sphinxstyleemphasis{\sphinxstylestrong{weather}}, если она еще не существует.
Затем она делает запрос к общедоступному API (в данном случае API OpenWeatherMap), используя библиотеку запросов \sphinxstyleemphasis{\sphinxstylestrong{requests}}. Ответ от API анализируется как JSON, и из него извлекаются необходимые данные.
Наконец, данные вставляются в таблицу \sphinxstyleemphasis{\sphinxstylestrong{weather}} в базе данных SQLite с помощью оператора вставки SQL, и изменения фиксируются.

\sphinxAtStartPar
Обратите внимание, что вам нужно заменить \sphinxstyleemphasis{\sphinxstylestrong{your\_api\_key}} на ваш собственный ключ API из \sphinxstyleemphasis{OpenWeatherMap} API, иначе данный код не будет работать. Кроме того, на вашем компьютере должна быть установлена библиотека \sphinxstyleemphasis{sqlite3}, она используется для работы с базой данных SQLite.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Важно иметь в виду, что этот код является примером, и в нем отсутствуют многие важные детали, которые должны учитываться перед выпуском проекта в виде готового продукта}.
Например, обработка ошибок и исключительных ситуаций, таких как сбои соединения, ошибки API и возможные ошибки выполнения SQL\sphinxhyphen{}запроса к СУБД. Также данный код не учитывает должным образом вопросы безопасности. Используя данный тестовый код, разработчики должны понимать, какие недостатки в нем присутствуют.
\end{quote}


\subsection{Оформление рабочего каталога}
\label{\detokenize{educational_materials/git_base/content:id6}}
\sphinxAtStartPar
Для удобства работы с файлами проекта создадим директорию с названием \sphinxstylestrong{my\_project}, например, на диске \sphinxstylestrong{\sphinxcode{\sphinxupquote{D:\textbackslash{}}}}. Можно выбрать другое расположение папки с проектом. В качестве примера далее будем считать, что путь к файлам проекта выглядит следующим образом: «\sphinxstylestrong{D:\textbackslash{}my\_project}».

\sphinxAtStartPar
Перейдем в директорию с нашим проектом (\sphinxstylestrong{my\_project}) и вызовем командную строку, как показано на рисунке 3. Для этого нужно нажать на строку, содержащую путь к текущей папке, ввести команду \sphinxstyleemphasis{cmd} и нажать на клавиатуре кнопку \sphinxstyleemphasis{Enter}.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_start_console_cmd}.png}

\sphinxAtStartPar
Рисунок 3 — Вызов командной строки в текущей папке

\sphinxAtStartPar
После выполнения данной команды должно отобразиться окно консоли (рисунок 4). В этом окне мы продолжим работу с Git.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_console_cmd}.png}

\sphinxAtStartPar
Рисунок 4 — Командная строка в текущей папке проекта


\subsection{Настройка конфигурации git}
\label{\detokenize{educational_materials/git_base/content:id7}}
\sphinxAtStartPar
Перед тем как приступить к работе с кодом, нужно выполнить краткую настройку Git, а именно — указать имя пользователя и почтовый адрес. Эта информация используется системой Git для отслеживания операций всех пользователей проекта в репозитории. Это нужно сделать только один раз, при работе с другим проектом вам не придется повторно указывать имя пользователя и почтовый адрес.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Команда git
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
git config \textendash{}global user.name «Ivan Ivanov»
&
\sphinxAtStartPar
Изменяем имя пользователя в git
\\
\sphinxhline
\sphinxAtStartPar
git config \textendash{}global user.email my\_email@example.com
&
\sphinxAtStartPar
Изменяем название почты пользователя
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Ниже представлен пример выполнения данных команд в консоли Git:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{git} \PYG{n}{config} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{k}{global} \PYG{n}{user}\PYG{o}{.}\PYG{n}{name} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ivan Ivanov}\PYG{l+s+s2}{\PYGZdq{}} 
 \PYG{n}{git} \PYG{n}{config} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{k}{global} \PYG{n}{user}\PYG{o}{.}\PYG{n}{email} \PYG{n}{my\PYGZus{}email}\PYG{n+nd}{@example}\PYG{o}{.}\PYG{n}{com}	 
\end{sphinxVerbatim}

\sphinxAtStartPar
Репозиторий — это каталог, в котором располагаются все файлы одного проекта. В нашем случае у нас есть каталог «\sphinxstylestrong{my\_project}», его мы и будет использовать. В итоге у вас должно получиться так же, как показано на рисунке 5.

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_global_config_user}.png}

\sphinxAtStartPar
Если вы хотите проверить используемую конфигурацию, можете применить команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git config \sphinxhyphen{}\sphinxhyphen{}list}}}, чтобы показать все настройки Git текущего репозитория:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{user}\PYG{o}{.}\PYG{n}{name}\PYG{o}{=} \PYG{n}{Ivan} \PYG{n}{Ivanov}
\PYG{n}{user}\PYG{o}{.}\PYG{n}{email}\PYG{o}{=} \PYG{n}{my\PYGZus{}email}\PYG{n+nd}{@example}\PYG{o}{.}\PYG{n}{com}
\PYG{n}{color}\PYG{o}{.}\PYG{n}{status}\PYG{o}{=}\PYG{n}{auto}
\PYG{n}{color}\PYG{o}{.}\PYG{n}{branch}\PYG{o}{=}\PYG{n}{auto}
\PYG{n}{color}\PYG{o}{.}\PYG{n}{interactive}\PYG{o}{=}\PYG{n}{auto}
\PYG{n}{color}\PYG{o}{.}\PYG{n}{diff}\PYG{o}{=}\PYG{n}{auto}
\end{sphinxVerbatim}

\sphinxAtStartPar
Также вы можете проверить значение конкретного ключа, выполнив \sphinxstylestrong{\sphinxcode{\sphinxupquote{git config \textless{}key\textgreater{}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{config} \PYG{n}{user}\PYG{o}{.}\PYG{n}{name}
\PYG{n}{Ivan} \PYG{n}{Ivanov}
\end{sphinxVerbatim}

\sphinxAtStartPar
Если вам нужна помощь при использовании Git, есть три способа открыть страницу руководства по любой команде:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{help} \PYG{o}{\PYGZlt{}}\PYG{n}{команда}\PYG{o}{\PYGZgt{}}
\PYG{n}{git} \PYG{o}{\PYGZlt{}}\PYG{n}{команда}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{help}
\end{sphinxVerbatim}

\sphinxAtStartPar
Например, так можно открыть руководство по команде \sphinxstylestrong{\sphinxcode{\sphinxupquote{git config}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{help} \PYG{n}{config}
\end{sphinxVerbatim}

\sphinxAtStartPar
После ввода имени пользователя и адреса электронной почты можно закончить с настройкой и перейти к знакомству с основными командами Git.

\sphinxAtStartPar
Для базового варианта использования Git достаточно знать всего несколько команд для ведения истории изменений.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}} создает в текущем каталоге новый подкаталог с именем \sphinxstylestrong{\sphinxcode{\sphinxupquote{.git}}}, содержащий все необходимые файлы и структуру git репозитория. На этом этапе ваш проект еще не находится под версионным контролем.

\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git add}}} добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита: \sphinxstylestrong{\sphinxcode{\sphinxupquote{git add \textless{}название файла\_1, название файла\_2\textgreater{}}}}. По умолчанию \sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit}}} использует лишь этот индекс, так что вы можете использовать \sphinxstylestrong{\sphinxcode{\sphinxupquote{git add}}} для сборки слепка вашего следующего коммита. Это одна из ключевых команд Git.

\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}} показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit}}} берет все данные, добавленные в индекс с помощью \sphinxstylestrong{\sphinxcode{\sphinxupquote{git add}}}, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git push}}} используется для установления связи с удаленным репозиторием, определения локальных изменений, отсутствующих в текущей версии кода, и собственно их передачи на удаленный репозиторий, например, \sphinxstyleemphasis{GitHub} или \sphinxstyleemphasis{Bitbucket}.

\item {} 
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git pull}}} работает как комбинация команд \sphinxstylestrong{\sphinxcode{\sphinxupquote{git fetch}}} и \sphinxstylestrong{\sphinxcode{\sphinxupquote{git merge}}}, т.е. Git вначале забирает изменения из указанного удаленного репозитория, а затем пытается объединить их (выполнить слияние) с текущим кодом (веткой).

\end{itemize}


\subsection{Первый пример работы с git}
\label{\detokenize{educational_materials/git_base/content:id8}}
\sphinxAtStartPar
Отлично! Теперь, когда мы настроили параметры нашего git и познакомились с основными командами, сделаем следующее:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Выполним инициализацию репозитория в папке с проектом.

\item {} 
\sphinxAtStartPar
Проверим статус нашего репозитория.

\item {} 
\sphinxAtStartPar
Добавим файл с тестовым кодом test\_project.py для отслеживания его изменений в git.

\item {} 
\sphinxAtStartPar
Создадим первый коммит и посмотрим, как изменится статус git.

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Шаг 1: Инициализация нашего рабочего каталога (репозитория)}
Когда вы инициализируете репозиторий командой \sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}}, Git создает ветку с именем \sphinxstylestrong{master} по умолчанию. В результате мы настроили рабочее окружение Git и выполнили инициализацию репозитория (рисунок 6).

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_git_init}.png}

\sphinxAtStartPar
Рисунок 6 — Вызов команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Шаг 2: Проверка статуса репозитория}
После того как был создан репозиторий, мы можем отслеживать все изменения (статус) в рабочей папке нашего проекта, вызвав команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}}. Что это значит? Дело в том, что после выполнения команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}} все изменения в директории \sphinxstyleemphasis{\sphinxstylestrong{my\_project}} будут контролироваться (отслеживаться) системой управления версиями Git. В директории \sphinxstyleemphasis{\sphinxstylestrong{my\_project}} есть файл \sphinxstyleemphasis{\sphinxstylestrong{test\_project.py}} с тестовым кодом на языке Python. Давайте выполним команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}}, как показано на рисунке 7.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_show_git_status}.png}

\sphinxAtStartPar
Рисунок 7 — Вызов команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}}

\sphinxAtStartPar
В результате работы команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}} мы видим несколько сообщений. Давайте разберемся, что они означают.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Сообщение Git
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
On branch master
&
\sphinxAtStartPar
Сообщение, в котором содержится информация о том, что мы находимся в ветке master.
\\
\sphinxhline
\sphinxAtStartPar
No commits yet
&
\sphinxAtStartPar
В текущий момент нет коммитов, готовых для их фиксации, внесения каких\sphinxhyphen{}либо подготовленных изменений в проект.
\\
\sphinxhline
\sphinxAtStartPar
Untracked files: use «git add …» to include in what will be committed test\_project.py
&
\sphinxAtStartPar
Найден файл «test\_project.py», который в данный момент находится в папке проекта, но его состояние пока не контролируется системой git. И дается справка о том, что для добавления этого файла нужно использовать команду git add.
\\
\sphinxhline
\sphinxAtStartPar
nothing added to commit but untracked files present (use «git add» to track)
&
\sphinxAtStartPar
Отсутствуют коммиты, но присутствуют неотслеживаемые файлы.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
С этого места давайте поподробней. Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}} вывела нам подробную информацию о том, в каком состоянии в данный момент находится наш проект с точки зрения системы контроля версий Git. В текущей директории есть файл \sphinxstylestrong{test\_project.py} с тестовым кодом, и пока что изменения этого файла никак не отслеживаются. Поскольку мы планируем работать с этим кодом и хотим знать, какие измения были внесены нами, либо кем\sphinxhyphen{}то из разработчиков нашей команды, нам нужно добавить его под контроль Git.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Шаг 3: Добавление файла для отслеживания изменений git}
Чтобы добавить файл для отслеживания его изменений, выполним команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git add test\_project.py}}}, как показано на рисунке 8.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_execute_git_add}.png}

\sphinxAtStartPar
Рисунок 8 — Вызов команды \sphinxcode{\sphinxupquote{git add}}

\sphinxAtStartPar
Выполним повторно вызов команды «\sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}}» и посмотрим, что изменилось (рисунок 9).

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_show_git_status_after_git_add}.png}

\sphinxAtStartPar
Рисунок 9 — Вызов \sphinxcode{\sphinxupquote{git status}} после выполнения команды \sphinxcode{\sphinxupquote{git add}}

\sphinxAtStartPar
Видим, что теперь текст сообщения несколько изменился. Изменилась строка с названием нашего тестового файла. Ранее она была выделена красным цветом (рисунок 6). Сейчас же эта строка выделена зеленым цветом, и добавилась приставка «\sphinxstylestrong{\sphinxcode{\sphinxupquote{new file: test\_project.py}}}». Это означает, что теперь Git начал следить за изменениями этого файла, но пока мы их не зафиксировали. Другими словами, Git увидел файл и готов зафиксировать это изменение. Для этого нам надо выполнить коммит (commit).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Шаг 4: Создаем коммит}
Чтобы сделать коммит (сохранить изменения и зафиксировать текущую версию), выполним следующую команду: \sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit \textendash{}m "текст сообщения — начинаем использовать git!"}}}.
На рисунке 10 видим, что Git обработал нашу команду и вернул результат, в котором сказано, что в ветке \sphinxstyleemphasis{\sphinxstylestrong{master}} изменен 1 файл, в который добавлено 26 строк.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_execute_git_commit_fix_change}.png}

\sphinxAtStartPar
Рисунок 10 — Создание первого коммита

\sphinxAtStartPar
Другими словами, до того, как мы добавили файл (\sphinxstylestrong{\sphinxcode{\sphinxupquote{git add}}}) и создали коммит (\sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit}}}), нашей системе Git нечего было отслеживать, поскольку в нем не было ни одного коммита. Теперь немного остановимся на самой команде «\sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit}}}».\\
После команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit}}} мы использовали параметр \sphinxstylestrong{\sphinxcode{\sphinxupquote{\textendash{}m}}} и в кавычках \sphinxstylestrong{\sphinxcode{\sphinxupquote{" "}}} написали сообщение для коммита. Это очень полезная фишка для комментирования изменений кода. Например, мы добавили в код новую функцию или исправили ошибку в работе программы и хотим зафиксировать это улучшение, кратко сформулировав смысл вносимых в код изменений.

\sphinxAtStartPar
Сейчас в нашем проекте «\sphinxstylestrong{test\_project.py}» нет проверок корректности данных, как и проверки наличия связи с удаленным сервером погоды (\sphinxstyleemphasis{OpenWeatherMap}). Когда мы добавим проверку корректности данных, нужно будет создать коммит и в качестве комментария указать:
«\sphinxstyleemphasis{Добавлена проверка кода ответа от сервера OpenWeatherMap. Если код ответа: 200, данные корректны, в другом случае возникает обработка исключительной ситуации}».

\sphinxAtStartPar
Конечно, помимо сообщения при создании коммита рекомендуется использовать комментарии в коде программы и вести документацию.

\sphinxAtStartPar
Для отслеживания всех изменений Git удобно использовать утилиту \sphinxstylestrong{\sphinxcode{\sphinxupquote{git\sphinxhyphen{}show}}} — это утилита командной строки, которая используется для просмотра подробных данных об объектах Git (рисунок 11).

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_execute_git_show_pretty}.png}

\sphinxAtStartPar
Рисунок 11 \textendash{} Отображение подробной информации вызовом команды \sphinxcode{\sphinxupquote{git show \sphinxhyphen{}\sphinxhyphen{}pretty}}

\sphinxAtStartPar
\sphinxstylestrong{Что делать, если ошибочно внесли неполное или некорректное описание коммита?}
В этом случае не стоит паниковать — всегда можно изменить содержание коммита. Чтобы изменить последний коммит, используйте команду: \sphinxstylestrong{\sphinxcode{\sphinxupquote{git commit \textendash{}amend}}}. После вызова команды откроется текстовый редактор, в котором можно изменить текст сообщения (рисунок 12).

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_view_new_message_commit}.png}

\sphinxAtStartPar
Рисунок 12 \textendash{} Окно редактора текста, в котором можно изменить последний коммит

\sphinxAtStartPar
После того, как вы внесете изменения в текст коммита, нужно сохранить изменения в этом файле. После этого в консоли отобразится «новое сообщение» измененного коммита (рисунок 13).

\sphinxAtStartPar
\sphinxincludegraphics{{git_base_edite_message_commit}.png}
Рисунок 13 — Отображение изменений коммита

\sphinxAtStartPar
Попробуйте внести изменения в файл «\sphinxstylestrong{test\_project.py}». Например, следующим образом:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{requests}
\PYG{k+kn}{import} \PYG{n+nn}{sqlite3}

\PYG{c+c1}{\PYGZsh{} Connect to the SQLite database}
\PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.db}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{cursor} \PYG{o}{=} \PYG{n}{conn}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create a table to store the data}
\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{CREATE TABLE IF NOT EXISTS weather (}
\PYG{l+s+s2}{    id INTEGER PRIMARY KEY,}
\PYG{l+s+s2}{    city TEXT,}
\PYG{l+s+s2}{    temperature REAL}
\PYG{l+s+s2}{)}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Make a request to the API}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{https://api.openweathermap.org/data/2.5/weather?}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}} \PYGZbs{}                      \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{q=London\PYGZam{}appid=your\PYGZus{}api\PYGZus{}key}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
	\PYG{n}{Response} \PYG{o}{=} \PYG{n}{requests}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
	\PYG{n}{Response}\PYG{o}{.}\PYG{n}{raise\PYGZus{}for\PYGZus{}status}\PYG{p}{(}\PYG{p}{)}
	
	\PYG{n}{data} \PYG{o}{=} \PYG{n}{response}\PYG{o}{.}\PYG{n}{json}\PYG{p}{(}\PYG{p}{)}
	\PYG{c+c1}{\PYGZsh{} Extract the relevant data}
	\PYG{n}{city} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
	\PYG{n}{temperature} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{main}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{temp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
	\PYG{c+c1}{\PYGZsh{} Insert the data into the table}
	\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO weather (city, temperature) VALUES (?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} 
                   \PYG{p}{(}\PYG{n}{city}\PYG{p}{,} \PYG{n}{temperature}\PYG{p}{)}\PYG{p}{)}
	\PYG{c+c1}{\PYGZsh{} Commit the changes to the database}
	\PYG{n}{conn}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
	\PYG{c+c1}{\PYGZsh{} Close the connection to the database}
	\PYG{n}{conn}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{except} \PYG{n}{requests}\PYG{o}{.}\PYG{n}{exceptions}\PYG{o}{.}\PYG{n}{HTTPError} \PYG{k}{as} \PYG{n}{err}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы добавили в код проверку возникновения исключительных событий. Исключения необходимы для того, чтобы сообщать программисту об ошибках, а также корректно их обрабатывать, чтобы избавиться от экстренного завершения работы программы. Сохраните изменения в файле с кодом и вызовите команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git status}}}. Посмотрите, какой будет результат.


\subsection{Вот несколько шагов, которые помогут начать работу с Git:}
\label{\detokenize{educational_materials/git_base/content:id9}}
\sphinxAtStartPar
Изучите основы: начните с основных команд Git, таких как \sphinxcode{\sphinxupquote{git init}}, \sphinxcode{\sphinxupquote{git add}}, \sphinxcode{\sphinxupquote{git commit}}, \sphinxcode{\sphinxupquote{git branch}}, \sphinxcode{\sphinxupquote{git checkout}}, \sphinxcode{\sphinxupquote{git merge}} и \sphinxcode{\sphinxupquote{git push}}. В Интернете есть множество ресурсов: учебные пособия, видеоролики и документация, которые могут помочь понять основные концепции и команды.
Лучший способ изучить Git — это использовать его. Создайте новый проект, возьмите наш тестовый проект или найдите проект с открытым исходным кодом и начните экспериментировать с командами Git. Совершайте коммиты, создавайте ветки и пробуйте разные сценарии рабочего процесса Git.


\subsection{Что такое публичный и приватный репозиторий?}
\label{\detokenize{educational_materials/git_base/content:id10}}
\sphinxAtStartPar
В Git репозиторий (или сокращенно «репо») — это набор файлов и каталогов, которые отслеживаются системой контроля версий. Репозиторий может быть как общедоступным, так и частным.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Общедоступный репозиторий. Общедоступный репозиторий — это репозиторий, доступный для всех, у кого есть URL\sphinxhyphen{}адрес репозитория. Любой может просмотреть файлы, загрузить их и сделать копию репозитория. Публичные репозитории часто используются для проектов с открытым исходным кодом, где каждый может внести свой вклад в код. Публичные репозитории также используются для обмена кодом с другими или для того, чтобы сделать код доступным для использования другими.

\item {} 
\sphinxAtStartPar
Частный репозиторий. Частный репозиторий недоступен никому, кроме людей, которым был предоставлен доступ. Эти репозитории часто используются для проектов с закрытым исходным кодом, где код не предназначен для общего доступа. Частные репозитории также используются для хранения кода, который не готов к публичному выпуску, или для конфиденциальной информации, которой не следует делиться с общественностью.
Основное различие между двумя типами репозиториев — в том, что общедоступные репозитории видны и доступны всем, а частные репозитории видны и доступны только избранной группе людей.
Стоит отметить, что большинство служб хостинга Git, таких как GitHub, GitLab, Bitbucket, предлагают как общедоступные, так и частные репозитории с разными ценами и ограничениями. Некоторые из них предлагают бесплатные планы для общедоступных репозиториев и взимают плату за частные.

\end{enumerate}

\sphinxAtStartPar
GitHub, GitLab и Bitbucket — популярные платформы хостинга Git, которые предоставляют как общедоступные, так и частные репозитории. На этих платформах вы можете сделать свой репозиторий общедоступным или частным при его создании. Вы также можете изменить видимость репозитория позже, но изменить его обратно может быть немного сложнее, если он общедоступный.
Важно помнить, что термины «общедоступные» и «частные» репозитории относятся к хостинговой платформе и пользователям, имеющим доступ к репозиторию, а не к Интернету в целом.


\subsection{Зафиксируйте изменения git}
\label{\detokenize{educational_materials/git_base/content:id11}}
\sphinxAtStartPar
Коммит — это моментальный снимок изменений, внесенных в файлы в репозитории Git. Он используется для сохранения и отслеживания хода проекта с течением времени. Вот шаги для фиксации изменений в Git:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Добавьте файлы в промежуточную область. Прежде чем делать фиксацию, вам необходимо добавить файлы, которые вы хотите включить в фиксацию, в промежуточную область. Вы можете сделать это, выполнив команду \sphinxcode{\sphinxupquote{git add file\sphinxhyphen{}name}} или \sphinxcode{\sphinxupquote{git add}}, чтобы добавить все измененные файлы.

\item {} 
\sphinxAtStartPar
Создайте фиксацию: после добавления файлов в область подготовки вы можете создать фиксацию. Используйте команду \sphinxcode{\sphinxupquote{git commit}} для создания коммита. Это откроет текстовый редактор по умолчанию, в котором вы можете написать сообщение фиксации.

\item {} 
\sphinxAtStartPar
Фиксация с сообщением: вместо того, чтобы открывать текстовый редактор по умолчанию, вы можете использовать флаг \sphinxcode{\sphinxupquote{\sphinxhyphen{}m}} для фиксации с сообщением, выполнив команду \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}m "Ваше сообщение фиксации"}}.

\item {} 
\sphinxAtStartPar
Зафиксировать с определенным файлом. Вы также можете зафиксировать определенный файл, выполнив команду \sphinxcode{\sphinxupquote{git commit имя\sphinxhyphen{}файла \sphinxhyphen{}m «Ваше сообщение о фиксации»}}.
Важно использовать четкие и описательные сообщения фиксации, которые объясняют сделанные изменения и причину, по которой они были сделаны. Это упрощает понимание истории проекта и помогает другим членам команды понять изменения.
Кроме того, вы также можете использовать команду \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}}, чтобы изменить последнюю фиксацию, или \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend \sphinxhyphen{}c original\sphinxhyphen{}commit}}, чтобы изменить предыдущую фиксацию.

\end{enumerate}


\subsection{Немного статистики о системе git}
\label{\detokenize{educational_materials/git_base/content:id12}}
\sphinxAtStartPar
Git — одна из наиболее широко используемых систем контроля версий в мире, и статистика ее использования отражает это. Вот некоторые показатели использования Git:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Популярность. Согласно опросу разработчиков Stack Overflow 2020, Git — самая популярная система контроля версий, которую используют более 88\% разработчиков.

\item {} 
\sphinxAtStartPar
Проекты с открытым исходным кодом. По данным GitHub, на их платформе размещено более 100 миллионов репозиториев, и большинство из них представляют собой проекты с открытым исходным кодом, использующие Git в качестве системы контроля версий.

\item {} 
\sphinxAtStartPar
Использование в отрасли: Git используется в самых разных отраслях, включая разработку программного обеспечения, финансы, здравоохранение и госуправление.

\item {} 
\sphinxAtStartPar
Кроссплатформенность: Git можно использовать в операционных системах Windows, Mac и Linux, что делает его кроссплатформенным инструментом.

\item {} 
\sphinxAtStartPar
Интеграция: Git можно интегрировать с широким спектром инструментов и сервисов, таких как GitHub, GitLab, Bitbucket, Jenkins и другими.

\item {} 
\sphinxAtStartPar
Совместная работа: Git позволяет нескольким людям одновременно работать над одной кодовой базой и имеет встроенные инструменты для совместной работы, такие как запросы на вытягивание и проверки кода.

\item {} 
\sphinxAtStartPar
Принятие: согласно официальному веб\sphinxhyphen{}сайту Git, более 100 000 организаций по всему миру используют Git для контроля версий.

\end{enumerate}

\sphinxAtStartPar
Эти статистические данные показывают, что Git — распространенный и универсальный инструмент, который используется большим количеством разработчиков и организаций по всему миру.


\chapter{Git как инструмент командной работы. Работа с удаленными репозиториями}
\label{\detokenize{index:id4}}
\sphinxstepscope


\section{Git как инструмент командной работы. Работа с удаленными репозиториями.}
\label{\detokenize{educational_materials/team_work_on_a_project/content:git}}\label{\detokenize{educational_materials/team_work_on_a_project/content::doc}}
\sphinxAtStartPar
Современный мир технологий и инноваций требует от специалистов не только глубоких знаний и навыков в своей области, но и умения эффективно сотрудничать в команде. Командная разработка стала неотъемлемой частью современного программирования, позволяя создавать сложные и инновационные продукты, которые были бы невозможны для одного разработчика. В данном учебном пособии мы погрузимся в мир командной работы, исследуя его принципы, лучшие практики и вызовы.

\sphinxAtStartPar
Так что же такое командная работа? Почему этому уделяется так много внимания? Посмотрим плейлист с записями видео докладов с конференции IT\sphinxhyphen{}шной компании, или в статьи на хабре и наверняка найдем что\sphinxhyphen{}нибудь про: «Работу в команде», «Управление проектом,» Эффективный менеджемнт» «Навыки Soft Skill», и много тому подобных тем. Глядя со стороны на эти темы, может показаться, что это глупости и ведь всё настолько очевидно, что нет смысла повторяться и говорить о том, «как одному разработчику в команде попросить о помощи другого», или «как мне соощить коллеге о найденном баге в его коде». Можно ведь просто позвонить ему и сообщить о своей находке, а можно самому исправить баг и позже сообщить коллеге при встрече. Наверняка каждый из нас сталкивался с подобной ситуацией. Однако, тут не всё так просто.

\sphinxAtStartPar
Работу в команде можно сравнить с системой автопилота самолета или беспилотного автомобиля. В которых за процессом управления непрерывно следят сотни или даже тысячи подсистем, информирующих бортовой компьютер о своем состоянии и показаниях датчиков. Таким образом, бортовой компьютер всегда обладает актуальной информацией и принимает лучшее решения для управления движением.

\sphinxAtStartPar
Аналогичным образом выглядит процесс управления разработкой IT проекта, в котором условный «бортовой компьютер» это «Руководитель проекта». Его роль \sphinxhyphen{} принимать эффективные решения, способствующие успешному запуску IT продукта и его дальнейшего развития. Как и у «бортового компьютера», у Руководителя проекта есть команда, с которой он взаимодействует, получает информацию, принимает управленческие решения. Например, расширить команду разработчиков, сформировать команду тестировщиков, разработать стратегию вывода продукта на рынок и т.д.

\sphinxAtStartPar
\sphinxstylestrong{Состав команды и их задачи в проекте разработки программного продукта}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Менеджер проекта:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Организует работу команды, следит за сроками и бюджетом.

\item {} 
\sphinxAtStartPar
Распределяет задачи между участниками и координирует их деятельность.

\item {} 
\sphinxAtStartPar
Составляет план разработки и следит за его выполнением.

\item {} 
\sphinxAtStartPar
Решает организационные и коммуникационные вопросы.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Архитектор:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определяет общую архитектуру продукта и его компонентов.

\item {} 
\sphinxAtStartPar
Разрабатывает технические решения и структуры системы.

\item {} 
\sphinxAtStartPar
Обеспечивает согласованность и соответствие архитектуры целям проекта.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработчики:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Отвечают за разработку кода, интеграцию со сторонними сервисами и реализацию дополнительной функциональности продукта.

\item {} 
\sphinxAtStartPar
Работают над конкретными модулями или компонентами.

\item {} 
\sphinxAtStartPar
Проводят тестирование своего кода и участвуют в код\sphinxhyphen{}ревью.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Тестировщики:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Занимаются тестированием функциональности продукта.

\item {} 
\sphinxAtStartPar
Разрабатывают тестовые сценарии и проводят автоматическое и ручное тестирование.

\item {} 
\sphinxAtStartPar
Выявляют и документируют ошибки и несоответствия в работе продукта.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Дизайнер/Интерфейсный дизайнер:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разрабатывает дизайн пользовательского интерфейса продукта.

\item {} 
\sphinxAtStartPar
Создает макеты, элементы дизайна и визуальные компоненты.

\item {} 
\sphinxAtStartPar
Обеспечивает удобство использования и эстетическое качество интерфейса.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Технический писатель/Разработчик документации и инструкций пользователя (User guide):}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разрабатывает документацию для продукта: руководства пользователя, API\sphinxhyphen{}документацию и т.д.

\item {} 
\sphinxAtStartPar
Обеспечивает четкость и понятность технической информации.

\item {} 
\sphinxAtStartPar
Взаимодействует с другими членами команды для сбора и структурирования информации.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Системный администратор/DevOps инженер:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Занимается настройкой инфраструктуры и серверов для разработки и развертывания продукта.

\item {} 
\sphinxAtStartPar
Обеспечивает автоматизацию процессов сборки, тестирования и развертывания.

\item {} 
\sphinxAtStartPar
Решает вопросы масштабирования и безопасности инфраструктуры.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Это классический состав команды, который охватывает основные этапы разработки программного продукта \textendash{} от планирования и проектирования до разработки, тестирования и документирования. Каждый участник команды вносит вклад в успешное выполнение проекта, обеспечивая высокое качество и соблюдение сроков.

\sphinxAtStartPar
С командой и её составом мы разобрались. Казалось бы, что этого достаточно \sphinxhyphen{} нужно чтоб каждый выполнял свои задачи и тогда всё будет работать как часы. И тут мы с вами подходим к главному вопросу: Как организовать и запустить рабочий процесс в команде так, чтоб каждый знал что ему нужно делать и понимал как взаимодействовать с коллегами в команде.

\sphinxAtStartPar
Конечно, мы можем «смоделировать ситуацию и мысленно представить этот рабочий процесс», как лучше поступить каждому участнику команды, выбрав на наш взгляд самый эффективный способ взаимодействия внутри команды. Каждый может это представить и будет по\sphinxhyphen{}своему прав.

\sphinxAtStartPar
Однако, в реальном мире всё несколько иначе. Каждый сотрудник должен уметь включаться в командную работу учитывая не только свои интересы, но также и интересы коллектива взаимодействуя в команде в которой имеются внутренние договоренности, нормы и правила. Если обратиться, к примеру «автопилота», то все системы взаимодействуют друг с другом посредством «протокола передачи данных». В протоколе прописаны «правила» и «критерии», которые должны соблюдать все устройства использующие этот протокол. Например, благодаря протоколу HTTP вы можете «серфить по интернету» и не важно, каким устройством (ноутбук, смартфон, планшет и т.д.) и какой канал связи (WiFi, Ethernet, 5G) вы используете. Вы сможете открыть любой сайт и выполнить действие. Например, оформить доставку пиццы и оплатить свой заказ. Требования к протоколам сформулированы в специальном документе \sphinxhyphen{} «техническом стандарте». Подробнее про стандарты и протоколы можете посмотреть в справочном материале.


\subsection{Знакомство с методом SCRUM}
\label{\detokenize{educational_materials/team_work_on_a_project/content:scrum}}
\sphinxAtStartPar
Для управления IT проектами часто можно услышать про методологию SCRUM

\sphinxAtStartPar
Методология SCRUM представляет собой гибкий подход к управлению проектами, ориентированный на совместную итеративную разработку программных продуктов. В ней выделяются следующие ключевые идеи:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Итеративность и поступательность}: Проект разбивается на небольшие временные интервалы, называемые спринтами, каждый продолжительностью 1\sphinxhyphen{}2 недели. Длительность спринта зависит от задач проекта и возможностей команды. Каждый спринт добавляет новую функциональность к продукту, или вносит серьезное изменение в существующий проект. Например, команда разрабатывает мобильную игру в которой с помощью «функциональных блоков» выстраивается стратегия игрока. Разработку нового типа «блока» с уникальным функционалом, который будет совместим с уже имеющимися блоками можно считать новой итерацией (шагом) в разработке игры. Эту задачу можно реализовать в пределах одного спринта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Роли и обязанности}: В SCRUM выделяются три ключевые роли: Продуктовый Владелец (Product Owner), Мастер SCRUMа (Scrum Master) и Разработчики. Каждая роль выполняет определенные функции для эффективной работы команды.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Бэклог продукта}: Это список задач и требований, представляющих потребности клиентов и пользователей. Бэклог продукта непрерывно обновляется, и наиболее приоритетные задачи планируются для выполнения в ближайших спринтах. В качестве инструмента для обозначения статуса задач и заметок используют «Канбан доску». Это инструмент визуализации рабочего процесса и управления задачами. Она представляет собой физическую или электронную доску, разделенную на несколько колонок, которые отражают различные этапы выполнения задач. Каждая задача представлена карточкой, которая перемещается по колонкам в зависимости от ее текущего статуса. Подробнее с этим инструментом познакомимся чуть позже.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Планирование спринта}: На начало каждого спринта команда выбирает задачи из бэклога продукта для выполнения. Задачи декомпозируются на более мелкие, оцениваются временем и планируются для достижения цели спринта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ежедневные стендапы}: Команда проводит короткие ежедневные встречи, на которых каждый член команды отвечает на три вопроса: «Что я сделал вчера?», «Что я собираюсь сделать сегодня?» и «Есть ли какие\sphinxhyphen{}либо препятствия?». Это помогает поддерживать прозрачность и обмен информацией.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Спринт\sphinxhyphen{}ревью и ретроспектива}: По завершении спринта проводится спринт\sphinxhyphen{}ревью, на котором команда представляет результаты продукту. Затем проводится спринт\sphinxhyphen{}ретроспектива, на которой анализируются успехи и уроки для улучшения процесса.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Адаптация}: Одной из ключевых идей SCRUM является постоянное совершенствование. Команда адаптируется к изменениям, основанным на обратной связи, и внедряет улучшения для повышения эффективности работы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Прозрачность и открытость}: В SCRUM поддерживается прозрачность во всех аспектах работы. Задачи, прогресс, проблемы и решения доступны всей команде, что способствует коллективной ответственности за успех проекта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Управление рисками}: SCRUM позволяет быстро выявлять риски и проблемы и реагировать на них в реальном времени. Это помогает минимизировать негативные воздействия на проект.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Цикличность и непрерывное улучшение}: Методология SCRUM ориентирована на непрерывное совершенствование процесса, продукта и команды. Постоянное обучение и адаптация помогают достигать лучших результатов.

\end{enumerate}

\sphinxAtStartPar
Использование методологии SCRUM в IT стартапе способствует быстрой разработке и поставке качественных продуктов, учету изменений и потребностей клиентов, а также эффективной командной работе.


\subsection{Знакомство с канбан\sphinxhyphen{}доской}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id1}}
\sphinxAtStartPar
\sphinxincludegraphics{{img_canban_desk_from_gigachat_3}.jpg}
Основная цель Канбан\sphinxhyphen{}доски \sphinxhyphen{} обеспечить прозрачность рабочего процесса чтоб каждый участник проекта мог видеть какие задачи ожидают решения в списке очереди, и кто в текущий момент выполняет какие задачи. Таким образом этот инструмент помогает управлять ресурсами и распределять рабочую нагрузку для оптимизации различных затрат, в том числе и временных. Задачи могут быть разбиты на подзадачи, приоритеты могут быть ясно видны, а вся команда может легко оценить текущее состояние проекта.

\sphinxAtStartPar
На Канбан\sphinxhyphen{}доске обычно используются следующие базовые колонки:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Backlog (Очередь задач)}: Эта колонка содержит задачи, которые пока не приступили к выполнению. Здесь формируется список задач, из которого команда будет брать новые задания для работы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{To Do (В работе)}: В этой колонке находятся задачи, над которыми в данный момент работают участники команды.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{In Progress (Выполняются)}: Задачи, которые находятся в процессе выполнения, перемещаются сюда после начала работы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Review (На проверке)}: После того как задача завершена, она переходит в эту колонку на проверку и ревью другими членами команды.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Done (Готово)}: Когда задача полностью выполнена и прошла проверку, она перемещается в эту колонку.

\end{enumerate}

\sphinxAtStartPar
Кроме базовых колонок, на доске могут быть добавлены и другие, в зависимости от потребностей команды и характера проекта. Например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blocked (Заблокировано)}: Здесь помещаются задачи, которые не могут быть продолжены из\sphinxhyphen{}за каких\sphinxhyphen{}либо проблем или зависимостей.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Testing (Тестирование)}: Задачи, находящиеся в этой колонке, ожидают проведения тестирования.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Deploy (Развертывание)}: Для задач, которые готовы к развертыванию, но еще не внедрены в продакшн.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Archived (Архив)}: Завершенные и проверенные задачи могут быть перемещены сюда, чтобы не засорять основную доску.

\end{itemize}

\sphinxAtStartPar
Выбор колонок зависит от особенностей проекта и его специфики. Например, разработка «чат\sphinxhyphen{}бота» и разработка «мобильного приложения» это 2 проекта которые отличаются как инструментами разработки, так и методами тестирования и внедрения. Следовательно, и колонки на Канбан доске будут отличаться как по количеству, так и по  их структура может быть адаптирована для соответствия рабочему процессу.
\sphinxincludegraphics{{sample_canban_desk_mobile_project}.png}


\subsection{Задача: Планирование и организация работы над разработкой чат\sphinxhyphen{}бота с использованием Канбан доски.}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id2}}
\sphinxAtStartPar
Описание задачи: Вашей задачей является разработка детального плана работы над проектом чат\sphinxhyphen{}бота с использованием методологии Канбан. Данный план должен включать в себя определение основных этапов разработки, колонок на Канбан доске и описание процесса перемещения задач между этими колонками. Вам также предстоит определить ответственных за каждый этап и роли в команде.

\sphinxAtStartPar
Шаги выполнения:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определение этапов разработки: Разбейте весь процесс разработки чат\sphinxhyphen{}бота на основные этапы, такие как проектирование, разработка, тестирование, ревью, развертывание и др.

\item {} 
\sphinxAtStartPar
Создание Канбан доски: Определите основные колонки на Канбан доске. Обычно это \sphinxstylestrong{Backlog}, \sphinxstylestrong{To Do}, \sphinxstylestrong{In Progress}, \sphinxstylestrong{Review}, \sphinxstylestrong{Testing}, \sphinxstylestrong{Done}.

\item {} 
\sphinxAtStartPar
Описание перемещения задач: Для каждой колонки опишите, какие задачи могут находиться в ней, и каким образом они будут перемещаться от этапа к этапу. Например, задачи могут начинать свой путь с \sphinxstylestrong{Backlog}, затем переходить в \sphinxstylestrong{To Do}, когда назначены на выполнение, далее в \sphinxstylestrong{In Progress} при начале работы и так далее.

\item {} 
\sphinxAtStartPar
Назначение ответственных: Определите, кто будет ответственным за каждый этап. Это может быть разработчик, тестировщик, ревьюер и т.д. Распределите роли в команде.

\item {} 
\sphinxAtStartPar
Установление временных рамок: Определите ожидаемое время выполнения для каждого этапа (спринта) и задачи. Это поможет вам лучше планировать и контролировать процесс разработки и оценивать время.

\item {} 
\sphinxAtStartPar
Создание доски: Воспользуйтесь инструментом для создания Канбан доски, например, онлайн\sphinxhyphen{}сервисами или физической доской с карточками.

\item {} 
\sphinxAtStartPar
Запуск работы: Начните работу с разработкой чат\sphinxhyphen{}бота в соответствии с описанным планом. Перемещайте задачи по Канбан доске, следите за прогрессом и корректируйте план при необходимости.

\item {} 
\sphinxAtStartPar
Внесение изменений: При необходимости, вносите изменения в Канбан доску, добавляя новые колонки или меняя порядок этапов. Главное, чтобы доска отражала текущий процесс и удовлетворяла потребности команды.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Цель задачи}: Разработать детальный план работы над проектом с использованием Канбан доски, который поможет команде эффективно организовать процесс разработки чат\sphinxhyphen{}бота, контролировать прогресс и достичь успешных результатов.


\subsection{Заключение}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id3}}
\sphinxAtStartPar
В данном блоке мы постарались кратко познакомиться вас с основными элементами командной работы на IT проектом: От начальных этапов планирования и определения ролей, до финального слияния кода и представления результатов, мы рассказали о ключевых шагах и важных уроках, которые вам помогут при выполнении совместной работы. Конечно, есть и много других тем, которые не были представлены в данном модуле, однако все они являются ветвями развития представленных базовых основ. Надеемся что вам удалость:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ознакомиться с принципами формирования эффективной команды разработчиков.

\item {} 
\sphinxAtStartPar
Понять, как распределение ролей и задач влияет на процесс работы над проектом.

\item {} 
\sphinxAtStartPar
Исследовать методы планирования и организации проекта в команде.

\item {} 
\sphinxAtStartPar
Узнать о инструментах и технологиях, которые облегчают командную разработку.

\item {} 
\sphinxAtStartPar
Погрузиться в аспекты совместной работы, решения конфликтов и обмена знаний.

\end{itemize}

\sphinxAtStartPar
Мы надеемся, что этот рассказ о командной работе станет вдохновением для тех, кто стремится к профессиональному росту и успешной совместной разработке. Надеемся что уроки, которые были представлены в этом модуле, помогут вам на пути к развитию навыков командной работы и созданию качественных технологических продуктов.


\subsubsection{Проверочные вопросы}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id4}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое методология Scrum и какие основные компоненты она включает?

\item {} 
\sphinxAtStartPar
Какие преимущества предоставляет методология Scrum при управлении IT\sphinxhyphen{}проектами?

\item {} 
\sphinxAtStartPar
Чем отличается Scrum Master от Product Owner в контексте Scrum?

\item {} 
\sphinxAtStartPar
Какие основные роли включает команда разработки в методологии Scrum и каковы их обязанности?

\item {} 
\sphinxAtStartPar
Что такое Sprint (итерация) в Scrum? Какие действия выполняются в рамках Sprint?

\item {} 
\sphinxAtStartPar
Что такое канбан доска и как она помогает в управлении проектом?

\item {} 
\sphinxAtStartPar
Какие принципы лежат в основе канбан методологии? Как она отличается от Scrum?

\item {} 
\sphinxAtStartPar
Какое значение имеет распределение ролей в команде проекта? Какие роли обычно включаются в команду разработки?

\item {} 
\sphinxAtStartPar
Какие ключевые навыки и характеристики важны для успешной работы в команде проекта?

\item {} 
\sphinxAtStartPar
Какие практики способствуют эффективной командной работе в IT\sphinxhyphen{}проекте?

\end{enumerate}


\bigskip\hrule\bigskip



\subsection{Справочная информация}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id5}}
\sphinxAtStartPar
В этом блоке представлена справочная информация, которая может послужить хорошим материалом, чтоб погрузиться в темы «Командная работы» и «Управление проектами». Представлен краткий анализ и сравнение различных методик управления проектами, а также некоторые подробности этапов их реализации. Также, здесь собраны краткие исторические факты и некоторые теоретические дополнения, которые помогут найти ответы, на некоторые вопросы, появившиеся при изучении основного материала.


\subsection{Роли каждого участника команды}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id6}}
\sphinxAtStartPar
\sphinxstylestrong{1. Программист:}
Программист отвечает за добавление нового функционала в игру. Например, он может работать над созданием новых типов блоков, улучшением алгоритма генерации фигур или добавлением новых игровых режимов. Программист анализирует код игры, понимает, какие изменения необходимы, и начинает их реализацию. Он также занимается тестированием своего кода, чтобы убедиться, что новый функционал работает корректно.

\sphinxAtStartPar
\sphinxstylestrong{2. Тестировщик:}
Тестировщик проверяет новый функционал на работоспособность и корректность. Он разрабатывает тестовые сценарии, которые покрывают различные аспекты игры с новым функционалом. Тестировщик также проводит тестирование на разных уровнях \sphinxhyphen{} от модульного тестирования до интеграционного тестирования. Если тесты выявляют ошибки или неполадки, тестировщик сообщает разработчику, чтобы проблемы могли быть исправлены.

\sphinxAtStartPar
\sphinxstylestrong{3. Технический писатель:}
Технический писатель разрабатывает документацию, которая объясняет, как использовать новый функционал игры. Это может быть руководство пользователя, описание новых игровых режимов или объяснение изменений для других разработчиков. Технический писатель обеспечивает четкость и понятность документации, чтобы пользователи или коллеги могли легко разобраться в новых возможностях игры.

\sphinxAtStartPar
\sphinxstylestrong{4. Менеджер проекта:}
Менеджер проекта координирует деятельность всей команды. Он следит за сроками выполнения задач, управляет ресурсами и обеспечивает коммуникацию внутри команды. Менеджер проекта также может помогать в планировании разработки нового функционала, распределять задачи между участниками и решать организационные вопросы. Важно, чтобы менеджер проекта обеспечивал эффективное взаимодействие между всеми участниками команды и следил за достижением целей проекта.

\sphinxAtStartPar
Каждый участник команды играет важную роль для достижения цели \sphinxhyphen{} успешной доработки игры «Тетрис». Их совместная работа, обмен знаниями и координация позволяют достичь хорошего результатов.


\subsection{Краткая история методологии SCRUM}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id7}}
\sphinxAtStartPar
История появления методологии SCRUM началась в мире разработки программного обеспечения в начале 1980\sphinxhyphen{}х годов. В то время компания Easel Corporation, занимавшаяся разработкой графических приложений, столкнулась с необходимостью улучшить свой подход к разработке, чтобы более эффективно управлять проектами и достигать более предсказуемых результатов.

\sphinxAtStartPar
В 1986 году, Джефф Сазерленд (Jeff Sutherland), занимавшийся исследованиями в области управления проектами, разработал первый прототип методологии SCRUM, который использовался внутри компании Easel. В 1993 году, Сазерленд и Кен Швабер (Ken Schwaber), также работавший в Easel, представили идеи SCRUM на конференции OOPSLA (Object\sphinxhyphen{}Oriented Programming, Systems, Languages \& Applications).

\sphinxAtStartPar
Следующие годы были периодом экспериментов, модификаций и совершенствования методологии SCRUM. Команда разработчиков, включая Сазерленда и Швабера, проводила исследования и тестировала принципы SCRUM на различных проектах. В 2001 году, на знаменитой встрече «Snowbird», группа специалистов по разработке программного обеспечения, включая Сазерленда и Швабера, сформулировала Манифест гибкой разработки программного обеспечения (Agile Manifesto), который включал в себя принципы, заложенные в SCRUM.

\sphinxAtStartPar
С тех пор SCRUM приобрел широкое признание и стал одним из самых популярных и успешных методологических фреймворков в области разработки программного обеспечения. Его применяют не только в IT\sphinxhyphen{}индустрии, но и во многих других отраслях, где важно быстро и гибко реагировать на изменения и достигать высококачественных результатов.

\sphinxAtStartPar
PMBOK, Agile и Scrum являются тремя разными методологиями и подходами к управлению проектами. Вот как они связаны между собой:

\sphinxAtStartPar
PMBOK (Project Management Body of Knowledge):
PMBOK \sphinxhyphen{} это набор стандартов и рекомендаций, разработанный Project Management Institute (PMI), который охватывает все ключевые аспекты управления проектами. Он включает в себя различные процессы, знания и практики, необходимые для эффективного управления проектами. PMBOK не привязан к конкретной методологии и может быть адаптирован к разным подходам.

\sphinxAtStartPar
Agile (гибкая методология):
Agile \sphinxhyphen{} это общий термин, описывающий группу методологий управления проектами, которые акцентируются на гибкости, сотрудничестве и быстрой адаптации к изменениям. Agile подходы ориентированы на достижение результатов через инкрементальное итеративное развитие, приоритизацию задач и активное взаимодействие с заказчиком.

\sphinxAtStartPar
Scrum:
Scrum \sphinxhyphen{} это конкретная методология Agile, которая представляет собой фреймворк для управления проектами. Он включает в себя роли (Product Owner, Scrum Master, Development Team), события (Sprint Planning, Daily Standup, Sprint Review, Sprint Retrospective) и артефакты (Product Backlog, Sprint Backlog, Increment), которые помогают командам разрабатывать продукт в коротких циклах (спринтах) с постоянной обратной связью и адаптацией.

\sphinxAtStartPar
Связь между ними:

\sphinxAtStartPar
PMBOK описывает широкий спектр практик управления проектами, включая традиционные методы.
Agile \sphinxhyphen{} это общий подход, который акцентирует внимание на гибкости и реагировании на изменения, и он может быть применен к разным методологиям.
Scrum \sphinxhyphen{} это конкретный фреймворк Agile, который предоставляет инструкции и инструменты для управления проектами с акцентом на сотрудничество и итеративное развитие.
Многие компании и команды применяют элементы Agile и Scrum в сочетании с PMBOK для создания гибкой и эффективной методологии управления проектами, которая учитывает как традиционные, так и инновационные подходы.


\subsection{Управление коммуникациями}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id8}}
\sphinxAtStartPar
«Управление коммуникациями» в рамках PMBOK охватывает планирование, выполнение и контроль коммуникаций внутри проектной команды и с заинтересованными сторонами. Эффективный обмен информацией и коммуникации считаются ключевыми элементами успешного управления проектом, поскольку они способствуют пониманию, сотрудничеству и принятию правильных решений. Вот подробнее об этом аспекте:


\subsection{Планирование коммуникаций:}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id9}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определение целей коммуникаций: Определение, что именно должно быть достигнуто через коммуникации в проекте.

\item {} 
\sphinxAtStartPar
Идентификация аудитории: Определение заинтересованных сторон, которым необходимо предоставить информацию и с кем следует поддерживать обмен.
Определение сообщений: Какие сообщения и какая информация будет распространяться.

\item {} 
\sphinxAtStartPar
Выбор методов и средств коммуникаций: Определение наиболее подходящих способов для достижения задач коммуникаций (например, встречи, отчеты, электронные письма и др.).

\item {} 
\sphinxAtStartPar
Разработка плана коммуникаций: Создание документированного плана, который описывает кто, что, когда и как будет коммуницировать.
Распределение коммуникаций:

\item {} 
\sphinxAtStartPar
Распространение информации: Отправка сообщений, предоставление данных и обмен информацией с членами команды и стейкхолдерами.

\item {} 
\sphinxAtStartPar
Своевременность и четкость: Гарантирование того, что коммуникации происходят вовремя и ясно, исключая неоднозначности.

\end{enumerate}


\subsection{Мониторинг и контроль коммуникаций:}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id10}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Оценка эффективности: Оценка, насколько эффективными являются методы коммуникаций и как достигается задачи.

\item {} 
\sphinxAtStartPar
Регулирование и улучшение: Если процесс коммуникаций не работает эффективно, регулирование методов и средств для улучшения взаимодействия.
Эффективное управление коммуникациями в проекте способствует более гладкому сотрудничеству между участниками команды, повышению осведомленности всех сторон о текущем состоянии проекта и позволяет решать проблемы и конфликты более оперативно.

\end{enumerate}

\sphinxAtStartPar
Управление коммуникациями в контексте небольшого IT стартапа, который применяет методологию SCRUM, играет важную роль в обеспечении эффективной командной работы, передаче информации и обмене знаний между участниками проекта. Важно поддерживать своевременную и прозрачную коммуникацию, чтобы участники проекта были в курсе всех изменений, задач и достигнутых результатов.


\subsection{Процесс управления коммуникациями в стартапе, использующем SCRUM, может выглядеть следующим образом:}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id11}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Daily Stand\sphinxhyphen{}ups}:
Ежедневные стендапы (Daily Stand\sphinxhyphen{}ups) \sphinxhyphen{} это короткие встречи, на которых каждый член команды делится своими достижениями, планами на день и возникшими препятствиями. Это позволяет всей команде быть в курсе актуальной ситуации, устранять блокирующие факторы и поддерживать синхронизацию работ.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Спринт\sphinxhyphen{}планирование}:
На начало каждого спринта проводится встреча спринт\sphinxhyphen{}планирования, где команда определяет, какие задачи будут выполнены в текущем спринте. На этой встрече важно провести детальное обсуждение и разъяснение задач, чтобы убедиться, что каждый член команды понимает свои обязанности.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Спринт\sphinxhyphen{}ревью}:
В конце спринта проводится спринт\sphinxhyphen{}ревью, на котором команда демонстрирует полученные результаты заказчику и другим заинтересованным сторонам. Это время для обратной связи и обсуждения проделанной работы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Спринт\sphinxhyphen{}ретроспектива}:
После спринт\sphinxhyphen{}ревью проводится спринт\sphinxhyphen{}ретроспектива, где команда анализирует прошлый спринт, выявляет положительные моменты и обсуждает, что можно улучшить. Это способ повысить эффективность командной работы и процессов.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Инструменты коммуникации}:
Важно выбрать подходящие инструменты для коммуникации, например, Slack, Microsoft Teams или Trello. Они позволяют обмениваться информацией, документами и управлять задачами в режиме реального времени.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Открытость и прозрачность}:
Коммуникация в стартапе должна быть открытой и прозрачной. Это означает делиться информацией о ходе проекта, достигнутых успехах и возникших проблемах. Это помогает создать атмосферу доверия и сотрудничества.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Управление изменениями}:
В ходе разработки стартап может столкнуться с изменениями в требованиях или приоритетах. Эти изменения также должны быть прозрачно обсуждены и приняты в команде.

\end{enumerate}

\sphinxAtStartPar
Управление коммуникациями в методологии SCRUM помогает снизить риски недопонимания, ускорить процесс принятия решений и создать единую видимость проекта для всех участников.


\subsubsection{Процесс управления в небольшом IT стартапе}
\label{\detokenize{educational_materials/team_work_on_a_project/content:it}}
\sphinxAtStartPar
Процесс управления в небольшом IT стартапе, который использует методологию SCRUM, ориентирован на достижение целей проекта через гибкое планирование, прозрачное выполнение задач и систематический анализ результатов. Процесс управления включает следующие ключевые этапы:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Планирование проекта}:
В начале проекта команда стартапа определяет общую картину целей, ожидаемые результаты и план спринтов. План спринтов включает список задач и приоритеты, которые будут выполнены в каждом спринте. Этот этап позволяет определить общий курс разработки и обеспечить общее понимание среди участников.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание бэклога продукта}:
Бэклог продукта представляет собой список задач, которые необходимо выполнить в проекте. Задачи в бэклоге приоритезируются, чтобы обеспечить максимальное добавление ценности для клиентов и пользователей.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Планирование спринта}:
Команда стартапа выбирает задачи из бэклога продукта для выполнения в следующем спринте. Задачи декомпозируются на меньшие подзадачи, оцениваются временем и приоритезируются в порядке их важности.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ежедневные стендапы}:
Каждый день команда проводит короткую встречу, на которой каждый член команды дает ответ на три вопроса: «Что я сделал вчера?», «Что я планирую сделать сегодня?» и «Есть ли какие\sphinxhyphen{}либо препятствия?». Это помогает участникам быть в курсе прогресса и обнаруживать проблемы в ранней стадии.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Выполнение спринта}:
Команда работает над задачами в течение спринта (обычно 2\sphinxhyphen{}4 недели). Разработчики регулярно обмениваются информацией и обсуждают прогресс. Промежуточные результаты показываются заказчику на спринт\sphinxhyphen{}ревью.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Спринт\sphinxhyphen{}ревью и ретроспектива}:
По завершении спринта проводится спринт\sphinxhyphen{}ревью, где демонстрируются результаты заказчику. Затем проводится спринт\sphinxhyphen{}ретроспектива, на которой команда анализирует, что было сделано хорошо и что можно улучшить.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Регулярные обзоры}:
Регулярно проводятся обзоры с заказчиком, на которых обсуждаются текущие задачи, изменения в приоритетах и выставляются оценки выполнения работ.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Анализ метрик}:
Команда стартапа анализирует ключевые метрики проекта, такие как скорость выполнения задач, качество продукта и удовлетворенность клиентов. Эти метрики помогают принимать решения и корректировать планы.

\end{enumerate}

\sphinxAtStartPar
Процесс управления в стартапе на базе SCRUM позволяет команде эффективно работать над проектом, реагировать на изменения в требованиях и быстро доставлять ценность клиентам. Гибкость и прозрачность методологии SCRUM способствуют успешной реализации проектов в условиях быстро меняющейся среды IT.


\subsubsection{Процесс управления проектом по PMBOK}
\label{\detokenize{educational_materials/team_work_on_a_project/content:pmbok}}
\sphinxAtStartPar
Процесс управления в контексте управления проектами, особенно как описано в стандарте PMBOK (Project Management Body of Knowledge), включает в себя множество активностей и шагов, необходимых для планирования, мониторинга, контроля и закрытия проекта. Процесс управления охватывает всю жизненный цикл проекта, начиная с его инициирования и заканчивая завершением.

\sphinxAtStartPar
Процесс управления включает следующие ключевые аспекты:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Инициирование}:
Этот этап включает в себя определение бизнес\sphinxhyphen{}целей, целей проекта и оценку его осуществимости. Важно также определить заинтересованных сторон и их ожидания от проекта. В результате этого этапа создается документ, называемый Хартером проекта, который формализует основные параметры проекта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Планирование}:
Планирование включает в себя разработку детального плана проекта, определение необходимых ресурсов, установление расписания, а также определение стратегий управления качеством, рисками, коммуникациями и другими аспектами. План проекта служит основой для выполнения и мониторинга.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Исполнение}:
На этом этапе команда проекта реализует план, выполняет запланированные работы и создает продукты или результаты, соответствующие требованиям проекта и ожиданиям заказчика.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Мониторинг и контроль}:
Этот этап включает постоянный мониторинг выполнения проекта по сравнению с планом. Если отклонения выявлены, то применяются корректирующие меры. Происходит оценка рисков и качества, а также обеспечивается соблюдение графика и бюджета.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Закрытие}:
В конце проекта проводится формальное закрытие, которое включает в себя проверку выполнения всех требований проекта, передачу результатов заказчику и завершение всех административных и финансовых аспектов.

\end{enumerate}

\sphinxAtStartPar
Процесс управления обеспечивает системный и структурированный подход к управлению проектом, который позволяет своевременно и эффективно достигать поставленных целей. Кроме того, он учитывает не только технические аспекты, но и социальные, коммуникационные и организационные аспекты управления проектом.


\subsubsection{Процесс решения задачи в команде: Как обдумать, детерминировать и выполнить задачу}
\label{\detokenize{educational_materials/team_work_on_a_project/content:id12}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Шаг
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1 \sphinxstylestrong{Понимание «Задачи и Разделение задач на простые части»}
&
\sphinxAtStartPar
Обсуждение задачи и разбиение ее на более мелкие управляемые части. Менеджер проекта и архитектор участвуют в этом процессе. Для создания страницы авторизации веб\sphinxhyphen{}приложения разбивается на подзадачи: «Создание формы ввода», «Подключение к базе данных», «Проверка данных пользователя» и т.д.
\\
\sphinxhline
\sphinxAtStartPar
2 \sphinxstylestrong{Назначение ответственных и установка приоритетов}
&
\sphinxAtStartPar
Каждая подзадача получает ответственного. Устанавливаются приоритеты. Разработчик A отвечает за создание формы, разработчик B \sphinxhyphen{} за подключение к базе данных, разработчик C \sphinxhyphen{} за проверку данных пользователя.
\\
\sphinxhline
\sphinxAtStartPar
3 \sphinxstylestrong{Обдумывание и Разработка}
&
\sphinxAtStartPar
Каждый участник начинает работу над своей подзадачей. Анализ требований, деталей, рисков. Разработчик B анализирует структуру базы данных, выбирает технологии, обсуждает с архитектором.
\\
\sphinxhline
\sphinxAtStartPar
4 \sphinxstylestrong{Взаимодействие и ревью}
&
\sphinxAtStartPar
Регулярное общение и ревью. Демонстрация результатов. Разработчик C демонстрирует реализацию проверки данных другим участникам.
\\
\sphinxhline
\sphinxAtStartPar
5 \sphinxstylestrong{Интеграция и тестирование}
&
\sphinxAtStartPar
Интеграция всех частей продукта, тестирование функциональности и взаимодействия. Веб\sphinxhyphen{}приложение проходит интеграционное и функциональное тестирование, включая проверку страницы авторизации.
\\
\sphinxhline
\sphinxAtStartPar
6 \sphinxstylestrong{Финальная оценка и представление}
&
\sphinxAtStartPar
Окончательная оценка работы, представление заказчику. После финального тестирования команда уверяется, что страница авторизации работает корректно, затем представляет результат заказчику.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{Задача: Планирование и организация работы над разработкой чат\sphinxhyphen{}бота с использованием Канбан доски}
\label{\detokenize{educational_materials/team_work_on_a_project/exercises:id1}}\label{\detokenize{educational_materials/team_work_on_a_project/exercises::doc}}
\sphinxAtStartPar
Описание задачи: Вашей задачей является разработка детального плана работы над проектом чат\sphinxhyphen{}бота с использованием методологии Канбан. Данный план должен включать в себя определение основных этапов разработки, колонок на Канбан доске и описание процесса перемещения задач между этими колонками. Вам также предстоит определить ответственных за каждый этап и роли в команде.

\sphinxAtStartPar
Этапы решения задачи:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определити этапы разработки. Разбейте весь процесс разработки чат\sphinxhyphen{}бота на основные этапы, такие как проектирование, разработка, тестирование, ревью, развертывание и др.

\item {} 
\sphinxAtStartPar
Создайте Канбан доску. Определите основные колонки на Канбан доске. Обычно это \sphinxstylestrong{Backlog}, \sphinxstylestrong{To Do}, \sphinxstylestrong{In Progress}, \sphinxstylestrong{Review}, \sphinxstylestrong{Testing}, \sphinxstylestrong{Done}.

\item {} 
\sphinxAtStartPar
Составьте список задач для команды и опишите их выполнения задач. Для каждой колонки опишите, статус задач и каким образом они будут перемещаться от этапа к этапу. Например, задачи могут начинать свой путь с \sphinxstylestrong{Backlog}, затем переходить в \sphinxstylestrong{To Do}, когда назначены на выполнение, далее в \sphinxstylestrong{In Progress} при начале работы и так далее.

\item {} 
\sphinxAtStartPar
Назначте ответственных для задач. Определите, кто будет ответственным для каждой задачи. Это может быть разработчик, тестировщик, ревьюер и т.д. Распределите роли в команде.

\item {} 
\sphinxAtStartPar
Установите временные рамки задач. Определите ожидаемое время выполнения для каждого этапа (спринта) и задачи. Это поможет вам лучше планировать и контролировать процесс разработки и оценивать время.

\item {} 
\sphinxAtStartPar
Создание доски в онлайн сервисе: Воспользуйтесь удобным инструментом для создания Канбан доски, например, онлайн\sphinxhyphen{}сервисами или физической доской с карточками. И перенесите на неё информацию с предыдущих этапов (3, 4 и 5).

\item {} 
\sphinxAtStartPar
Выполните несколько итераций работы с проектом. Начните работу по разработке чат\sphinxhyphen{}бота в соответствии с разработанным планом. Перемещайте задачи по Канбан доске, следите за прогрессом и корректируйте план при необходимости.

\item {} 
\sphinxAtStartPar
Внесете изменения в процессе работы если план работ будет скорректирован. Например появилась новая задача которая требует решения в первую очередь, или наоборот, возможно какая\sphinxhyphen{}то задача потеряет актуальность и её нужно убрать с Канбан доски. При необходимости, вносите изменения в Канбан доску, добавляя новые колонки или меняя порядок этапов. Главное, чтобы доска отражала текущий процесс и удовлетворяла потребности команды.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Цель задачи}: Получить опыт в использовании инструментов командной работы, разработке плана работ над проектом с использованием Git и Канбан доски, который поможет команде эффективно организовать процесс разработки чат\sphinxhyphen{}бота, контролировать прогресс и достичь успешных результатов.

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/team_work_on_a_project/quiz:id1}}\label{\detokenize{educational_materials/team_work_on_a_project/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какие основные задачи выполняет Scrum Master в процессе управления проектом?
а) Разработка кода и тестирование продукта.
б) Планирование проекта и установка приоритетов задач.
в) Организация ежедневных совещаний и отчетность перед заказчиком.
г) Устранение препятствий, поддержка команды и соблюдение принципов Scrum.

\item {} 
\sphinxAtStartPar
Какие характеристики делают канбан доску эффективным инструментом для визуализации рабочего процесса?
а) Отсутствие ограничений по количеству задач.
б) Четкое разграничение этапов выполнения задач.
в) Отображение всех задач на одной доске без разделения.
г) Использование сложных цветовых маркировок.

\item {} 
\sphinxAtStartPar
Какие принципы лежат в основе Agile методологий, таких как Scrum и канбан?
а) Строгий контроль и управление процессом разработки.
б) Предпочтение планам и документации перед работающим кодом.
в) Разработка взаимодействующих командами и участниками продукта.
г) Сосредоточение только на первоначально заданных требованиях.

\item {} 
\sphinxAtStartPar
Какие преимущества и недостатки связаны с гибкими методологиями управления проектами, например, Scrum и канбан?
а) Преимущество: быстрая реакция на изменения. Недостаток: недостаточное внимание документации.
б) Преимущество: высокая предсказуемость. Недостаток: сложность адаптации к изменениям.
в) Преимущество: строгий контроль над каждым этапом. Недостаток: ограничение гибкости.
г) Преимущество: формальное планирование. Недостаток: ограниченное взаимодействие с заказчиком.

\item {} 
\sphinxAtStartPar
Какие типы задач обычно можно увидеть на канбан доске и каким образом они отслеживаются?
а) Только задачи разработки. Отслеживаются с помощью тегов.
б) Задачи всех этапов разработки. Отслеживаются перемещением между столбцами.
в) Задачи только по тестированию. Отслеживаются по названию.
г) Задачи только по документации. Отслеживаются с помощью вложенных комментариев.

\item {} 
\sphinxAtStartPar
Что такое «daily stand\sphinxhyphen{}up» (ежедневное совещание) в методологии Scrum? Какие вопросы обычно обсуждаются на нем?
а) Это встреча разработчиков после завершения проекта. Обсуждаются детали реализации.
б) Это встреча для обсуждения долгосрочных планов развития проекта.
в) Это ежедневное совещание для синхронизации команды. Обсуждаются ответы на три вопроса: «Что было сделано?», «Что будет сделано?», «Есть ли препятствия?».
г) Это еженедельная встреча с заказчиком для сдачи результатов работы.

\item {} 
\sphinxAtStartPar
Какие из следующих характеристик являются ключевыми для эффективной работы в команде?
а) Отсутствие коммуникации между членами команды.
б) Стремление к индивидуальной работе без взаимодействия.
в) Регулярные конфликты и отсутствие обратной связи.
г) Открытое общение, сотрудничество, разделение знаний и опыта.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\end{enumerate}


\chapter{Знакомство с платформами размещения исходного кода программ на примере GitFlic}
\label{\detokenize{index:gitflic}}
\sphinxstepscope


\section{Знакомство с платформами размещения исходного кода программ на примере Gitflick}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:gitflick}}\label{\detokenize{educational_materials/team_work_on_a_gitflic/content::doc}}
\sphinxAtStartPar
В современном мире разработки программного обеспечения существует множество платформ, предоставляющих разработчикам возможность хранить, управлять и совместно работать над исходным кодом своих проектов. Выбор платформы для работы с кодом зависит от потребностей проекта, предпочтений команды разработчиков и ряда других факторов. Важно выбрать такую платформу, которая наилучшим образом соответствует целям вашего проекта и предоставляет необходимые инструменты для успешного сотрудничества.

\sphinxAtStartPar
Существует множество платформ для размещения и совместной работы над исходным кодом программ. Наиболее известные из них представлены в таблице:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Название платформы
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GitHub}}
&
\sphinxAtStartPar
Один из самых популярных и распознаваемых ресурсов, предоставляющих возможность хранения, управления и совместной работы над кодом. Поддерживает систему контроля версий Git и предоставляет широкий набор инструментов для управления проектами.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GitLab}}
&
\sphinxAtStartPar
Сервис и самостоятельное программное обеспечение для управления исходным кодом с возможностью самостоятельной установки. Предоставляет инструменты для CI/CD, управления задачами и другими аспектами разработки.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Bitbucket}}
&
\sphinxAtStartPar
Платформа, поддерживающая Git и Mercurial, предлагает бесплатные и платные варианты. Интегрируется с другими инструментами разработки.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Azure DevOps (Visual Studio Team Services)}}
&
\sphinxAtStartPar
Набор инструментов от Microsoft для разработки ПО, включая хостинг исходного кода, CI/CD, отслеживание ошибок и другие функции.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SourceForge}}
&
\sphinxAtStartPar
Одна из старейших платформ для хостинга проектов с открытым исходным кодом. Предоставляет хостинг, систему контроля версий и инструменты для совместной работы.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Launchpad}}
&
\sphinxAtStartPar
Платформа от Canonical, предоставляющая хостинг и систему контроля версий для проектов с открытым исходным кодом. Интегрируется с инструментами Ubuntu.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gitflick}}
&
\sphinxAtStartPar
Эта отечественная платформа обеспечивает хостинг исходного кода, систему контроля версий Git и инструменты для совместной работы над проектами, а также уделяет особое внимание российским разработчикам.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Одной из таких платформ является GitFlick, которая объединяет возможности системы контроля версий Git с удобством облачных сервисов. Близким по функциональности с популярной платформой GitHub. Как и на GitHub, команды совместно разрабатывают проекты, а обширный набор инструментов обеспечивает эффективное взаимодействие и отслеживание изменений. Давайте рассмотрим подробнее, как GitFlick и аналогичные платформы упрощают жизнь команд разработчиков, позволяют следить за изменениями в проектах, коммуницировать в команде и создавать инновационные продукты.

\sphinxAtStartPar
Рассмотрим основные рекомендации при работе над проектом в команде


\subsection{Знакомство с отечественным сервисом GitFlic}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:gitflic}}
\sphinxAtStartPar
\sphinxincludegraphics{{ogimage}.png}

\sphinxAtStartPar
В начале 2010\sphinxhyphen{}х годов, когда глобальные платформы для разработки и управления кодом уже были популярны, российское сообщество разработчиков осознало, что национальная аудитория также нуждается в удобном и адаптированном решении. Местные особенности, языковые и культурные нюансы, а также желание обеспечить более высокую безопасность данных для российских компаний и команд стали ключевыми факторами для создания собственного сервиса.

\sphinxAtStartPar
\sphinxhref{https://gitflic.ru/}{GitFlic} — это сервис хранения и обмена кодом, созданный командой разработчиков из России. Он предоставляет пользователям возможность сохранять свой код в облаке, обмениваться им с другими пользователями и получать доступ к нему без необходимости оплаты. GitFlic позиционирует себя как российский аналог популярного западного хранилища кода GitHub, но при этом обладает рядом уникальных функций и возможностей.

\sphinxAtStartPar
Одной из главных особенностей GitFlic является его безопасность. Сервис использует шифрование SSL/TLS для защиты передаваемых данных и имеет систему авторизации пользователей, которая обеспечивает высокий уровень безопасности. Кроме того, GitFlic предоставляет возможность создавать закрытые ветки кода, что позволяет разработчикам работать над проектами совместно и делиться своими наработками с другими участниками сообщества. Одним из преиммуществ сервиса GitFlic является наличие документации и инструкций на русском языке, что облегчает знакомство с платформой.

\sphinxAtStartPar
Перед тем как приступить к работе с репозиторием и браться за выполнение задач команде стоит разработать и обсудить структуру проекта. Как будут располагаться различные файлы и компоненты проекта. Ниже представлена рекомендуемая структура директории для командной разработки проекта на Python. Предложенный вариант позволяет налядно оценить масштаб задач и структурировать различные элементы. Также это позволяет решить многие вопросы. Куда загруужать данные? Куда записать премежуточные результаты? Где хранить тесты и документацию, где искать скрипты для автоматизации рутинных задач. Предложенный вариант является не более чем рекомендацией для размышления. Ведь структура проекта зависит от его тематики и предпочтений команды.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
my\PYGZus{}project/
│
├──\PYG{+w}{ }docs/
│\PYG{+w}{   }├──\PYG{+w}{ }requirements.txt
│\PYG{+w}{   }├──\PYG{+w}{ }design\PYGZus{}documents/
│\PYG{+w}{   }├──\PYG{+w}{ }user\PYGZus{}guides/
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }src/
│\PYG{+w}{   }├──\PYG{+w}{ }my\PYGZus{}module\PYGZus{}1/
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }module\PYGZus{}1\PYGZus{}file1.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }module\PYGZus{}1\PYGZus{}file2.py
│\PYG{+w}{   }│\PYG{+w}{   }└──\PYG{+w}{ }...
│\PYG{+w}{   }├──\PYG{+w}{ }my\PYGZus{}module\PYGZus{}2/
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }module\PYGZus{}2\PYGZus{}file1.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }module\PYGZus{}2\PYGZus{}file2.py
│\PYG{+w}{   }│\PYG{+w}{   }└──\PYG{+w}{ }...
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }tests/
│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}my\PYGZus{}module\PYGZus{}1/
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}module\PYGZus{}1\PYGZus{}file1.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}module\PYGZus{}1\PYGZus{}file2.py
│\PYG{+w}{   }│\PYG{+w}{   }└──\PYG{+w}{ }...
│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}my\PYGZus{}module\PYGZus{}2/
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}module\PYGZus{}2\PYGZus{}file1.py
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }test\PYGZus{}module\PYGZus{}2\PYGZus{}file2.py
│\PYG{+w}{   }│\PYG{+w}{   }└──\PYG{+w}{ }...
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }data/
│\PYG{+w}{   }├──\PYG{+w}{ }input/
│\PYG{+w}{   }├──\PYG{+w}{ }output/
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }scripts/
│\PYG{+w}{   }├──\PYG{+w}{ }data\PYGZus{}processing\PYGZus{}script.py
│\PYG{+w}{   }├──\PYG{+w}{ }utility\PYGZus{}script.py
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }config/
│\PYG{+w}{   }├──\PYG{+w}{ }config\PYGZus{}file1.yaml
│\PYG{+w}{   }├──\PYG{+w}{ }config\PYGZus{}file2.yaml
│\PYG{+w}{   }└──\PYG{+w}{ }...
│
├──\PYG{+w}{ }requirements.txt
├──\PYG{+w}{ }README.md
├──\PYG{+w}{ }LICENSE
├──\PYG{+w}{ }.gitignore
└──\PYG{+w}{ }...
\end{sphinxVerbatim}

\sphinxAtStartPar
Объяснение структуры:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docs/}}: Здесь хранятся документация, связанная с проектом, включая требования, дизайн\sphinxhyphen{}документы, руководства пользователя и др.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{src/}}: Это место для всех исходных файлов вашего проекта. Рекомендуется организовать код в модули и пакеты.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tests/}}: Директория для тестовых файлов. Каждый модуль следует сопровождать соответствующими тестами.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data/}}: Здесь хранятся входные и выходные данные, используемые или генерируемые вашим приложением.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scripts/}}: Если вам нужно включить дополнительные сценарии обработки данных или утилиты, это место для них.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{config/}}: Содержит конфигурационные файлы, которые управляют поведением приложения.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{requirements.txt}}: Список зависимостей для вашего проекта.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{README.md}}: Описание проекта, его назначение, инструкции по установке, использованию и вкладу в разработку.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LICENSE}}: Файл с лицензией вашего проекта.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.gitignore}}: Файл, указывающий Git’у, какие файлы и директории нужно игнорировать при коммите.

\end{itemize}

\sphinxAtStartPar
Эта структура помогает организовать код и ресурсы вашего проекта так, чтобы разработка и совместная работа были более структурированными и эффективными.


\subsection{Типовой процесс совсместной работы с кодом}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:id1}}
\sphinxAtStartPar
Мы познакомились с платформами для работы с кодом, обсудили что нужно учитывать при разработке структуры проекта, пора перейти к работе с Git. Рассмотрим сценарий командной работы трех разработчиков, которые используют git для работы с платформой, например GitFlic. Они работать над проектом и каждый разработчик вносит изменения по своей задаче. Посмотрим, какие комманды git используют разработчики и в какой последовательности. Они сначала создадут форк исходного проекта и будут выполнять коммиты по мере завершения работы над задачами. Каждый в свою версию проекта, а затем после внесения своих доработок отправят pull request в исходный репозиторий чтоб объединить свои части кода.    Опишем каждое действия разработчиков используя команды Git при работе с удаленным репозиторием.
\begin{quote}

\sphinxAtStartPar
Аналогично можно испольpовать любую другую платформу для работы с кодом поддерживающую git, например, GitHub.
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Инициализация проекта:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 1: Создает пустой репозиторий на GitFlic (назовем его «myproject»).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }init
git\PYG{+w}{ }remote\PYG{+w}{ }add\PYG{+w}{ }origin\PYG{+w}{ }https://gitflic.ru/yourusername/myproject.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Форкают репозиторий «myproject» и получают копии в своих аккаунтах на GitFlic.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Клонирование репозиториев:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 1: Клонирует репозиторий «myproject» на свой локальный компьютер.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }clone\PYG{+w}{ }https://gitflic.ru/yourusername/myproject.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Клонируют свои форки репозитория «myproject» на свои локальные компьютеры.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }clone\PYG{+w}{ }https://gitflic.ru/developer2/myproject.git
git\PYG{+w}{ }clone\PYG{+w}{ }https://gitflic.ru/developer3/myproject.git
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработка задач:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 1: Работает над первой задачей и вносит изменения в свой локальный репозиторий.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }add\PYG{+w}{ }.
git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Added feature 1\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Разработчик 2: Работает над второй задачей и вносит изменения в свой локальный репозиторий.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }add\PYG{+w}{ }.
git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Fixed bug in feature 2\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Разработчик 3: Работает над третьей задачей и вносит изменения в свой локальный репозиторий.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }add\PYG{+w}{ }.
git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Implemented enhancement 3\PYGZdq{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Обновление форков:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Регулярно синхронизируют свои форки с оригинальным репозиторием «myproject».

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }pull\PYG{+w}{ }upstream\PYG{+w}{ }master
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Отправка изменений на сервер:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 1: Отправляет свои изменения на GitFlic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }push\PYG{+w}{ }origin\PYG{+w}{ }master
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Также отправляют свои изменения на свои форки на GitFlic.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pull Request:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Создают Pull Request из своих форков в оригинальный репозиторий «myproject».

\item {} 
\sphinxAtStartPar
Разработчик 1: Получает уведомления о созданных Pull Request’ах и проводит ревью изменений.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ревью и слияние изменений:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчик 1: Оставляет комментарии и проводит ревью кода в Pull Request’ах Разработчика 2 и Разработчика 3.

\item {} 
\sphinxAtStartPar
Разработчик 2 и Разработчик 3: Вносят изменения по комментариям и обсуждают с Разработчиком 1.

\item {} 
\sphinxAtStartPar
Разработчик 1: Сливает (мерджит) Pull Request’ы Разработчика 2 и Разработчика 3 в основную ветку проекта.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Таким образом, каждый разработчик работает над своей задачей, использует Git для управления версиями кода и взаимодействия с командой, и создает Pull Request’ы для объединения изменений в основной репозиторий.

\sphinxAtStartPar
В общем виде это выглядит весьма понятно, однако перед началом работы команде следует договриться о том как они будут называть и оформлять ветки, как часто делать коммиты и что писать в комментариях чтоб другие участники могли самостоятельно разобраться в чужом коде без привлечения автора. Эти и многие вопросы, были исторически решены и сформировалны в так называемый «Best Practices» состоящий в виде списка рекомендаций, которого придержиываются большинство разработчиков. Конечно в каждой команде он может быть свой хотя по большей части по смыслу они совпадают.

\sphinxAtStartPar
Список «Best Practices» для эффективной работы команды разработчиков использующих Git представлен в таблице:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Best Practice
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Используйте однообразные стили именования}
&
\sphinxAtStartPar
Договоритесь о стандартах именования веток, коммитов, тегов и других элементов. Допустим, у нас есть команда разработчиков, которая работает над проектом по созданию онлайн\sphinxhyphen{}магазина. Для того чтобы следовать совету о использовании однообразных стилей именования, команда договорилась о следующих правилах: Для каждой новой функциональности или задачи создается отдельная ветка. Название ветки состоит из краткого описания задачи, разделенного дефисами. Например, feature\sphinxhyphen{}add\sphinxhyphen{}checkout\sphinxhyphen{}button для ветки, в которой добавляется кнопка оформления заказа. Каждый коммит содержит осмысленное и краткое сообщение, начинающееся с глагола в настоящем времени. Сообщение описывает, что именно было сделано в этом коммите. Например, «Добавляет функцию корзины для товаров». Для обозначения версий релизов используется семантическое версионирование. Теги имеют формат X.Y.Z, где X \sphinxhyphen{} мажорная версия, Y \sphinxhyphen{} минорная версия, и Z \sphinxhyphen{} патч\sphinxhyphen{}версия. Например, 1.0.0 для первого релиза. Это улучшает читаемость и понимание истории проекта. Таким образом, разработчики могут легко разобраться в назначении и состоянии веток, коммитов и тегов, что способствует пониманию работы над проектом. Также, способствует лучшей навигации по коду проекта. Можно быстро найти нужные ветки или коммиты, так как структура именования следует определенному формату.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Маленькие и законченные коммиты}
&
\sphinxAtStartPar
Каждый коммит должен решать конкретную задачу. Это значит что в коде не должно быть недописанных кусков кода, которые нельзя проверить или оценить их качество. Если вы напишете функцию, класс или модифицируете что\sphinxhyphen{}то из того что было ранее и ваша вклад готов к стадии тестирования, значит пора отправлять коммит. Это облегчает ревью кода и понимание изменений. Отправлять одним коммитом изменения касающиеся различных частей кода это плохая практика. Такого стоит избегать. Просто возьмите себе за правило: как только вы решили что задача выполнена, перед тем как браться за что\sphinxhyphen{}то другое отправьте коммит. Зафиксируйте результат. Это улучшает читаемость и понимание истории проекта.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Ветвление по функциональности}
&
\sphinxAtStartPar
Используйте ветки для каждой новой функциональности или задачи. Это позволяет изолировать изменения и упрощает слияние. Когда команда разработчиков работает над проектом, который включает множество функциональных задач или новых возможностей, хорошей практикой является создание отдельных веток для каждой функциональности или задачи. Это позволяет изолировать изменения, связанные с конкретной задачей, от остального кода, что облегчает тестирование, ревью и интеграцию. Ветки также предотвращают вмешательство изменений в процесс разработки других членов команды и упрощают слияние изменений обратно в основную ветку. Когда задача завершена и готова для интеграции, ветка может быть слита с основной веткой с минимальными конфликтами.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Регулярное обновление основной ветки}
&
\sphinxAtStartPar
Важно держать основную ветку (например, \sphinxcode{\sphinxupquote{main}} или \sphinxcode{\sphinxupquote{master}}) актуальной с последними изменениями. Используйте merge (слияния) или rebase (перебазирование).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Внедрение код ревью}
&
\sphinxAtStartPar
Практика обязательного ревью кода перед вливанием изменений в основную ветку улучшает качество кода. Практика обязательного ревью кода означает, что перед тем как изменения вливаются в основную ветку (например, \sphinxcode{\sphinxupquote{main}} или \sphinxcode{\sphinxupquote{master}}), другие члены команды анализируют и оценивают предложенные изменения. В основном эту задачу выполняют опытные разработчики, которые достаточно хорошо знакомы с текущим проектом. Они могут выявить возможные недостатки кода и дать хороший фидбек (обратную связь автору кода), с пояснениями принятого решения и рекомендациями. Это не только улучшает качество кода, позволяя выявлять ошибки и проблемы, но и способствует обмену опытом между членами команды. Ревью помогает снизить вероятность внесения дефектов и несоответствий коду основной ветки, что важно для стабильности и надежности проекта.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Используйте .gitignore}
&
\sphinxAtStartPar
Игнорируйте временные файлы, зависимости и другие ненужные элементы в системе контроля версий. Файл \sphinxcode{\sphinxupquote{.gitignore}} предназначен для указания файлов и папок, которые не следует включать в систему контроля версий. К ним относятся: временные файлы, локальные зависимости, сгенерированные файлы компиляции и другие элементы, которые не имеют значения для других членов команды и могут засорять историю изменений. Игнорируя такие файлы, можно поддерживать репозиторий чистым и облегчить с ним работу. Допустим вы пишете веб\sphinxhyphen{}сервис на Python. У вас настроено виртуальное окружение в папке env. У вас есть основной файл \sphinxcode{\sphinxupquote{main.py}}, который содержит основной код. Перед созданием коммита, убедитесь что в файле \sphinxcode{\sphinxupquote{.gitignore}} содержится папка \sphinxcode{\sphinxupquote{env}}. Иначе, все её содержимое отправится в ваш репозиторий при создании коммита. папка \sphinxcode{\sphinxupquote{env}} будет занимать значительное место на диске и может достигать от десятков мегабайт до нескольких гигабайт. Это приведет к тому что процесс загрузки, и клонирования вашего репозитория будет медленным. В этом случае для фиксации версий используемых библиотек и сторонних пакетов рекомендуется использовать файл \sphinxcode{\sphinxupquote{requirements.txt}}. Узнать как это сделать можно \sphinxhref{https://dvmn.org/encyclopedia/pip/pip\_requirements\_txt/}{тут}.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Используйте теги для релизов}
&
\sphinxAtStartPar
Для обозначения версий релизов и важных точек в истории проекта следует использовать теги. Теги позволяют быстро вернуться к конкретной версии кода, что полезно для устранения проблем и анализа изменений между версиями. Семантическое версионирование (например, \sphinxcode{\sphinxupquote{1.2.3}}) в тегах позволяет четко обозначить, какие изменения внесены в каждую версию и насколько они совместимы между собой.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Семантическое версионирование}
&
\sphinxAtStartPar
При использовании тегов для версионирования придерживайтесь семантической версии (например, \sphinxcode{\sphinxupquote{1.2.3}}).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Используйте «говорящие комментарии» в коммитах}
&
\sphinxAtStartPar
Поясняйте, что и зачем было сделано. Это помогает понимать историю изменений и восстанавливать контекст. При создании коммитов важно добавлять понятные комментарии, которые описывают, какие изменения были внесены и зачем. Это помогает другим членам команды понимать цель и контекст изменений, а также позволяет в будущем легче восстановить историю проекта и вернуться к определенному состоянию. Хорошо оформленные комментарии снижают необходимость дополнительных объяснений и способствуют прозрачности работы.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Обучение команды}
&
\sphinxAtStartPar
Организуйте обучение по использованию Git и его лучших практик в команде. Это способствует согласованности и высокому качеству работы.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Автоматизация сборки и тестирования}
&
\sphinxAtStartPar
Используйте CI/CD для автоматизации сборки, тестирования и развертывания. Это ускоряет процесс разработки и обнаружение ошибок.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Коммуникация в команде}
&
\sphinxAtStartPar
Поддерживайте открытую коммуникацию о том, что делается и какие изменения вносятся. Это помогает избежать конфликтов и недопониманий. Фиксируйте свои задачи на физической канбан\sphinxhyphen{}доске или в её электронной версии. Познакомтесь с методологиями \sphinxhref{https://www.atlassian.com/ru/agile/scrum}{Scrum} и \sphinxhref{https://www.atlassian.com/ru/agile/agile-at-scale/long-term-agile-planning}{Agile}. Это самые распространенные на сегодняшний день инструменты для организации эффективной работы команды разработчиков.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\begin{quote}

\sphinxAtStartPar
Представленные рекомендации могут отличаться в зависимости от специфики проекта и команды. Следование предложенным рекомендациям поможет обеспечить более эффективную и согласованную работу над проектами с использованием Git. Эти практики обеспечивают более структурированный и эффективный процесс разработки, упрощают совместную работу над кодом и могут повысить качество и надежность вашего проекта.
\end{quote}

\sphinxAtStartPar
В рамках курса мы уже упоминали популярную платформу GitHub, которая является одной из самых крупных площадок для работы с кодом и развития Open Source. Она была основана в апреле 2008 года Томом Престон\sphinxhyphen{}Вернером и Крисом Ван Дамом. В том же 2008 году компанией Atlassian был создан схожий по функционалу  сервис Bitbucket. Ориентированый на более широкий спектр инструментов для разработчиков, включая хостинг Git\sphinxhyphen{}репозиториев, системы отслеживания ошибок и интеграцию с другими продуктами Atlassian, такими как Jira и Confluence.

\sphinxAtStartPar
За годы своего существования GitHub стал ключевой платформой для open source сообщества, стартапов и больших корпораций. Однако 26 октября 2018 года была завершена сделка по приобретению платформы GitHub компанией Microsoft. Это означает, что начиная с этой даты GitHub попал под влияние компании Microsoft, что неоднозначно воспринялось участниками движения Open Source.

\sphinxAtStartPar
В целях соблюдения мер безопасности и конфиденциальности данных крупные IT компании используют собственные платформы для работы с кодом (аналогичные GitHub, GitLab) расположенные на собственных вычислительных мощностях. Разумеется что доступ к этим платформам имеют только часть сотрудников компании и никакие сторонние лица не могут размещать там свои Open Sopurce проекты. Однако в России есть своя доступная платформа для работы с кодом \sphinxhyphen{} \sphinxhref{https://gitflic.ru/}{GitFlic}.


\subsection{Задание для команды разработчиков: Создание чат\sphinxhyphen{}бота для мессенджера Telegram с использованием GitFlick}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:telegram-gitflick}}
\sphinxAtStartPar
\sphinxstylestrong{Цель:} Создать чат\sphinxhyphen{}бота для мессенджера Telegram, который будет предоставлять информацию о ближайших хакатонах и олимпиадах для школьников и студентов, справочную информацию о команде разработчиков, а также возможность выполнять поиск справочной информации из открытых источников.

\sphinxAtStartPar
\sphinxstylestrong{Задачи:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание GitFlick проекта и репозитория:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Каждый разработчик должен создать учетную запись на GitFlick.

\item {} 
\sphinxAtStartPar
Один из разработчиков создает новый проект на GitFlick и приглашает остальных участников команды.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработка чат\sphinxhyphen{}бота:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчики создают структуру проекта для чат\sphinxhyphen{}бота.

\item {} 
\sphinxAtStartPar
Реализуют функцию выдачи списка ближайших хакатонов и олимпиад.

\item {} 
\sphinxAtStartPar
Разрабатывают механизм предоставления справочной информации о команде разработчиков.

\item {} 
\sphinxAtStartPar
Добавляют кнопки и пункты меню для удобства навигации в интерфейсе чат\sphinxhyphen{}бота.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Интеграция с Telegram API:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчики настраивают интеграцию с Telegram API для взаимодействия с мессенджером.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Реализация поиска справочной информации:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Интегрировать API для поиска информации из открытых источников (например, Wikipedia или другие источники).

\item {} 
\sphinxAtStartPar
Реализовать возможность поиска по заданному запросу.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Тестирование и отладка:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Каждый участник команды тестирует свои функции и исправляет возникающие ошибки.

\item {} 
\sphinxAtStartPar
Обеспечить работоспособность и стабильность чат\sphinxhyphen{}бота.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Документация:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Подготовить описание функций чат\sphinxhyphen{}бота и инструкции по его использованию.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Сроки:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Создание проекта и репозитория: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Разработка чат\sphinxhyphen{}бота: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Интеграция с Telegram API: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Реализация поиска справочной информации: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Тестирование и отладка: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Документация: {[}Указать срок{]}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Результат:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Реализованный и работоспособный чат\sphinxhyphen{}бот, размещенный на GitFlick, с функциями выдачи информации о хакатонах, олимпиадах, справочной информации о команде и возможностью поиска.

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Примечание:} Для эффективной организации работы предлагаем разбиться на команды по 3\sphinxhyphen{}5 человек, чтоб вы могли совместно принимать решения данной задачи. Используйте методику SСRUM и канбан\sphinxhyphen{}доску для формирования списка задач и их распределения в команде. Это позволит вам сфомировать процесс управления разработкой IT продукта. Также рекомендуется изучить возможности полатформы GitFlick для управления задачами, ведения обсуждений и отслеживания прогресса.
\end{quote}


\subsection{Заключение}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:id2}}
\sphinxAtStartPar
В данном блоке мы постарались кратко познакомиться вас с основными элементами командной работы на IT проектом: От начальных этапов планирования и определения ролей, до финального слияния кода и представления результатов, мы рассказали о ключевых шагах и важных уроках, которые вам помогут при выполнении совместной работы. Конечно есть и много других тем которые не были представлены в данном модуле, однако все они являются ветвями развития представленных базовых основ. Надеемся что вам удалость:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ознакомиться с принципами формирования эффективной команды разработчиков.

\item {} 
\sphinxAtStartPar
Понять, как распределение ролей и задач влияет на процесс работы над проектом.

\item {} 
\sphinxAtStartPar
Исследовать методы планирования и организации проекта в команде.

\item {} 
\sphinxAtStartPar
Узнать о инструментах и технологиях, которые облегчают командную разработку.

\item {} 
\sphinxAtStartPar
Погрузиться в аспекты совместной работы, решения конфликтов и обмена знаний.

\end{itemize}

\sphinxAtStartPar
Мы надеемся, что этот рассказ о командной работе станет вдохновением для тех, кто стремится к профессиональному росту и успешной совместной разработке. Надеемся что уроки, которые были представлены в этом модуле, помогут вам на пути к развитию навыков командной работы и созданию качественных технологических продуктов.


\bigskip\hrule\bigskip



\subsection{Справочная информация}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:id3}}
\sphinxAtStartPar
В этом блоке представлена справочная информация которая может послужить хорошим материалом чтоб погрузиться в темы «Командная работы» и «Управление проектамии». Представлен краткий анализ и сравнение различных методик управления проектами, а также некоторые подробности этапов их реализации. Также, здесь собраны краткие исторические факты и некоторые теоретические дополнения которые помогут найти ответы на некоторые вопросы появившиеся при изучении основного материала.

\sphinxAtStartPar
Итак, погрузимся в Git и его возможностей для управления кодом в командной разработке. Освоив эти навыки, вы сможете стать более продуктивным участником команды разработки и добиться более успешных результатов в совместных проектах.

\sphinxAtStartPar
Git является мощным инструментом для командной работы над проектами разработки ПО и управления версиями кода. Он позволяет разработчикам совместно работать над кодом, отслеживать изменения, управлять версиями и координировать работу в больших командах. Вот как Git позволяет улучшить работу команды:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ветвление и слияние (Branching and Merging):} Git позволяет создавать ветки для различных задач, функциональности или исправлений. Каждый разработчик может работать над своей собственной веткой, изолированной от основного кода. По завершении работы ветки могут быть слиты (слияние) в основную ветку. Это позволяет избежать конфликтов и упрощает одновременную работу над разными частями проекта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pull Requests (Запросы на слияние):} В платформах с поддержкой PR (Pull Requests), таких как GitHub, GitLab и др., разработчики могут создавать PR для обсуждения и рецензии изменений. Это позволяет другим разработчикам ознакомиться с кодом, оставить комментарии и предложить изменения. Эффективное средство для обсуждения и улучшения кода.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Рецензирование кода (Code Review):} Это важная часть разработки, которая помогает обнаруживать ошибки, улучшать качество кода и обмениваться знаниями в команде. Git облегчает этот процесс через комментирование изменений в PR и возможность просмотра и обсуждения кода.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Управление конфликтами (Conflict Resolution):} При слиянии изменений может возникнуть конфликт, когда одни и те же строки кода были изменены в разных ветках. Git предоставляет инструменты для разрешения таких конфликтов, позволяя разработчикам вручную выбирать, какие изменения следует сохранить.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{История изменений и откат (History and Reverting):} Git хранит историю всех изменений в коде. Если что\sphinxhyphen{}то идет не так, вы можете вернуться к предыдущему состоянию проекта. Это дает команде уверенность в том, что изменения всегда могут быть отменены, если они приведут к проблемам.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Улучшенное управление проектами:} Платформы с поддержкой Git (например, GitHub, GitFlic, Bitbucket) предоставляют инструменты для создания задач (issues), организации проектов (projects), автоматизации сборки и развертывания (CI/CD) и многие другие функции, которые помогают управлять проектами.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Гибкость и распределенность:} Git позволяет разработчикам работать над проектами независимо, даже без постоянного доступа к сети. Это особенно важно для удаленных команд и ситуаций, когда необходимо работать вне офиса.

\end{enumerate}


\subsubsection{Стандарты и протоколы}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:id4}}
\sphinxAtStartPar
Если вам хочется более подробно разобраться в теме стандартов и протоколов, познакомиться с процессом их разработки \sphinxhyphen{} вы можете поискать информацию об институтах стандартизации. Вот пара примеров:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Институт инженеров электротехники и электроники (Institute of Electrical and Electronics Engineers, IEEE) — некоммерческая инженерная ассоциация из США, разрабатывающая широко применяемые в мире стандарты по радиоэлектронике, электротехнике и аппаратному обеспечению вычислительных систем и сетей.

\item {} 
\sphinxAtStartPar
Международная электротехническая комиссия (МЭК; англ. International Electrotechnical Commission, IEC — международная некоммерческая организация по стандартизации в области электрических, электронных и смежных технологий. Некоторые из стандартов МЭК разрабатываются совместно с Международной организацией по стандартизации.

\end{enumerate}


\subsubsection{Краткая история развития популярных платформ для хостинга и совместной разработки кода с использованием Git:}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/content:git}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
SourceForge (1999): Одна из первых платформ для размещения и совместной разработки открытого кода. Впоследствии SourceForge приобрела большую популярность, хотя в последние годы она уступила место новым платформам.

\item {} 
\sphinxAtStartPar
Launchpad (2005): Создан Canonical для хостинга проектов с открытым исходным кодом, включая проект Ubuntu. Помимо Git, поддерживает систему контроля версий Bazaar.

\item {} 
\sphinxAtStartPar
GitHub (2008): Основан Томом Престон\sphinxhyphen{}Вернером и Крисом Ван Дамом. Стал одной из самых популярных платформ для хостинга Git\sphinxhyphen{}репозиториев, обеспечивая удобное совместное программирование, инструменты отслеживания задач и обсуждение изменений. В 2018 году GitHub был приобретен Microsoft.

\item {} 
\sphinxAtStartPar
Bitbucket (2008): Создана компанией Atlassian. Ориентирована на более широкий спектр инструментов для разработчиков, включая хостинг Git\sphinxhyphen{}репозиториев, системы отслеживания ошибок и интеграцию с другими продуктами Atlassian, такими как Jira и Confluence.

\item {} 
\sphinxAtStartPar
GitLab (2011): Запущен Dmitriy Zaporozhets и Валерий Сирожин. GitLab предлагает как облачное решение, так и версию для самостоятельного развертывания на сервере. Это интегрированная платформа с инструментами DevOps, системой непрерывной интеграции и развертывания (CI/CD).

\end{enumerate}

\sphinxstepscope


\section{Задание для команды разработчиков: Создание чат\sphinxhyphen{}бота для мессенджера Telegram с использованием GitFlick}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/exercises:telegram-gitflick}}\label{\detokenize{educational_materials/team_work_on_a_gitflic/exercises::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Цель:} Создать чат\sphinxhyphen{}бота для мессенджера Telegram, который будет предоставлять информацию о ближайших хакатонах и олимпиадах для школьников и студентов, справочную информацию о команде разработчиков, а также возможность выполнять поиск справочной информации из открытых источников.

\sphinxAtStartPar
\sphinxstylestrong{Задачи:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание GitFlick проекта и репозитория:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Каждый разработчик должен создать учетную запись на GitFlick.

\item {} 
\sphinxAtStartPar
Один из разработчиков создает новый проект на GitFlick и приглашает остальных участников команды.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработка чат\sphinxhyphen{}бота:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчики создают структуру проекта для чат\sphinxhyphen{}бота.

\item {} 
\sphinxAtStartPar
Реализуют функцию выдачи списка ближайших хакатонов и олимпиад.

\item {} 
\sphinxAtStartPar
Разрабатывают механизм предоставления справочной информации о команде разработчиков.

\item {} 
\sphinxAtStartPar
Добавляют кнопки и пункты меню для удобства навигации в интерфейсе чат\sphinxhyphen{}бота.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Интеграция с Telegram API:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработчики настраивают интеграцию с Telegram API для взаимодействия с мессенджером.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Реализация поиска справочной информации:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Интегрировать API для поиска информации из открытых источников (например, Wikipedia или другие источники).

\item {} 
\sphinxAtStartPar
Реализовать возможность поиска по заданному запросу.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Тестирование и отладка:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Каждый участник команды тестирует свои функции и исправляет возникающие ошибки.

\item {} 
\sphinxAtStartPar
Обеспечить работоспособность и стабильность чат\sphinxhyphen{}бота.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Документация:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Подготовить описание функций чат\sphinxhyphen{}бота и инструкции по его использованию.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Сроки:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Создание проекта и репозитория: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Разработка чат\sphinxhyphen{}бота: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Интеграция с Telegram API: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Реализация поиска справочной информации: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Тестирование и отладка: {[}Указать срок{]}

\item {} 
\sphinxAtStartPar
Документация: {[}Указать срок{]}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Результат:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Реализованный и работоспособный чат\sphinxhyphen{}бот, размещенный на GitFlick, с функциями выдачи информации о хакатонах, олимпиадах, справочной информации о команде и возможностью поиска.

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Примечание:} Для эффективной организации работы предлагаем разбиться на команды по 3\sphinxhyphen{}5 человек, чтоб вы могли совместно принимать решения данной задачи. Используйте методику SСRUM и канбан\sphinxhyphen{}доску для формирования списка задач и их распределения в команде. Это позволит вам сфомировать процесс управления разработкой IT продукта. Также рекомендуется изучить возможности полатформы GitFlick для управления задачами, ведения обсуждений и отслеживания прогресса.
\end{quote}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/team_work_on_a_gitflic/quiz:id1}}\label{\detokenize{educational_materials/team_work_on_a_gitflic/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какая практика разработки с использованием Git помогает изолировать изменения и упрощает слияние кода?
а) Регулярное обновление основной ветки.
б) Использование .gitignore для игнорирования файлов.
в) Ветвление по функциональности.
г) Автоматизация сборки и тестирования.

\item {} 
\sphinxAtStartPar
Какой инструмент помогает обнаруживать и устранять ошибки в коде до его вливания в основную ветку?
a) Взаимодействие и ревью кода.
b) Использование тегов для релизов.
c) Разработка с помощью комментариев.
d) Поддержание резервных копий кода.

\item {} 
\sphinxAtStartPar
Какой файл используется для игнорирования временных файлов, зависимостей и других ненужных элементов в системе контроля версий?
а) .gitconfig
б) .gitignore
в) .gitcommit
г) .gitbranch

\item {} 
\sphinxAtStartPar
Для чего используются теги в системе контроля версий Git?
а) Для создания резервных копий кода.
б) Для автоматической сборки и тестирования.
в) Для обозначения версий релизов.
г) Для отправки кода на удаленный сервер.

\item {} 
\sphinxAtStartPar
Какой принцип работы с Git помогает понимать историю изменений и восстанавливать контекст?
а) Ветвление по функциональности.
б) Взаимодействие и ревью кода.
в) Регулярное обновление основной ветки.
г) Использование коммитов и их комментариев.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\end{enumerate}


\chapter{Среда разработки}
\label{\detokenize{index:id5}}
\sphinxstepscope


\section{Среда разработки}
\label{\detokenize{educational_materials/ide/content:id1}}\label{\detokenize{educational_materials/ide/content::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Среда разработки} или, если дословно с английского, интегрированная среда разработки (Integrated Development Environment, IDE) — это приложение, которое позволяет разрабатывать код более эффективно, чем в текстовом редакторе, например \sphinxhref{https://kate-editor.org/}{Kate} или \sphinxhref{https://notepad-plus-plus.org/downloads/}{Notepad++}. Среда разработки объединяет в себе несколько функций, которые обычно разработчики хотят в ней увидеть: автоматизация написания кода, подсветка синтаксиса, автоматическое дополнение кода, форматирование, рефакторинг, компиляция, сборка и отладка. Также среды разработки поддерживают основные инструменты разработчиков в виде дополнений, так, можно подключить плагины, которые позволят пользоваться \sphinxcode{\sphinxupquote{git}} и прогонять тесты прямо из среды разработки. Сейчас сложно найти среды разработки, которые имеют поддержку только одного языка программирования. Существуют среды разработки, специализирующиеся на одном языке программирования для серверных приложений (backend), такие как PyCharm, но даже в них есть \sphinxhref{https://www.jetbrains.com/help/pycharm/supported-languages.html}{поддержка} JavaScript, HTML и других инструментов для разработки приложений пользователя (frontend). Это необходимо, так как есть понятие fulstack разработки, и переключаться между средами для разработки отдельно серверной и пользовательской частей было бы неудобно. В таких средах разработки, как \sphinxhref{https://code.visualstudio.com/}{VisualStudioCode} и \sphinxhref{https://www.eclipse.org/downloads/}{Eclipse}, существует поддержка, наверное, всех возможных языков программирования, языков разметки, форматов сериализации данных и так далее. Поддержка устанавливается как дополнение, при этом визуальный интерфейс остается без изменений, что положительно влияет на разработку, так как мы не тратим время на привыкание к другому интерфейсу.

\sphinxAtStartPar
\sphinxincludegraphics{{ide_select_language}.png}


\subsection{Подсветка синтаксиса}
\label{\detokenize{educational_materials/ide/content:id2}}
\sphinxAtStartPar
Подсветка синтаксиса — достаточно распространенная функция, поддерживающаяся даже в текстовых редакторах, которые нельзя отнести к IDE. Подсветка синтаксиса использует свойство человеческого глаза, который лучше (быстрее) воспринимает цвет, а не смысл написанного. Поэтому идея подсветки кода в том, чтобы разделить код на сущности, которые принадлежат к одним группам (функции к функциям, переменные к переменным) и подсветить их одним цветом.

\sphinxAtStartPar
\sphinxincludegraphics{{ide_code_highlight}.png}


\subsection{Автодополнение кода (завершение кода)}
\label{\detokenize{educational_materials/ide/content:id3}}
\sphinxAtStartPar
Среда разработки понимает, какие имена переменных, функций и классов доступны в данном приложении, и использует их, чтобы разработчик мог выбрать подходящий объект при наборе неполного имени:

\sphinxAtStartPar
\sphinxincludegraphics{{ide_auto_completion}.png}

\sphinxAtStartPar
Автодополнение бывает не особо полезно, когда мы знаем название объекта, часто написать его быстрее, чем выбрать из списка. Но если мы забыли название метода или поля класса, мы можем легко его вспомнить, если увидим название в списке, без вызова документации по классу.

\sphinxAtStartPar
\sphinxincludegraphics{{ide_auto_completion_methods}.png}

\sphinxAtStartPar
Кроме автодополнения кода существует такое понятие, как «интеллектуальное дополнение кода». Например, если мы написали название метода, среда разработки может подсказать, какие аргументы можно передать в этот метод. Так как мы ничего не писали, это уже нельзя отнести к автодополнению кода. В VSCode это реализовано в виде \sphinxhref{https://code.visualstudio.com/docs/editor/intellisense}{IntelliSense}.

\sphinxAtStartPar
\sphinxincludegraphics{{ide_auto_completion_arguments}.png}


\subsection{Рефакторинг}
\label{\detokenize{educational_materials/ide/content:id4}}
\sphinxAtStartPar
Рефакторинг — это изменение формы кода без изменения содержания. Мы можем объединить повторяющийся код в функцию или метод, назвать переменные более понятным образом, изменить цикл и совершить другие действия, которые улучшают читаемость кода, но не поменяют то, что он делает. Это и будет рефакторингом.

\sphinxAtStartPar
\sphinxincludegraphics{{ide_refactoring}.png}


\subsection{Компиляция}
\label{\detokenize{educational_materials/ide/content:id5}}
\sphinxAtStartPar
Среды разработки могут выполнять все действия, чтобы запустить код или скомпилировать его в исполняемый файл. Эти действия — такие же, как и при ручном запуске или компиляции. Следует помнить, что среда разработки выполняет некоторые действия неявно, например, осуществляет выбор виртуального окружения, в котором могут быть установлены зависимости, не прописанные нигде явно. Это может приводить к тому, что код не запустится у другого разработчика без дополнительных действий. Часто начинающие просто «нажимают зеленую стрелочку» без понимания, что именно происходит после нажатия. Вы как разработчики, прошедшие этот курс, должны понимать, что запуск и сборка кода может происходить там, где не установлена та же среда разработки, что и у вас. Поэтому все инструкции по запуску, компиляции и сборки проекта должны быть отражены в соответствующих файлах, например, make\sphinxhyphen{}файлах. Среда разработки должна использовать эти файлы при работе. Проще говоря, \sphinxstylestrong{среда разработки должна упрощать разработку и не подменять ее этапы}. Сборка из командной строки становится незаменимой, когда нужно собрать множество проектов, которые должны работать в рамках одной системы. Нужно также помнить, что среды разработки гораздо разнообразнее, чем командные строки, и пользователь, скорее всего, воспользуется командной строкой вместо того, чтобы устанавливать новую среду разработки.


\subsection{Настройка окружения под себя}
\label{\detokenize{educational_materials/ide/content:id6}}
\sphinxAtStartPar
Вы можете приобрести какие\sphinxhyphen{}то привычки при написании кода. Например, использовать табуляцию для отделения блоков кода, при том что общепринятым способом делать отступы являются 4 пробела. Т.е. вы забираете код с git, правите его, и часть строк вместо отступов с пробелами получаются с табуляцией. И даже если это не вызовет ошибку при исполнении кода (в Python вызовет), это будет все равно будет неудобно, так как длина табуляции может быть различна для различных редакторов. Мы можем настроить среду разработки так, чтобы когда мы нажимаем на \sphinxcode{\sphinxupquote{Tab}}, вместо табуляции подставлялось 4 пробела (или столько, сколько принято для данного проекта). Поэтому среда разработки может взять на себя часть функций по редактированию кода, а разработчик продолжит работать так, как привык. Это упрощенный пример.


\chapter{Стили оформления кода}
\label{\detokenize{index:id6}}
\sphinxstepscope


\section{Оформление кода}
\label{\detokenize{educational_materials/styles/content:id1}}\label{\detokenize{educational_materials/styles/content::doc}}
\sphinxAtStartPar
Если мы хотим создать полезную библиотеку, мы должны позаботиться об оформлении кода, чтобы его было удобно читать. Для больших проектов с активным сообществом справедливо утверждение, что код больше читают, чем пишут. И если мы хотим участвовать в таком сообществе, нужно не только производить фичи, но и хорошо их оформлять. Хорошо — это значит общепринятым способом, чтобы другой разработчик не тратил время на понимание того, что вы почему\sphinxhyphen{}то решили назвать переменную так, как обычно называют класс. Есть интуитивно понятные правила оформления кода, например, с использованием отступов. Но существуют не такие очевидные, например, где мы должны переносить строку, \sphinxhref{https://peps.python.org/pep-0008/\#should-a-line-break-before-or-after-a-binary-operator}{до или после знака оператора}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}wrong}
\PYG{n}{income} \PYG{o}{=} \PYG{p}{(}\PYG{n}{gross\PYGZus{}wages} \PYG{o}{+}
          \PYG{n}{taxable\PYGZus{}interest} \PYG{o}{+}
          \PYG{p}{(}\PYG{n}{dividends} \PYG{o}{\PYGZhy{}} \PYG{n}{qualified\PYGZus{}dividends}\PYG{p}{)} \PYG{o}{\PYGZhy{}}
          \PYG{n}{ira\PYGZus{}deduction} \PYG{o}{\PYGZhy{}}
          \PYG{n}{student\PYGZus{}loan\PYGZus{}interest}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}correct    }
\PYG{n}{income} \PYG{o}{=} \PYG{p}{(}\PYG{n}{gross\PYGZus{}wages}
          \PYG{o}{+} \PYG{n}{taxable\PYGZus{}interest}
          \PYG{o}{+} \PYG{p}{(}\PYG{n}{dividends} \PYG{o}{\PYGZhy{}} \PYG{n}{qualified\PYGZus{}dividends}\PYG{p}{)}
          \PYG{o}{\PYGZhy{}} \PYG{n}{ira\PYGZus{}deduction}
          \PYG{o}{\PYGZhy{}} \PYG{n}{student\PYGZus{}loan\PYGZus{}interest}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Можно думать о стиле как о минимально необходимом наборе всех возможностей языка программирования по написанию и оформлению кода: даже если мы можем так написать, мы не будем — в угоду читаемости. Соблюдение стиля не всегда приводит к меньшему количеству кода. Мы можем обратиться к дзену Python и увидим, что там нет строчки про количество кода, поэтому лучше получить более читаемый, явный и простой код, чем короткий, но сложный, в котором происходит что\sphinxhyphen{}то неявное.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{this} 

\PYG{n}{The} \PYG{n}{Zen} \PYG{n}{of} \PYG{n}{Python}\PYG{p}{,} \PYG{n}{by} \PYG{n}{Tim} \PYG{n}{Peters}

\PYG{n}{Beautiful} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{ugly}\PYG{o}{.}
\PYG{n}{Explicit} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{implicit}\PYG{o}{.}
\PYG{n}{Simple} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n+nb}{complex}\PYG{o}{.}
\PYG{n}{Complex} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{complicated}\PYG{o}{.}
\PYG{n}{Flat} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{nested}\PYG{o}{.}
\PYG{n}{Sparse} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{dense}\PYG{o}{.}
\PYG{n}{Readability} \PYG{n}{counts}\PYG{o}{.}
\PYG{n}{Special} \PYG{n}{cases} \PYG{n}{aren}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t special enough to break the rules.}
\PYG{n}{Although} \PYG{n}{practicality} \PYG{n}{beats} \PYG{n}{purity}\PYG{o}{.}
\PYG{n}{Errors} \PYG{n}{should} \PYG{n}{never} \PYG{k}{pass} \PYG{n}{silently}\PYG{o}{.}
\PYG{n}{Unless} \PYG{n}{explicitly} \PYG{n}{silenced}\PYG{o}{.}
\PYG{n}{In} \PYG{n}{the} \PYG{n}{face} \PYG{n}{of} \PYG{n}{ambiguity}\PYG{p}{,} \PYG{n}{refuse} \PYG{n}{the} \PYG{n}{temptation} \PYG{n}{to} \PYG{n}{guess}\PYG{o}{.}
\PYG{n}{There} \PYG{n}{should} \PYG{n}{be} \PYG{n}{one}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o+ow}{and} \PYG{n}{preferably} \PYG{n}{only} \PYG{n}{one} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{obvious} \PYG{n}{way} \PYG{n}{to} \PYG{n}{do} \PYG{n}{it}\PYG{o}{.}
\PYG{n}{Although} \PYG{n}{that} \PYG{n}{way} \PYG{n}{may} \PYG{o+ow}{not} \PYG{n}{be} \PYG{n}{obvious} \PYG{n}{at} \PYG{n}{first} \PYG{n}{unless} \PYG{n}{you}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re Dutch.}
\PYG{n}{Now} \PYG{o+ow}{is} \PYG{n}{better} \PYG{n}{than} \PYG{n}{never}\PYG{o}{.}
\PYG{n}{Although} \PYG{n}{never} \PYG{o+ow}{is} \PYG{n}{often} \PYG{n}{better} \PYG{n}{than} \PYG{o}{*}\PYG{n}{right}\PYG{o}{*} \PYG{n}{now}\PYG{o}{.}
\PYG{n}{If} \PYG{n}{the} \PYG{n}{implementation} \PYG{o+ow}{is} \PYG{n}{hard} \PYG{n}{to} \PYG{n}{explain}\PYG{p}{,} \PYG{n}{it}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s a bad idea.}
\PYG{n}{If} \PYG{n}{the} \PYG{n}{implementation} \PYG{o+ow}{is} \PYG{n}{easy} \PYG{n}{to} \PYG{n}{explain}\PYG{p}{,} \PYG{n}{it} \PYG{n}{may} \PYG{n}{be} \PYG{n}{a} \PYG{n}{good} \PYG{n}{idea}\PYG{o}{.}
\PYG{n}{Namespaces} \PYG{n}{are} \PYG{n}{one} \PYG{n}{honking} \PYG{n}{great} \PYG{n}{idea} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{let}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s do more of those!}
\end{sphinxVerbatim}


\subsection{Используйте отступы}
\label{\detokenize{educational_materials/styles/content:id2}}
\sphinxAtStartPar
Одно из основных правил хорошего стиля программирования (code style) заключается в том, что разные уровни вложенности стоит выделять при помощи отступов, используя знаки пробела или табуляции. \sphinxstylestrong{Работая с кодом в рамках одного файла, стоит использовать что\sphinxhyphen{}то одно: или пробелы, или табуляцию}.
Если вы попробуете использовать и то, и другое, набирая код программы на Python, то интерпретатор выдаст вам сообщение об ошибке. В других языках программирования такая ситуация не вызовет ошибку синтаксиса, однако читать код с отступами приятнее, он легче и быстрее воспринимается разработчиком. Еще больше информации о стиле программирования можно узнать из документа \sphinxhref{https://peps.python.org/pep-0008/}{pep8}. В нем множество рекомендаций по оформлению кода на языке Python.

\sphinxAtStartPar
Код без отступов:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DEFINE\PYGZus{}NAME true}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}\PYG{+w}{   }
\PYG{c+c1}{//not indented code    }
\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{DEFINE\PYGZus{}NAME}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello, }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{    }
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{k}{else}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{    }
\PYG{p}{\PYGZcb{}}
\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{   }
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Код с отступами:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DEFINE\PYGZus{}NAME true}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{name}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{DEFINE\PYGZus{}NAME}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello, }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
В Python также есть ситуации, когда отступы не будут приводить к ошибке, например, при вызове функции, название и аргументы которой не помещаются в максимальную длину строки и должны быть перенесены на следующую строку.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}buity }
\PYG{n}{foo} \PYG{o}{=} \PYG{n}{long\PYGZus{}function\PYGZus{}name}\PYG{p}{(}\PYG{n}{var\PYGZus{}one}\PYG{p}{,} \PYG{n}{var\PYGZus{}two}\PYG{p}{,}
                         \PYG{n}{var\PYGZus{}three}\PYG{p}{,} \PYG{n}{var\PYGZus{}four}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}not\PYGZus{}so\PYGZus{}buity}
\PYG{n}{foo} \PYG{o}{=} \PYG{n}{long\PYGZus{}function\PYGZus{}name}\PYG{p}{(}\PYG{n}{var\PYGZus{}one}\PYG{p}{,} \PYG{n}{var\PYGZus{}two}\PYG{p}{,}
           \PYG{n}{var\PYGZus{}three}\PYG{p}{,} \PYG{n}{var\PYGZus{}four}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Оба варианта валидны с точки зрения интерпретатора, но первый более читаем. В \sphinxhref{https://peps.python.org/pep-0008/\#should-a-line-break-before-or-after-a-binary-operator}{разных} ситуациях отступы используются по\sphinxhyphen{}разному. Если чувствуете, что участок кода сложен при оформлении, обратитесь к руководству по стилю.


\subsection{Соблюдайте принятую длину строки}
\label{\detokenize{educational_materials/styles/content:id3}}
\sphinxAtStartPar
В разных языках программирования и в разных проектах может быть принята разная максимальная длина строки. Когда я работал над проектом на Java, мы использовали длину строки 120 символов. В Python принято вмещать код на каждой строке в \sphinxhref{https://peps.python.org/pep-0008/\#maximum-line-length}{79 символов}, а комментарии в 72 символа. Отчасти это историческое ограничение, связанное с тем, что раньше были маленькие экраны. Но даже с появлением широкоформатных экранов от этого элемента форматирования не стали отказываться, так как человеку проще воспринимать более узкие колонки текста. Во многих изданиях принято оформлять текст в виде нескольких колонок на одной странице, хотя ничто не мешает занять всю ширину страницы. Также такой подход позволяет разделить экран ноутбука на две области и быть уверенными, что код войдет по ширине в обе, и шрифт не будет слишком мелким. Не заставляйте своих коллег скролить горизонтально, это не круто.

\sphinxAtStartPar
Существуют разные способы разбить длинную строку на несколько коротких. Они будут зависеть от языка программирования и от конкретного участка кода, который нужно перенести на другую строку.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{super\PYGZus{}long\PYGZus{}condition\PYGZus{}variable} \PYG{o}{==} \PYG{k+kc}{True} \PYG{o+ow}{and} \PYG{n}{another\PYGZus{}condition\PYGZus{}with\PYGZus{}yet\PYGZus{}longer\PYGZus{}name} \PYG{o}{==} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{k}{pass}
    \PYG{c+c1}{\PYGZsh{} do stuff here}
\end{sphinxVerbatim}

\sphinxAtStartPar
Просто перенести второе условие на новую строку нельзя, будет ошибка:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{super\PYGZus{}long\PYGZus{}condition\PYGZus{}variable} \PYG{o}{==} \PYG{k+kc}{True} \PYG{o+ow}{and} 
   \PYG{n}{another\PYGZus{}condition\PYGZus{}with\PYGZus{}yet\PYGZus{}longer\PYGZus{}name} \PYG{o}{==} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{k}{pass}
    \PYG{c+c1}{\PYGZsh{} do stuff here}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{k}{if} \PYG{n}{super\PYGZus{}long\PYGZus{}condition\PYGZus{}variable} \PYG{o}{==} \PYG{k+kc}{True} \PYG{o+ow}{and}
                                                 \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}\PYG{p}{:} \PYG{n}{invalid} \PYG{n}{syntax}
\end{sphinxVerbatim}

\sphinxAtStartPar
Можно окружить условие скобками. Скобки имеют более высокий приоритет, чем перенос, поэтому пример внизу выполнится корректно

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{super\PYGZus{}long\PYGZus{}condition\PYGZus{}variable} \PYG{o}{==} \PYG{k+kc}{True} \PYG{o+ow}{and} 
    \PYG{n}{another\PYGZus{}condition\PYGZus{}with\PYGZus{}yet\PYGZus{}longer\PYGZus{}name} \PYG{o}{==} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
    \PYG{c+c1}{\PYGZsh{} do stuff here}
\end{sphinxVerbatim}

\sphinxAtStartPar
Можно использовать явный способ сказать интерпретатору, что строка ниже является продолжением текущей строки:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{super\PYGZus{}long\PYGZus{}condition\PYGZus{}variable} \PYG{o}{==} \PYG{k+kc}{True} \PYG{o+ow}{and} \PYGZbs{}
   \PYG{n}{another\PYGZus{}condition\PYGZus{}with\PYGZus{}yet\PYGZus{}longer\PYGZus{}name} \PYG{o}{==} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{k}{pass}
    \PYG{c+c1}{\PYGZsh{} do stuff here}
\end{sphinxVerbatim}

\sphinxAtStartPar
В математических выражениях удобнее использовать скобки:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{income} \PYG{o}{=} \PYG{p}{(}\PYG{n}{gross\PYGZus{}wages}
          \PYG{o}{+} \PYG{n}{taxable\PYGZus{}interest}
          \PYG{o}{+} \PYG{p}{(}\PYG{n}{dividends} \PYG{o}{\PYGZhy{}} \PYG{n}{qualified\PYGZus{}dividends}\PYG{p}{)}
          \PYG{o}{\PYGZhy{}} \PYG{n}{ira\PYGZus{}deduction}
          \PYG{o}{\PYGZhy{}} \PYG{n}{student\PYGZus{}loan\PYGZus{}interest}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Так же, как и при вызове функции.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{long\PYGZus{}function\PYGZus{}name}\PYG{p}{(}\PYG{n}{var\PYGZus{}one}\PYG{p}{,} \PYG{n}{var\PYGZus{}two}\PYG{p}{,} \PYG{n}{var\PYGZus{}three}\PYG{p}{,} \PYG{n}{var\PYGZus{}four}\PYG{p}{,}
                   \PYG{n}{var\PYGZus{}six}\PYG{p}{,} \PYG{n}{var\PYGZus{}seven}\PYG{p}{,} \PYG{n}{var\PYGZus{}eight}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Используйте фигурные скобки правильно}
\label{\detokenize{educational_materials/styles/content:id4}}
\sphinxAtStartPar
В С++ и в других языках, которые используют фигурные скобки для выделение блоков кода, мы можем не писать фигурные скобки у условного оператора или оператора цикла.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{age}\PYG{p}{;}
\PYG{c+c1}{//get age from user}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{age}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{allow\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{disable\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Но лучше всегда их использовать, даже если вы полностью уверены, что в тело условия больше не будет добавлено ни одной строчки. Опять же, использование единого оформления позволит не отвлекаться и читать код быстрее.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{age}\PYG{p}{;}
\PYG{c+c1}{//get age from user}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{age}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{allow\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{disable\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Есть также альтернативное оформление, которое, на мой взгляд, выглядит более приятно при условии использования отступов. Уточните, какой из этих способов принят в команде, к которой вы подключаетесь. Но скобки должны быть всегда.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{age}\PYG{p}{;}
\PYG{c+c1}{//get age from user}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{age}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{allow\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{disable\PYGZus{}18plus\PYGZus{}content}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Именуйте объекты правильно}
\label{\detokenize{educational_materials/styles/content:id5}}
\sphinxAtStartPar
Среди начинающих программистов и своих студентов я часто встречаю именование переменных либо одним ничего не значащим символом, любо транслитом.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{srednee}\PYG{p}{(}\PYG{n}{znacheniya}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{znacheniya}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{znacheniya}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Как первое, так и второе — плохо. Именование с использованием транслита не позволит другому разработчику понять, что это за функция и что она делает. Еще одна частая проблема, которая встречается при именовании объектов, — сохранение контекста, который использовался при разработке. Например, мы работаем с датчиком, который предоставляет температуру (\sphinxcode{\sphinxupquote{temperature}}) и давление (\sphinxcode{\sphinxupquote{pressure}}). Мы хотим как\sphinxhyphen{}то обработать данные, например, найти среднее значение. Мы начинаем разработку и выбираем использовать температуру, чтобы проверять нашу работу. Мы правильно пишем название функции, а аргументом передаем список снятых значений температуры. Вроде бы все нормально.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{average}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)}

\PYG{n}{vals} \PYG{o}{=} \PYG{n}{measure\PYGZus{}temperature}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{average\PYGZus{}temperature} \PYG{o}{=} \PYG{n}{average}\PYG{p}{(}\PYG{n}{vals}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы протестировали функцию и довольны ее работой, и теперь готовы применить ее к показаниям давления. И все… работает. Мы счастливы и коммитим свою работу. А разработчик, который будет потом разбираться в нашем коде, долго не сможет понять, почему температура ведет себя как давление.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vals} \PYG{o}{=} \PYG{n}{measure\PYGZus{}pressure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{average\PYGZus{}pressure} \PYG{o}{=} \PYG{n}{average}\PYG{p}{(}\PYG{n}{vals}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Используйте несколько слов там, где это нужно. Например, мы могли просто назвать функцию \sphinxcode{\sphinxupquote{pressure()}}.  И что это значит, «давление»? Измерить, прочитать из файла, забрать из базы данных, что я делаю с давлением? Тот вариант, который использовали мы, \sphinxcode{\sphinxupquote{measure\_pressure()}}, сразу даст понять, что это функция измерения давления, и скорее всего она работает с датчиком, а не получает давление каким\sphinxhyphen{}то другим способом. Здесь можно прокомментировать, что непонятно, что эта функция дает ряд значений, а не одно. Мы можем согласиться с этим и добавить эту информацию к названию функции, или сделать это через обязательные аргументы.
Существуют два основных способа именования переменных и функций: через подчеркивания (\sphinxcode{\sphinxupquote{measure\_pressure}}) и CamelCase (\sphinxcode{\sphinxupquote{measurePressure}}). На мой взгляд, через подчеркивание удобнее, так как мы используем название классов с заглавными буквами (\sphinxcode{\sphinxupquote{PressureSensor}}), и при беглом чтении разница в одной заглавной (для классов) или строчной (для переменных и функций) менее заметна, чем при использовании подчеркиваний.
При выборе имени для переменной используйте существительные, а для функции — глагол.


\subsection{Придерживаться определенного подхода}
\label{\detokenize{educational_materials/styles/content:id6}}
\sphinxAtStartPar
Этот пункт не относится напрямую к стилю кода и не является строгим требованием. Код состоит из определенных конструкций, и неплохая идея — пользоваться одним подходом для написания одной и той же функциональности. Например, если нам нужно открыть файл, мы можем сделать это несколькими способами:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}do something}
\end{sphinxVerbatim}

\sphinxAtStartPar
или

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}do something}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Это простой пример, и есть соглашение о том, что конструкция с \sphinxcode{\sphinxupquote{with}} лучше. Но в других ситуациях, когда нет устоявшегося способа написать участок кода, вам придется приходить к этому внутри команды. То же самое касается и подходов к программированию. Например, Python позволяет использовать основные парадигмы программирования: объектно\sphinxhyphen{}ориентированную, процедурную, функциональную и императивную. Мы можем смешивать их в рамках одной программы, и это не будет ошибкой. Есть решения, где использование другого подхода оправдано: все так делают, и решение более красивое и явное, чем при использовании другого подхода. Однако использование другого подхода только ради того, чтобы его использовать, не будет хорошей идеей и ухудшит читаемость кода.


\subsection{Избегайте вложенности (Flat is better than nested)}
\label{\detokenize{educational_materials/styles/content:flat-is-better-than-nested}}
\sphinxAtStartPar
Этот пункт взять из дзена Python, и ему можно легко дать количественную оценку — уровни вложенности можно посчитать. Возьмем код ниже:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}nested}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{c} \PYG{o}{!=} \PYG{l+m+mi}{6}\PYG{p}{:} 
                \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{n}{c}
    \PYG{k}{return} \PYG{k+kc}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
И уберем вложенность:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{c} \PYG{o}{!=} \PYG{l+m+mi}{6}\PYG{p}{:} 
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
Задание: попробуйте прогнать код с вложенностью через autopep8 и проверьте, что произойдет. Как думаете, почему так?


\subsection{Не перегружайте код (Sparse is better than dense)}
\label{\detokenize{educational_materials/styles/content:sparse-is-better-than-dense}}
\sphinxAtStartPar
Хотя мы должны вмещать код в 8 строк, мы можем написать очень насыщенный код. Код ниже заставить разработчика остановиться и потратить какое\sphinxhyphen{}то время, чтобы разобраться в нем, если ему нужно что\sphinxhyphen{}то поправить или реализовать подобный функционал у себя.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{capacity} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{o}{*}\PYG{o}{*}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s+s2}{ bits can store number up to }\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{bc} \PYG{k}{for} \PYG{n}{bc} \PYG{o+ow}{in} \PYG{n}{capacity}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8} \PYG{n}{bits} \PYG{n}{can} \PYG{n}{store} \PYG{n}{number} \PYG{n}{up} \PYG{n}{to} \PYG{l+m+mi}{255}
\PYG{l+m+mi}{16} \PYG{n}{bits} \PYG{n}{can} \PYG{n}{store} \PYG{n}{number} \PYG{n}{up} \PYG{n}{to} \PYG{l+m+mi}{65535}
\PYG{l+m+mi}{32} \PYG{n}{bits} \PYG{n}{can} \PYG{n}{store} \PYG{n}{number} \PYG{n}{up} \PYG{n}{to} \PYG{l+m+mi}{4294967295}
\PYG{l+m+mi}{64} \PYG{n}{bits} \PYG{n}{can} \PYG{n}{store} \PYG{n}{number} \PYG{n}{up} \PYG{n}{to} \PYG{l+m+mi}{18446744073709551615}
\end{sphinxVerbatim}

\sphinxAtStartPar
Написав больше кода, мы можем уменьшить время, которое разработчик тратит на изучение этого участка.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{capacity} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{i}
    \PYG{n}{bits} \PYG{o}{=} \PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{8}
    \PYG{n}{max\PYGZus{}val} \PYG{o}{=} \PYG{l+m+mi}{256}\PYG{o}{*}\PYG{o}{*}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
    \PYG{n}{capacity}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{bits} \PYG{p}{,} \PYG{n}{max\PYGZus{}val}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{bits}\PYG{p}{,} \PYG{n}{max\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{capacity}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s+s2}{ bits can store number up to }\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{bits}\PYG{p}{,} \PYG{n}{max\PYGZus{}val}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Выводы}
\label{\detokenize{educational_materials/styles/content:id7}}
\sphinxAtStartPar
Придерживаться стиля нужно для того, чтобы писать код понятно. Хороший стиль помогает быстро сориентироваться в коде и найти тот участок, за которым вы пришли в этот модуль. Часть работы по оформлению кода можно делегировать автоматическим средствам, таким как \sphinxcode{\sphinxupquote{autopep8}}. Про другую часть придется помнить и писать код с учетом этих знаний. Стиль — это не про то, чтобы писать меньше кода. Иногда (редко) вам будет казаться, что придерживаться стиля контринтуитивно, а получивший код некрасив. Но если так пишет большинство разработчиков — придерживайтесь рекомендаций, со временем вы привыкнете. Вы не сможете начать хорошо оформлять код без практики: пишите, а самое главное — читайте чужой код, чтобы понять, как пишут ваши коллеги.

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/styles/exercises:id1}}\label{\detokenize{educational_materials/styles/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/styles/exercises:id2}}
\sphinxAtStartPar
Уберите вложенность из кода ниже без изменения условий:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}nested}
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{c} \PYG{o}{!=} \PYG{l+m+mi}{6}\PYG{p}{:} 
                \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{n}{c}
    \PYG{k}{return} \PYG{k+kc}{None}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/styles/exercises:id3}}
\sphinxAtStartPar
Улучшите читаемость кода ниже. Для решения примите, что нам нужно импортировать функции \sphinxcode{\sphinxupquote{one\_function}}, \sphinxcode{\sphinxupquote{another\_function}} из \sphinxcode{\sphinxupquote{my\_module}}. Обратитесь к \sphinxhref{https://note.nkmk.me/en/python-import-usage/}{этой} статье, если вам нужна помощь в оформлении.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}\PYG{o}{,} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{k+kn}{from} \PYG{n+nn}{my\PYGZus{}module} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
Хорошим стилем считается использование импортов каждой сущности отдельно.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{from} \PYG{n+nn}{my\PYGZus{}module} \PYG{k+kn}{import} \PYG{p}{(}\PYG{n}{one\PYGZus{}function}\PYG{p}{,} 
                       \PYG{n}{another\PYGZus{}function}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/styles/exercises:id4}}
\sphinxAtStartPar
Улучшите читаемость кода ниже, убрав лишние пробелы и добавив нужные там, где это необходимо.

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,} \PYG{n}{factor}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Multiply two numbers with factor.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b}

\PYG{n}{x} \PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=}\PYG{l+m+mi}{5}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{result}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10} \PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result is greater than 10.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
Мы должны поправить несколько моментов.
* Вокруг арифметических, логических операторов есть пробелы, например, (\sphinxcode{\sphinxupquote{a * b}}, \sphinxcode{\sphinxupquote{x = 10}} и \sphinxcode{\sphinxupquote{y = 5}}), что упрощает идентификацию выполняемой операции. Вокруг оператора присваивания пробелы также ставятся, кроме случаев использования при объявлении функции.
* Перед двоеточием в условном операторе пробела нет, что улучшает связность кода.
* После запятой, которая разделяет аргументы функции, мы ставим пробел.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{factor}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Multiply two numbers.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{result} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result is greater than 10.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задача 4}
\label{\detokenize{educational_materials/styles/exercises:id5}}
\sphinxAtStartPar
Улучшите именование переменных, функций и классов. Используйте CamelCase для классов и разделение подчеркиванием для функций.

\sphinxAtStartPar
\sphinxstylestrong{Фрагмент 1}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Bad style}
\PYG{k}{def} \PYG{n+nf}{calcrect1}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the perimeter of a rectangle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{l} \PYG{o}{+} \PYG{n}{w}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{calcrect2}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the area of a rectangle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{l} \PYG{o}{*} \PYG{n}{w}


\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}class}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n} \PYG{o}{=} \PYG{n}{n}
    
    \PYG{k}{def} \PYG{n+nf}{pn}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{My name is }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ 1}

\sphinxAtStartPar
Мы должны поправить имена переменных, чтобы они не состояли из одной буквы. Имя функции сокращено и не дает понимания того, что функция делает: \sphinxcode{\sphinxupquote{calcrect1}} не дает понимания, что именно будет рассчитано.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}area\PYGZus{}of\PYGZus{}rectangle}\PYG{p}{(}\PYG{n}{length}\PYG{p}{,} \PYG{n}{width}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the area of a rectangle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{length} \PYG{o}{*} \PYG{n}{width}

\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}perimeter\PYGZus{}of\PYGZus{}rectangle}\PYG{p}{(}\PYG{n}{length}\PYG{p}{,} \PYG{n}{width}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the area of a rectangle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{length} \PYG{o}{+} \PYG{n}{width}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}


\PYG{k}{class} \PYG{n+nc}{MyClass}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{name}
    
    \PYG{k}{def} \PYG{n+nf}{print\PYGZus{}name}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{My name is }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Фрагмент 2}

\sphinxAtStartPar
Для примера ниже предполагается, что база данных хранит данные о покупателе и его карточку.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Bad style}
\PYG{n}{maxAttempts} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{circleArea}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the area of a circle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{l+m+mf}{3.14} \PYG{o}{*} \PYG{n}{r} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{k}{class} \PYG{n+nc}{customer\PYGZus{}db}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cust} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cars} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    
    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}cust}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cust}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}cust\PYGZus{}count}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cust}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}cust\PYGZus{}car}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cars}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cc}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ 2}

\sphinxAtStartPar
Часто бывает, что сокращение начинает читаться как другое слово. Так в примере карточка (card) стала машиной (car).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MAX\PYGZus{}RETRY\PYGZus{}ATTEMPTS} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}circle\PYGZus{}area}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the area of a circle.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{l+m+mf}{3.14} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{k}{class} \PYG{n+nc}{CustomerDatabase}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{customers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cards} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    
    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}customer}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{customer}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{customers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{customer}\PYG{p}{)}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}customer\PYGZus{}count}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{customers}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}customer\PYGZus{}card}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{customer}\PYG{p}{,} \PYG{n}{card}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cards}\PYG{p}{[}\PYG{n}{customer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{card}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Фрагмент 3}

\sphinxAtStartPar
Бывает, что мы называем объект, используя какие\sphinxhyphen{}то свои ассоциации или что\sphinxhyphen{}то еще, что делает название понятным для нас, но будет сбивать с толку других разработчиков. Поправьте код ниже чтобы, каждый мог понять, что мы создали класс Кольцо. Поправьте название методов.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Bad style (objects named improperly)}
\PYG{k}{class} \PYG{n+nc}{Donut}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{material}\PYG{p}{,} \PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{material} \PYG{o}{=} \PYG{n}{material}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{n}{size}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ingredient}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{material}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}circle}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}

\PYG{n}{new\PYGZus{}donut} \PYG{o}{=} \PYG{n}{Donut}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gold}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{medium}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{new\PYGZus{}donut}\PYG{o}{.}\PYG{n}{get\PYGZus{}ingredient}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Output: gold}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{new\PYGZus{}donut}\PYG{o}{.}\PYG{n}{get\PYGZus{}circle}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} 
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Ring}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{material}\PYG{p}{,} \PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{material} \PYG{o}{=} \PYG{n}{material}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{n}{size}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}material}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{material}
    
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}size}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}

\PYG{n}{new\PYGZus{}ring} \PYG{o}{=} \PYG{n}{Ring}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gold}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{medium}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{new\PYGZus{}ring}\PYG{o}{.}\PYG{n}{get\PYGZus{}material}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Output: gold}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{new\PYGZus{}ring}\PYG{o}{.}\PYG{n}{get\PYGZus{}size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}    
\end{sphinxVerbatim}


\subsection{Задача 5}
\label{\detokenize{educational_materials/styles/exercises:id6}}
\sphinxAtStartPar
Напишите комментарии к функции, чтобы дать понимание о ее работе. Попробуйте описать функцию, которая рассчитывает прибыль по инвестициям.

\sphinxAtStartPar
\sphinxstylestrong{Фрагмент 1}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}interest}\PYG{p}{(}\PYG{n}{principal}\PYG{p}{,} \PYG{n}{rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{final\PYGZus{}amount} \PYG{o}{=} \PYG{n}{principal} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{rate} \PYG{o}{/} \PYG{n}{n}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{n} \PYG{o}{*} \PYG{n}{time}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{final\PYGZus{}amount}


\PYG{c+c1}{\PYGZsh{} Example usage}
\PYG{n}{principal\PYGZus{}amount} \PYG{o}{=} \PYG{l+m+mf}{1000.0}
\PYG{n}{annual\PYGZus{}interest\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.05}  
\PYG{n}{investment\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{5}  
\PYG{n}{final\PYGZus{}amount} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}interest}\PYG{p}{(}\PYG{n}{principal\PYGZus{}amount}\PYG{p}{,} \PYG{n}{annual\PYGZus{}interest\PYGZus{}rate}\PYG{p}{,} \PYG{n}{investment\PYGZus{}time}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The final amount after }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{investment\PYGZus{}time}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ years is: \PYGZdl{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{final\PYGZus{}amount}\PYG{l+s+si}{:}\PYG{l+s+s2}{.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Less obvious code that benefits from comments}

\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}interest}\PYG{p}{(}\PYG{n}{principal}\PYG{p}{,} \PYG{n}{rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate compound interest for the given parameters.}

\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        principal (float): The principal amount (initial investment).}
\PYG{l+s+sd}{        rate (float): The annual interest rate in decimal form (e.g., 0.05 for 5\PYGZpc{}).}
\PYG{l+s+sd}{        time (int): The time period in years.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        float: The final amount after compounding the interest.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Formula for compound interest: A = P(1 + r/n)\PYGZca{}(nt)}
    \PYG{c+c1}{\PYGZsh{} A: Final amount after compounding the interest}
    \PYG{c+c1}{\PYGZsh{} P: Principal amount}
    \PYG{c+c1}{\PYGZsh{} r: Annual interest rate}
    \PYG{c+c1}{\PYGZsh{} t: Time period in years}

    \PYG{c+c1}{\PYGZsh{} In this implementation, we\PYGZsq{}ll assume interest is compounded annually (n=1)}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{c+c1}{\PYGZsh{} Calculate the final amount after compounding interest}
    \PYG{n}{final\PYGZus{}amount} \PYG{o}{=} \PYG{n}{principal} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{rate} \PYG{o}{/} \PYG{n}{n}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{n} \PYG{o}{*} \PYG{n}{time}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{final\PYGZus{}amount}

\PYG{c+c1}{\PYGZsh{} Example usage}
\PYG{n}{principal\PYGZus{}amount} \PYG{o}{=} \PYG{l+m+mf}{1000.0}
\PYG{n}{annual\PYGZus{}interest\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.05}  \PYG{c+c1}{\PYGZsh{} 5\PYGZpc{} interest rate}
\PYG{n}{investment\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{5}  \PYG{c+c1}{\PYGZsh{} 5 years}
\PYG{n}{final\PYGZus{}amount} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}interest}\PYG{p}{(}\PYG{n}{principal\PYGZus{}amount}\PYG{p}{,} \PYG{n}{annual\PYGZus{}interest\PYGZus{}rate}\PYG{p}{,} \PYG{n}{investment\PYGZus{}time}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The final amount after }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{investment\PYGZus{}time}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ years is: \PYGZdl{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{final\PYGZus{}amount}\PYG{l+s+si}{:}\PYG{l+s+s2}{.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Фрагмент 2}

\sphinxAtStartPar
Часто бывает, что мы реализуем логику, которая специфична для конкретной ситуации и может не встречаться за ее пределами. Например, поведение функции \sphinxcode{\sphinxupquote{sum}} для чисел очевидно, она вернет суммы переданных в нее аргументов\sphinxhyphen{}чисел. Но давайте представим подсчет очков в настольной игре\sphinxhyphen{}ходилке, где количество очко зависит от тех клеток, которые прошла фишка игрока. Допустим, клетки с номером, кратным трем, содержат сундуки, которые увеличивают вклад на этой клетке в два раза. А на клетках с номером, кратным двум, находятся разбойники, которые уменьшают вклад на этой клетке в два раза.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}player\PYGZus{}total}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{item} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{k}{elif} \PYG{n}{item} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item} \PYG{o}{/} \PYG{l+m+mi}{2}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item}

    \PYG{k}{return} \PYG{n}{total}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}player\PYGZus{}total}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Process the given list of integers, that presents cells ID. }
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    Contribution of the cell to the total is based on divisibility of cell ID.}

\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data (list): A list of integers.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        int: The total value after processing the list.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{item} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} if cell id is divisible by 3, it is chest, double the value and add to \PYGZsq{}total\PYGZsq{}}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{k}{elif} \PYG{n}{item} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} if cell id is divisible by 2, it is robber, halve the value and add to \PYGZsq{}total\PYGZsq{}}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item} \PYG{o}{/} \PYG{l+m+mi}{2}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} For other numbers, add the number to \PYGZsq{}total\PYGZsq{}}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item}

    \PYG{k}{return} \PYG{n}{total}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/styles/quiz:id1}}\label{\detokenize{educational_materials/styles/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Мы именуем переменные и функции как snake\_case или CamelCase?

\item {} 
\sphinxAtStartPar
Мы именуем классы как snake\_case или CamelCase?

\item {} 
\sphinxAtStartPar
Используются ли комментарии для комментирования каждой строки кода?

\item {} 
\sphinxAtStartPar
Является ли написание docstring для функций и классов, объясняющие их назначение, хорошей практикой?

\item {} 
\sphinxAtStartPar
Считается ли одинаковый отступ (например, использование четырех пробелов для каждого уровня) хорошим стилем даже для языков, которые используют другой способ для разделения вложенных блоков кода?

\item {} 
\sphinxAtStartPar
Какая рекомендованная длина строки в Python, если в команде не принято другое? \sphinxstylestrong{Ответ}: 79 или 88 символов.

\item {} 
\sphinxAtStartPar
Считается ли использование импортов в любом месте кода хорошей практикой?

\item {} 
\sphinxAtStartPar
Является ли \sphinxcode{\sphinxupquote{from module import *}} хорошей практикой?

\item {} 
\sphinxAtStartPar
В Python строковую переменную можно создать, используя одинарные (“ „) или двойные кавычки (» «). Как регламентировано их использование? \sphinxstylestrong{Ответ}: Выбираются одинарные (“ „) или двойные кавычки (» «), и выбранный вид используется для строковых литералов во всех модулях проекта.

\item {} 
\sphinxAtStartPar
Правильно ли с точки зрения стиля использовать тернарные операторы для упрощения кода?

\item {} 
\sphinxAtStartPar
Верно ли утверждение, что код должен включать как можно больше комментариев, даже если они избыточны (например, констатация очевидного), так как из всех комментариев собирается документация?

\item {} 
\sphinxAtStartPar
Верно ли утверждение, что константы, которые встречаются в коде всего раз, должны быть использованы прямо в выражении без объявление дополнительного имени? \sphinxstylestrong{Ответ}: Нет, магические числа должны быть именованными переменными или константами с описательными именами.

\item {} 
\sphinxAtStartPar
Верно ли утверждение, что необходимо добавить пробелы в конце строки, чтобы длина строки совпадала с регламентированной, например, 79 символов?

\item {} 
\sphinxAtStartPar
Должна ли функция быть краткой, насколько это возможно, и сосредоточенной на решении одной задачи?

\item {} 
\sphinxAtStartPar
Верно ли утверждение, что аргументы функций и методов должны быть краткими, желательно однобуквенными или аббревиатурой из слов, определяющих их назначение, для экономии места?

\item {} 
\sphinxAtStartPar
Чем больше вложенность кода, тем легче его понимать, так как сразу понятен переход на уровень ниже?

\end{enumerate}


\chapter{Польза документации на примере поиска проекта на GitHub}
\label{\detokenize{index:github}}
\sphinxstepscope


\section{Сервис GitHub}
\label{\detokenize{educational_materials/github/content:github}}\label{\detokenize{educational_materials/github/content::doc}}

\subsection{Учимся читать и использовать в своем проекте чужой код с GitHub}
\label{\detokenize{educational_materials/github/content:id1}}
\sphinxAtStartPar
Перенимаем опыт других разработчиков: ищем, читаем, клонируем, внедряем…

\sphinxAtStartPar
\sphinxincludegraphics{{github-logo-vector}.png}

\sphinxAtStartPar
Как только вы начинаете погружаться в атмосферу IT\sphinxhyphen{}сообщества, в вашем информационном поле постепенно формируется круг экспертов, которых вы встречаете на конференциях, подкастах и за просмотром онлайн\sphinxhyphen{}митапа крупной компании. Большинство советов, которыми делятся опытные разработчики, можно разделить на 3 категории:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Читайте документацию и книги;

\item {} 
\sphinxAtStartPar
Изучайте новый язык или инструмент, используйте его в разработке своего PetProject;

\item {} 
\sphinxAtStartPar
Изучайте чужой код и участвуйте в «open source» разработке.

\end{enumerate}

\sphinxAtStartPar
Касательно книг обычно все понятно, рекомендуют конкретных авторов и печатные издания. Про PetProject тоже довольно ясно: хотите понять, как работает Django? Создайте свой веб\sphinxhyphen{}сервис на любую тему. Например, для обработки заказов небольшой пиццерии, с админкой, меню и регистрацией клиентов. В общем, используйте все, что идет из коробки Django, чтобы разобраться, как работает этот фреймворк.

\sphinxAtStartPar
А что по поводу третьего пункта? «Изучайте чужой код…». Обычно мысль на этом обрывается.

\sphinxAtStartPar
Сегодня попытаемся восполнить этот пробел и закрасим «белое пятно». Выстроим цепочку алгоритма, которая поможет начинающим программистам сориентироваться в поиске «чужого кода» и использовании его в своем проекте. Чтобы «не научиться плохому».
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Где и как искать код?

\item {} 
\sphinxAtStartPar
Выбрали проект — на что в первую очередь стоит обратить внимание?

\item {} 
\sphinxAtStartPar
С чего начать знакомство с чужим кодом?

\item {} 
\sphinxAtStartPar
Как использовать его в своем проекте?

\item {} 
\sphinxAtStartPar
Как опубликовать свой проект на GitHub?

\end{enumerate}


\subsection{Где и как искать код?}
\label{\detokenize{educational_materials/github/content:id2}}
\sphinxAtStartPar
Самой популярной площадкой для поиска и размещения кода является GitHub (https://github.com). Если вы ранее не пользовались этим сервисом, следует начать именно с него.

\sphinxAtStartPar
GitHub — это веб\sphinxhyphen{}платформа для контроля версий и совместной работы, которая была запущена в апреле 2008 года. Она была основана Томом Престон\sphinxhyphen{}Вернером, Крисом Ванстратом и П. Дж. Хайеттом, а сейчас принадлежит компании Microsoft.
Платформа была построена на основе системы контроля версий Git, созданной Линусом Торвальдсом в 2005 году. Git — мощная и эффективная система для управления исходным кодом и другими файлами. GitHub стремился сделать Git более доступным, предоставляя веб\sphinxhyphen{}интерфейс и набор инструментов для совместной работы и совместного использования.
GitHub быстро стал популярным среди разработчиков открытого исходного кода. Одной из ключевых особенностей платформы является возможность разветвления репозитория, что позволяет пользователям создавать собственную копию проекта и вносить изменения, не затрагивая оригинал. Это упростило для разработчиков совместную работу и участие в проектах с открытым исходным кодом.
За прошедшие годы GitHub добавил множество функций и инструментов, чтобы сделать совместную работу еще проще, в том числе:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Запросы на вытягивание (Merge Request), которые позволяют пользователям отправлять изменения в проект для проверки.

\item {} 
\sphinxAtStartPar
Проблемы (Issue), которые позволяют пользователям отслеживать ошибки и запросы функций.

\item {} 
\sphinxAtStartPar
Вики (Wiki), которые позволяют пользователям создавать документацию и другую информацию для проекта.

\item {} 
\sphinxAtStartPar
GitHubPages, который позволяет пользователям создавать и размещать веб\sphinxhyphen{}страницы для своих проектов.

\item {} 
\sphinxAtStartPar
GitHubActions, которые позволяют пользователям создавать и развертывать свой код с помощью GitHub.

\end{itemize}

\sphinxAtStartPar
В 2018 году Microsoft приобрела GitHub за 7,5 млрд долларов. С тех пор он продолжал развивать и улучшать платформу, включая запуск GitHubDiscussions, GitHubCodespaces и GitHubActions. Сегодня GitHub — это крупнейшее хранилище исходного кода в мире с более чем 40 миллионами пользователей и более чем 200 миллионами репозиториев.

\sphinxAtStartPar
Для поиска проекта достаточно ввести в строку поиска одно или несколько ключевых слов.

\sphinxAtStartPar
\sphinxincludegraphics{{github_repository_with_bad_project_structure}.png}

\sphinxAtStartPar
Рисунок 1 — Репозиторий с плохой структурой проекта

\sphinxAtStartPar
\sphinxincludegraphics{{github_repository_without_description_and_instructions}.png}
Рисунок 2 — Репозиторий без описания и инструкций

\sphinxAtStartPar
\sphinxincludegraphics{{github_repository_with_good_structure}.png}

\sphinxAtStartPar
Рисунок 3 — Репозиторий с хорошей структурой

\sphinxAtStartPar
Посмотрим описание «Readme.md»

\sphinxAtStartPar
\sphinxincludegraphics{{github_instructions_for_working_with_the_project_code}.png}

\sphinxAtStartPar
Рисунок 4 \textendash{} Инструкция по работе с кодом проекта

\sphinxAtStartPar
После знакомства с инструкцией приступаем к просмотру файлов проекта, чтобы выполнить «поверхностную реверсивную инженерию» объектов и понять его структуру. Этот процесс может занять некоторое время. В результате нам надо разобраться в коде и оценить его достоинства и недостатки, понять зависимости и попробовать составить структуру проекта в виде блок\sphinxhyphen{}схемы или псевдокода. В процессе изучения кода можно встретить различные решения, которые мы бы могли реализовать в этой задаче иначе, это вполне распространенная практика. Давайте кратко постараемся определить, каковы признаки «\sphinxstyleemphasis{хорошего кода}»:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Структура проекта понятна.

\item {} 
\sphinxAtStartPar
Задачи распределены по отдельным файлам.

\item {} 
\sphinxAtStartPar
Предусмотрена модификация кода проекта.

\item {} 
\sphinxAtStartPar
Реализована поддержка разных операционных систем (ОС). В коде есть проверка текущей ОС и сценарий корректной работы в случае отличий из\sphinxhyphen{}за разных версий ОС.

\item {} 
\sphinxAtStartPar
Ключевые места в коде прокомментированы.

\item {} 
\sphinxAtStartPar
Реализована обработка исключений.

\item {} 
\sphinxAtStartPar
Минимальная зависимость от сторонних библиотек.

\item {} 
\sphinxAtStartPar
Внешние библиотеки представлены в файле requirements.txt.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{github_view_file_requirements}.png}

\sphinxAtStartPar
Рисунок 5 — Файл requirements.txt — список сторонних библиотек


\subsubsection{Выбрали проект — на что в первую очередь стоит обратить внимание?}
\label{\detokenize{educational_materials/github/content:id3}}
\sphinxAtStartPar
\sphinxincludegraphics{{github_view_project_files}.png}

\sphinxAtStartPar
Рисунок 6 — Файлы проекта


\subsubsection{С чего начать знакомство с чужим кодом?**}
\label{\detokenize{educational_materials/github/content:id4}}
\sphinxAtStartPar
Скачаем проект и проанализируем его содержимое. Скачать проект с GitHub можно двумя способами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
используя консольное приложение git;

\item {} 
\sphinxAtStartPar
скачать проект zip\sphinxhyphen{}архивом.

\end{itemize}

\sphinxAtStartPar
Наша цель — не только посмотреть исходный код проекта, но и модифицировать его по мере знакомства с проектом.

\sphinxAtStartPar
\sphinxincludegraphics{{github_code_download_tab_from_github}.png}

\sphinxAtStartPar
Рисунок 7 — Вкладка загрузки кода с GitHub

\sphinxAtStartPar
В таком случае использование системы контроля версий git нам сильно облегчит задачу отслеживания изменений в проекте. Внося изменения в чужой код, стоит учитывать возможность возникновения ошибок и сбоев на этапе тестирования ПО. Таким образом, мы сможем лучше разобраться в коде, откатить последние изменения и выложить свой проект на GitHub, и т.д.

\sphinxAtStartPar
Приступим к подготовке рабочего окружения. Создадим на компьютере папку, в которой будет размещаться проект. Для примера будем считать, что такой директорией является: «\sphinxstylestrong{project\_github}».
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Откроем консоль в данной папке и выполним инициализацию нового проекта командой \sphinxcode{\sphinxupquote{git init}}.

\item {} 
\sphinxAtStartPar
Выполним загрузку кода из репозитория, используя команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git pull}}}, добавив в качестве аргумента ссылку на проект: «\sphinxstylestrong{\sphinxcode{\sphinxupquote{https://github.com/bfontaine/term2048.git}}}».

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{github_downloa_repository_from_github_in_terminal}.png}

\sphinxAtStartPar
Рисунок 8 — Инициализация локального \sphinxstylestrong{Git} репозитория и загрузка проекта из GitHub

\sphinxAtStartPar
В качестве альтернативы можно использовать команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git clone}}}. Можно сказать, что команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{git clone}}} выполняет две команды: \sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}} и \sphinxstylestrong{\sphinxcode{\sphinxupquote{git pull}}}.
\sphinxstylestrong{\sphinxcode{\sphinxupquote{git init}}} применяется для того, чтобы создать пустой репозиторий, а \sphinxstylestrong{\sphinxcode{\sphinxupquote{git pull}}} — чтобы наполнить его из другого репозитория. Поэтому, если вы новый участник проекта, и вам нужно получить код проекта, чтобы с ним познакомиться, то рекомендуется делать \sphinxstylestrong{\sphinxcode{\sphinxupquote{git clone}}}:

\sphinxAtStartPar
\sphinxincludegraphics{{github_clone_repository_from_github_in_terminal_descriptions}.png}

\sphinxAtStartPar
После успешного клонирования проекта из GitHub мы можем приступить к изучению кода. В нашей папке с названием «\sphinxstylestrong{project\_github}» появятся все файлы репозитория (см. рисунок), их можно открыть любым редактором, например, «\sphinxstyleemphasis{Sublime 3}». На что обращать внимание при работе с чужим кодом, чтобы прокачать \sphinxstyleemphasis{hard \& soft skills}?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Постарайтесь внимательно изучить код, учитывая инструкции и комментарии автора.

\item {} 
\sphinxAtStartPar
Может быть так, что вам попался код, который вам непонятен. Например, вы не знакомы с таким объектом/функцией, или ранее вы не использовали его подобным образом. Вам стоит попробовать написать небольшой пример для его исследования и постараться ответить на вопрос: почему разработчик использовал такое решение и чем оно лучше/хуже альтернативного варианта, который известен вам.

\item {} 
\sphinxAtStartPar
Обратите внимание, можно ли сократить код, если встречаются повторения. Например, вынести часть кода в отдельные функции или методы класса, а может, и вовсе стоит вынести участок кода в отдельный модуль. Подумайте об этом.

\item {} 
\sphinxAtStartPar
Если вы видите, что в коде допущены очевидные ошибки, например: отсутствует проверка типа аргументов; в арифметических выражениях отсутствует проверка деления на ноль; или повторяется набор одинаковых действий, которые можно оформить в цикл и т.д., оставьте комментарий и сформулируйте, как сделать лучше. Но не пытайтесь сразу приступать к работе над изменением кода до того, как ознакомитесь с ним полностью. Могут выясниться различные ограничения или структурные решения, которые привели к такой реализации.

\end{enumerate}

\sphinxAtStartPar
Если вы запустите команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{git log}}} в каталоге клонированного проекта, вы увидите следующий вывод:

\sphinxAtStartPar
\sphinxincludegraphics{{github_result_command_git_log}.png}

\sphinxAtStartPar
Рисунок 9 — Просмотр изменений командой git log

\sphinxAtStartPar
\sphinxincludegraphics{{github_result_command_git_log_key_p}.png}

\sphinxAtStartPar
Рисунок 10 — Просмотр изменений последнего коммита


\subsubsection{Как использовать чужой код в своем проекте?}
\label{\detokenize{educational_materials/github/content:id5}}
\sphinxAtStartPar
В процессе подробного изучения кода проекта у вас наверняка появится несколько идей, как его изменить, что\sphinxhyphen{}то поменять или добавить новый функционал. Например, мы можем изменить размер игрового поля, количество генерируемых чисел на поле и ввести свой рейтинг\sphinxhyphen{}лист с 10 лучшими результатами, и т.д. Так вы не только потренируете изучение чужого кода, но и разовьете навык внесения в него модификаций. Также после завершения этапа отладки кода и тестирования можно выгрузить код в репозиторий GitHub.


\subsection{Работа с GitHub}
\label{\detokenize{educational_materials/github/content:id6}}
\sphinxAtStartPar
Первым делом надо зарегистрироваться на сервисе github.com и авторизоваться на сайте (рисунок 11).

\sphinxAtStartPar
\sphinxincludegraphics{{github_login_or_registration_in_github}.png}

\sphinxAtStartPar
Рисунок 11 — Авторизация в Github

\sphinxAtStartPar
Затем переходим к созданию первого репозитория. В правой верхней части, рядом с иконкой вашего профиля, нужно нажать на значок + (плюс) и выбрать пункт «New repository» (рисунок 12).

\sphinxAtStartPar
\sphinxincludegraphics{{github_form_create_new_repository}.png}

\sphinxAtStartPar
Рисунок 12 — Создание нового репозитория

\sphinxAtStartPar
Откроется страница, на которой нужно выбрать параметры и указать дополнительную информацию о проекте (рисунок 13). Введите название нового репозитория и краткое описание, отражающее главную задачу и способ ее решения, который вы планируете реализовать. Например, в нашем случае можно назвать репозиторий «\sphinxstyleemphasis{terminalGame2048}» или «\sphinxstyleemphasis{py2048CLI}». При выборе названия старайтесь использовать «говорящие слова», чтобы разработчику со стороны было интуитивно понятно, о чем ваш проект. Использование «py» укажет, что проект на Python, а слово «game» говорит о том, что это игра. 2048 — это очень известное название игры и многих ее вариаций, а слова «terminal» и «CLI» указывают на то, что игра использует в качестве интерфейса пользователя консольное окно (терминал, командная строка). Таким образом, мы кратко в 3 словах сказали, что это игра 2048, запускается в консоли и написана на языке \sphinxstyleemphasis{Python}.

\sphinxAtStartPar
\sphinxincludegraphics{{github_page_with_parameters_of_the_new_repository}.png}

\sphinxAtStartPar
Рисунок 13 — Страница с параметрами нового репозитория

\sphinxAtStartPar
По желанию в поле «Описание репозитория» можно ввести краткую информацию об особенностях проекта. Например, какой новый функционал вы предлагаете реализовать; в чем отличие от классической игры 2048; разработка кода выполнена в рамках конкурса, школьного/студенческого проекта или хакатона. Затем следует выбрать, какого типа будет ваш новый репозиторий — открытый или закрытый:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Открытый/публичный} — исходный код этого репозитория будет доступен всем. Вы даете согласие, что другие разработчики могут просматривать и скачивать ваш код. Все проекты open source распространяются в открытых репозиториях.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Закрытый/приватный} — данный вариант часто используется коммерческими организациями. Приватные репозитории не отображаются в процессе поиска, и весь код будет скрыт для сторонних разработчиков, не участвующих в разработке этого проекта.

\end{itemize}

\sphinxAtStartPar
Далее вы можете добавить файл «\sphinxstylestrong{README}» — это документ, в котором разработчики размещают справочную информацию и инструкции по работе с проектом.

\sphinxAtStartPar
Следует помнить о том, что существует большое количество лицензий, которые регламентируют условия распространения и использования кода. В частности, это необходимо для защиты прав авторства разработчиков. Например, вы можете полностью разрешить доступ к вашему коду и дать права на его использование всем желающим в любом виде.

\sphinxAtStartPar
После нажатия на кнопку «Create repository» перед вами откроется страница с вашим только что созданным репозиторием (рисунок 14). Не стоит волноваться о настройках репозитория, их можно изменить в любое время.

\sphinxAtStartPar
\sphinxincludegraphics{{github_page_change_settings_repository}.png}

\sphinxAtStartPar
Рисунок 14 — Страница репозитория

\sphinxAtStartPar
После того как был создан репозиторий, мы можем составить описание проекта в файле «Readme.md». Информация из этого файла отображается на странице репозитория в поле сразу после файлов с кодом. Добавим описание нашего проекта, как показано на рисунке 15.

\sphinxAtStartPar
\sphinxincludegraphics{{github_page_edite_file_readme}.png}

\sphinxAtStartPar
Рисунок 15 — Редактирование описания репозитория

\sphinxAtStartPar
Чтобы посмотреть, как будет отображаться информация с описанием на странице, нужно переключиться на вкладку «Preview» (рисунок 16).

\sphinxAtStartPar
\sphinxincludegraphics{{github_page_preview_file_readme}.png}

\sphinxAtStartPar
Рисунок 16 — Предварительный просмотр c использованием стилей Markdown

\sphinxAtStartPar
Когда отображение справочной информации о нашем проекте будет удовлетворять нашим интересам, нужно сохранить изменения (рисунок 17), нажав на кнопку «Commit change». Кстати, это будет зарегистрировано системой git как создание нового коммита (commit). Это значит, что файл «Readme.md» изменил свое содержание и, следовательно, нужно его обновить.

\sphinxAtStartPar
\sphinxincludegraphics{{github_page_save_change_to_file_readme}.png}

\sphinxAtStartPar
Рисунок 17 — Сохранение изменений в файле Readme

\sphinxAtStartPar
Далее нам нужно загрузить код из нашего локального репозитория (на компьютере) в удаленный репозиторий GitHub. Для этого нужно скопировать путь к удаленному репозиторию (рисунок 18).

\sphinxAtStartPar
\sphinxincludegraphics{{github_address_of_the_remote_repository_in_github}.png}

\sphinxAtStartPar
Рисунок 18 — Адрес удаленного репозитория в GitHub

\sphinxAtStartPar
Теперь перейдем в окно консоли git. Нам надо добавить ссылку на удаленный репозиторий в конфигурацию git на нашем локальном репозитории, чтобы система git понимала, куда отправлять код (сервер и репозиторий).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} Проверка удаленного адреса репозитория
git remote \PYGZhy{}v
\PYGZsh{} Указание на новый удаленный репозиторий
git remote add origin «*ссылка\PYGZus{}на\PYGZus{}удаленный\PYGZus{}репозиторий*»
\PYGZsh{} Отправка изменений локального репозитория в удаленный, помеченный как источник
git push origin master
\end{sphinxVerbatim}

\sphinxAtStartPar
Система git потребует авторизации на сервере github. Нужно будет ввести логин и пароль, указанный при регистрации.

\sphinxAtStartPar
\sphinxincludegraphics{{github_successful_upload_of_local_repository_to_github}.png}

\sphinxAtStartPar
Рисунок 19 — Успешная загрузка локального репозитория на GitHub

\sphinxAtStartPar
После успешной загрузки кода из локального репозитория мы увидим наши файлы в репозитории на GitHub (рисунок 20).

\sphinxAtStartPar
\sphinxincludegraphics{{github_project_files_in_a_remote_github_repository}.png}

\sphinxAtStartPar
Рисунок 20 — Файлы проекта в удаленном репозитории GitHub

\sphinxAtStartPar
\sphinxstylestrong{Альтернативный вариант}

\sphinxAtStartPar
Мы подробно рассмотрели вариант работы с GitHub, но есть и более простой способ создать копию чужого репозитория. Если вы хотите вносить свой вклад в уже существующие проекты, в которых у вас нет прав на внесение изменений путем их отправки (push), вы можете создать свое собственное ответвление (fork) проекта. Это означает, что GitHub создаст вашу собственную копию проекта, она будет находиться в вашем пространстве имен, и вы сможете легко менять ее путем отправки (push) изменений.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Примечание}
Исторически так сложилось, что англоязычный термин «fork» (создание ветвления проекта) имел негативный контекстный смысл. Он означал, что кто\sphinxhyphen{}то повел проект с открытым исходным кодом в другом, отличном от оригинала, направлении. Иногда данный термин также означал создание конкурирующего проекта с другими авторами. В контексте GitHub «fork» просто означает создание ветвления проекта в собственном пространстве имен, что позволяет вносить публичные изменения и делать свой собственный вклад в более открытом виде.
\end{quote}

\sphinxAtStartPar
Таким образом, авторы проектов не обеспокоены тем, чтобы пользователи, которые хотели бы выступать в роли соавторов, имели право на внесение изменений путем их отправки (\sphinxstylestrong{\sphinxcode{\sphinxupquote{push}}}). Люди просто могут создавать свои собственные ветвления (\sphinxstyleemphasis{fork}), вносить туда изменения, а затем отправлять свои внесенные изменения в оригинальный репозиторий проекта, создавая запрос на принятие изменений (\sphinxstyleemphasis{Pull Request}). Сами же запросы на принятие изменений (\sphinxstyleemphasis{Pull Request}) будут описаны далее. Запрос на принятие изменений (\sphinxstyleemphasis{Pull Request}) откроет новую ветвь с обсуждением отправляемого кода, и автор оригинального проекта, а также другие его участники, могут обсуждать предлагаемые изменения до тех пор, пока автор проекта не будет ими доволен, после чего сможет добавить предлагаемые изменения в проект.

\sphinxAtStartPar
Для того, чтобы создать ответвление проекта, зайдите на страницу проекта и нажмите кнопку «Создать ответвление» («\sphinxstyleemphasis{Fork}»), которая расположена в правом верхнем углу.

\sphinxAtStartPar
\sphinxincludegraphics{{github_create_fork}.png}

\sphinxAtStartPar
Далее

\sphinxAtStartPar
\sphinxincludegraphics{{github_finish_create_fork}.png}


\chapter{Раздел 2. Работа над проектом}
\label{\detokenize{index:id7}}

\chapter{Стадии жизни проекта}
\label{\detokenize{index:id8}}
\sphinxstepscope


\section{Стадии жизни проекта}
\label{\detokenize{educational_materials/stages/content:id1}}\label{\detokenize{educational_materials/stages/content::doc}}

\subsection{От человека:}
\label{\detokenize{educational_materials/stages/content:id2}}\begin{quote}

\sphinxAtStartPar
Одним из важных навыков является возможность делегировать часть своей работы. При этом делегировать можно как и другим людям, так и своим инструментам. Ранее мы говорили про фреймворки, которые берут на себя рутину, позволяя сосредоточиться на функциональности. Когда мы осуществляем поиск проблемы, мы также делегируем эту задачу поисковой машине (мало кто заходит далее, чем первая страница поисковой выдачи). Искусственный интеллект в разных своих проявлениях входит в нашу жизнь, и даже в такую сложную область, как разработка ПО и \sphinxhref{https://www.nature.com/articles/d41586-023-00107-z}{создание} научных публикаций. Главная претензия к нему состоит в том, что инструменты, построенные с привлечением искусственного интеллекта, — это черный ящик, результат работы которого мы не можем полностью контролировать. Это так, но их можно использовать как ассистента, проводя оценку и корректировку выдачи данных от искусственного интеллекта. Нам кажется, что такие инструменты, как ChatGPT, являются одним из способов масштабировать свою производительность. Посмотрите вокруг: возможно, вы найдете в своей области и другие инструменты, которые позволят упростить рутинные операции. Но не перекладывайте на них творческую работу, именно она делает вас ценным. Данная глава была написана с помощью ChatGPT и является экспериментальной. Весь материал, приведенный ниже, прочитан и отредактирован или прокомментирован (каждый комментарий начинается так — \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}:…) человеком там, где это было нужно. Относитесь к содержимому данного занятия не только как к чему\sphinxhyphen{}то ценному самому по себе, но и как к демонстрации инструмента, который поможет вам коснуться темы, в которую вы бы хотели погрузиться. Вы можете проделать то же самое на эту же или другую тему, но помните, что критическое мышление вам не заменит ни одна нейросеть, кроме вашей.
\end{quote}


\subsection{Поехали}
\label{\detokenize{educational_materials/stages/content:id3}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Стадии жизни проекта: идея, визуализация, архитектура, разработка (написание кода), отладка, документация, релиз, сборка в пакет, контейнеризация. Инструменты для достижения целей на каждом из этапов. Зачем нужно пользоваться инструментами.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id4}}
\sphinxAtStartPar
Этапы разработки:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Идея}: в этой стадии вы формируете общую концепцию проекта, определяете его основные цели и задачи.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Визуализация}: на этой стадии вы создаете схемы и другие визуальные материалы, которые помогают вам лучше представить проект как набор компонентов и процессов, протекающих между ними. В разработке ПО существуют общепринятые способы представления тех или иных процессов.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Архитектура}: здесь вы определяете структуру и компоненты проекта, их взаимодействие и зависимости.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработка}: на этой стадии вы пишете код, который реализует задачи, определенные на предыдущих этапах.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Отладка}: в этой стадии вы исправляете ошибки в коде, чтобы обеспечить правильную работу всего проекта.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Документация}: здесь вы создаете различные документы, описывающие проект и его компоненты, а также инструкции по его использованию и обслуживанию.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Релиз}: на этом этапе проект готов к использованию, и вы можете выпустить его для целевой аудитории.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Сборка в пакет}: здесь вы создаете установочный пакет или дистрибутив проекта, который может быть установлен на различные компьютеры.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Контейнеризация}: на этом этапе вы размещаете проект в контейнере, который позволяет запускать его на различных платформах.

\end{itemize}

\sphinxAtStartPar
Инструменты для достижения целей на каждом из этапов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Идея}: Блокноты, мозговые штурмы, доски для мозгового штурма и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Визуализация}: Adobe Photoshop, Adobe XD, Sketch, Figma, InVision, Balsamiq Mockups и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Архитектура}: UML\sphinxhyphen{}диаграммы, ER\sphinxhyphen{}диаграммы, ARIS, Microsoft Visio и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Разработка}: Visual Studio Code, PyCharm, IntelliJ IDEA, Eclipse, Xcode и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Отладка}: Инструменты для отладки, такие как PyCharm Debugger, Visual Studio Debugger, Xcode Debugger и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Документация}: Sphinx, Javadoc, Doxygen, Markdown и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Релиз}: Git, GitHub, GitLab, Bitbucket и т.д.* (\sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{перечисленные системы являются системами контроля версий, но, как мы увидим далее по курсу, их также можно использовать как универсальный способ для дистрибуции своего кода, в отличии от, например, PyPI, который будет работать только с проектами на Python.})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Сборка в пакет}: InstallShield, MSI, RPM, Deb и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Контейнеризация}: Docker, Kubernetes, AWS Elastic Container Service и т.д.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{были описаны только те пункты, которые мы указали в запросе. Например, такой важный аспект, как контроль версий, не был описан, а GitHub и GitLab отнесены к инструментам для релиза. Мы считаем, что контроль версий должен сопровождать проект на всех этапах, поэтому мы не выделили его как отдельный этап.}


\subsection{Идея}
\label{\detokenize{educational_materials/stages/content:id5}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про идею.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id6}}
\sphinxAtStartPar
Идея — это первый этап в жизненном цикле проекта, на котором формируется концепция проекта и определяются его цели и задачи. Идея может появиться из различных источников, таких как потребности рынка, проблемы, которые нужно решить, построение инфраструктуры вокруг новых технологий или развитие существующих идей.

\sphinxAtStartPar
Важным аспектом на этапе идеи является определение целевой аудитории, которая будет использовать продукт. Необходимо понимать, с какой проблемой они сталкиваются, какие потребности у них возникают и как проект может помочь решить их проблемы и удовлетворить потребности. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{на наш взгляд, понимание целевой аудитории очень важно для успеха вашей разработки. Если вы предлагаете решение проблемы X для пользователей программы Y, работающей только под Windows, но реализуете свое решение под Linux, вы потеряете большую часть своих пользователей. Это искусственный пример, как и все в этой главе, но он дает понять важность правильной оценки целевой аудитории и ваших возможностей по улучшению ее жизни.}

\sphinxAtStartPar
При формировании идеи необходимо проводить анализ рынка и конкурентов, чтобы определить, какой потенциал имеет проект, насколько он уникален и востребован на рынке. Это поможет избежать ошибок в концепции проекта и определить его конкурентоспособность. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{уникальность очень сложно установить: ваш проект может быть немного лучше по всем параметрам, чем у конкурентов, или лучше по одному, но намного, или в него добавлено что\sphinxhyphen{}то новое, например, новая интеграция или функциональность, или же вообще нефункциональные свойства, такие как легкость установки. Например, для этого курса мы пробовали несколько редакторов Markdown, один, \sphinxhref{https://remarkable.com/}{reMarkable}, не запустился сходу, и мы решили не тратить время и попробовать следующий в списке, \sphinxhref{https://github.com/retext-project/retext}{ReText}. Он установился, и мы сразу начали писать текст, юзабилити нас устроило. Позже выяснилось, что экспортированные PDF\sphinxhyphen{}документы не такие красивые, как нам бы хотелось, и мы взяли третий редактор (осторожно, не FOSS) \sphinxhref{https://typora.io/}{Typora}, и использовали только для конвертации одного из уроков. Позже рабочие документы просматривались на GitLab, а итоговая сборка сделана с использованием \sphinxhref{https://www.sphinx-doc.org/}{Sphinx}. Т.е. для нас каждый из этих инструментов оказался по\sphinxhyphen{}своему уникальным.}

\sphinxAtStartPar
Кроме того, на этом этапе необходимо определить бюджет и время, которое потребуется для реализации проекта, а также сформировать команду проекта и определять их роли. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{мы не указывали в запросе, что речь идет об open source, возможно, тогда ответ был бы другим. Определение времени является крайне важным, особенно для open source проектов, так как позволяет установить сроки достижения желаемых результатов и, как следствие, получить дополнительную мотивацию, когда все идет по плану. Определить бюджет сложнее, так как участники таких проектов вкладывают свое свободное от основных занятий время.}

\sphinxAtStartPar
Инструменты, которые могут помочь на этом этапе, могут быть различными. Например, использование блокнотов, чтобы записать все идеи и мысли, проведение мозгового штурма, создание макетов, концептуальных чертежей и т.д. Важно выбирать инструменты, которые подходят конкретному проекту и команде и которые помогают сформировать ясное понимание концепции проекта и его потенциала. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{также важно оценивать достижимость озвученных предложений с учетом доступных командам ресурсов и инструментов. В 2017 мы хотели сделать конструктор для изучения ориентации робота внутри помещения, и на каком\sphinxhyphen{}то этапе стало понятно, что нужен лидар — устройство, которое позволяет достаточно быстро получить информацию о препятствиях на 360 градусов от робота. Тогда не было доступных вариантов, и задачу пришлось решать за счет внешней системы видеонаблюдения. Сейчас доступные лидары существуют и могут быть включены в состав конструктора. Отсутствие лидара влияет на круг задач, которые могут быть рассмотрены с применением конструктора, что может повлиять на успех решения.}


\subsection{Визуализация}
\label{\detokenize{educational_materials/stages/content:id7}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про визуализацию.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id8}}
\sphinxAtStartPar
\sphinxstylestrong{Визуализация} — это процесс создания визуальных материалов, которые помогают проиллюстрировать концепцию проекта. Этот этап жизненного цикла проекта является важным, так как визуализация помогает уточнить концепцию, сделать ее более понятной для других членов команды, заказчиков и потенциальных пользователей.

\sphinxAtStartPar
Основной целью визуализации является создание прототипов и макетов, которые помогут представить, как будет выглядеть и работать готовый продукт. Это может быть макет веб\sphinxhyphen{}сайта или мобильного приложения, физический прототип устройства, дизайн интерфейса пользователя и т.д. Визуализация также может включать в себя создание документации, которая описывает детали проекта, такие как функциональные требования, технические спецификации, диаграммы потоков данных и т.д.

\sphinxAtStartPar
Визуализация может быть выполнена вручную или с использованием специальных программных инструментов. Существует множество инструментов для создания прототипов и макетов, таких как Sketch, Figma, Adobe XD, Axure, InVision и т.д. Они позволяют создавать интерактивные прототипы, которые можно тестировать на пользователях и улучшать на основе обратной связи.

\sphinxAtStartPar
Визуализация помогает сократить время и издержки на разработку, так как позволяет увидеть ошибки и проблемы на ранних этапах проекта. Она также помогает уточнить требования и дизайн продукта, улучшить его юзабилити и общее качество, что в итоге способствует увеличению удовлетворенности пользователей и успеху проекта.


\subsection{Архитектура}
\label{\detokenize{educational_materials/stages/content:id9}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про архитектуру.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id10}}
\sphinxAtStartPar
\sphinxstylestrong{Архитектура} — это процесс проектирования структуры и организации компонентов проекта, включая аппаратные, программные и сетевые компоненты, для достижения определенных целей. Она определяет взаимодействие между компонентами и обеспечивает соответствие требованиям качества проекта, таким как производительность, надежность, безопасность и масштабируемость. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{позже мы будем говорить о тестах, и архитектура будет опосредованно тестироваться интеграционными и системными тестами. Хорошая архитектура упрощает тестирование системы, делая его более прозрачным и легким в написании.}

\sphinxAtStartPar
В зависимости от проекта мы можем разбивать архитектуру на одну или несколько частей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Архитектура приложения определяет, как будут взаимодействовать различные компоненты приложения, включая клиентскую и серверную стороны, базы данных, хранилища и т.д.

\item {} 
\sphinxAtStartPar
Архитектура базы данных определяет структуру и организацию данных, а также методы доступа к данным.

\item {} 
\sphinxAtStartPar
Архитектура сетевого взаимодействия определяет структуру сети, включая сетевые протоколы, устройства и маршрутизацию.* \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{это важно для приложений, где данные поступают из разнородных источников. Например, система, которую мы разрабатываем для научных расчетов \sphinxhref{https://simurg.space/}{SIMuRG}, основана на микросервисах, которые могут быть расположены как на компьютерах внутри локальной сети, так и на удаленных серверах. При таком подходе нам важно, как взаимодействуют узлы системы и сможем ли мы быстро перекинуть 10 Гб данных (пропускная способность) для проведения расчетов, или сможем ли мы настроить поток данных для функционирования в режиме реального времени (наличие подходящего протокола).}

\item {} 
\sphinxAtStartPar
Архитектура безопасности определяет механизмы защиты информации и данных от несанкционированного доступа и взлома.

\end{itemize}

\sphinxAtStartPar
Для достижения цели построения хорошей архитектуры необходимо использовать специальные инструменты и технологии. Например, диаграммы UML — для визуализации архитектурных концепций и отношений между компонентами. Или инструменты моделирования и прототипирования — для создания и тестирования прототипов компонентов, а также моделирования взаимодействия между компонентами. И подходящие методологии разработки, такие как Agile или DevOps.

\sphinxAtStartPar
Архитектура помогает увеличить вероятность, что проект будет соответствовать требованиям заказчика и стандартам отрасли, а также обеспечивает эффективность и производительность проекта на всех его этапах.

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{к этому можно добавить, что наличие архитектуры позволяет вовремя заметить, что мы делаем в проекте что\sphinxhyphen{}то, что потом будет невозможно поддерживать. Таким образом, архитектура отвечает не только на вопрос, что мы делаем, но и позволяет аргументировать, чего мы делать точно не будем. В open source мы будем аргументировать это прежде всего себе, что может уберечь нас от чрезмерных «костылей» в коде, которые рано или поздно могут обрушить всю систему.}


\subsection{Разработка}
\label{\detokenize{educational_materials/stages/content:id11}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про разработку.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id12}}
\sphinxAtStartPar
\sphinxstylestrong{Разработка} — это этап создания программного продукта, который включает в себя написание кода, тестирование и интеграцию различных компонентов. Важной задачей на этом этапе является реализация концептуального дизайна, представленного на этапе визуализации и архитектуры. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{в русском языке дизайн ассоциируется с графическим дизайном, в английском design имеет более широкий смысл. То, что мы разработали на предыдущем этапе, является дизайном нашего приложения, который мы должны воплотить в коде.}

\sphinxAtStartPar
На этапе разработки используются языки программирования, фреймворки, библиотеки и инструменты разработки. Разработчики пишут код, который должен соответствовать определенным стандартам качества, например, должен быть читабельным, эффективным и надежным.

\sphinxAtStartPar
Разработка может происходить по разным методологиям, таким как Agile, Waterfall или DevOps. В Agile разработка происходит в коротких итерациях, называемых спринтами, каждый из которых заканчивается работающим продуктом. В Waterfall разработка происходит последовательно, с каждым этапом, зависящим от успешного завершения предыдущего этапа. В DevOps разработка и операции объединены в цикл, чтобы обеспечить быстрое и надежное создание и внедрение продукта.

\sphinxAtStartPar
Для разработки проектов используются интегрированные среды разработки (IDE) и инструменты версионного контроля, такие как Git, SVN, Mercurial и др. IDE предоставляет программисту множество инструментов для написания кода, отладки и тестирования, а системы версионного контроля позволяют отслеживать изменения в коде и управлять версиями программного продукта.


\subsection{Отладка}
\label{\detokenize{educational_materials/stages/content:id13}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про отладку.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id14}}
\sphinxAtStartPar
\sphinxstylestrong{Отладка} — это процесс выявления, анализа и исправления ошибок в программном коде. Ошибки могут быть логическими, синтаксическими, семантическими, временными или другими, и могут привести к неправильной работе программы или даже к ее аварийному завершению.

\sphinxAtStartPar
Отладка начинается с выявления ошибки. Это может произойти в процессе тестирования продукта или приложения, а также благодаря обратной связи пользователей. На этапе отладки разработчик использует различные инструменты и технологии, чтобы определить причину ошибки и исправить ее. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{далее мы будем рассматривать тестирование подробнее. Написание тестов до или после создания кода не является отладкой само по себе. Существует такое понятие, как разработка через тестирование, и создание тестов можно отнести больше к разработке. Отладка помогает привести одну часть программного обеспечения (код) к другой (тестам). Да, тесты это тоже код, мы знаем. Тесты помогают выявлять ошибки, отладка нацелена на их исправление и достижение соответствия кода требованиям через тесты или через удовлетворения потребностей пользователя. Когда мы привлекаем пользователей к тестированию продукта, как правило, они взаимодействуют не с кодом, а с готовым приложением, и разработчики, опираясь на отзывы пользователей, пытаются воспроизвести ошибку и увидеть, что в коде пошло не так.}

\sphinxAtStartPar
Инструменты отладки могут варьироваться в зависимости от языка программирования и платформы. В общем инструменты отладки позволяют программистам проверять переменные, отслеживать выполнение кода, устанавливать точки останова, анализировать стек вызовов и многое другое. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{существует профессия тестировщика программного обеспечения. И даже можно услышать «приходите в разработку (или в IT)» через тестирование. Следует помнить, что разработчики и тестировщики — это разные профессии, в них даже хотят разного: разработчики — чтобы все работало, а тестировщики — чтобы что\sphinxhyphen{}то сломалось. Они также используют и разный инструментарий: разработчики пишут код и юнит\sphinxhyphen{}тесты, тестировщики — нет. Тестировщики подключаются на этапе тестирования более высокого уровня.}

\sphinxAtStartPar
Один из наиболее распространенных инструментов отладки — это отладчик, инструмент, который позволяет программистам запускать код пошагово, отслеживать выполнение программы, устанавливать точки останова и проверять значения переменных во время выполнения. Также используются различные виды логирования, что позволяет программистам понимать, что происходит в коде на каждом этапе выполнения программы.

\sphinxAtStartPar
Отладка может быть достаточно трудоемкой задачей, поскольку ошибки бывают довольно сложными и неочевидными. Кроме того, исправление ошибки может привести к появлению новых ошибок или нежелательному изменению поведения программы. Поэтому важно проявлять терпение и методичность в процессе отладки.

\sphinxAtStartPar
Хорошая отладка помогает обеспечить качество программного продукта и минимизировать вероятность появления ошибок при его эксплуатации. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{мы можем просто исправить ошибку или сформулировать предупреждение. В процессе отладки, работая над исправлением ошибки А, мы можем понять, что другой набор данных тоже может привести к ошибке А. Также мы можем увидеть, что ситуация B не протестирована. Сейчас все работает, но неплохо было бы написать дополнительные тесты.}


\subsection{Документация}
\label{\detokenize{educational_materials/stages/content:id15}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про документацию.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id16}}
\sphinxAtStartPar
\sphinxstylestrong{Документация} — это набор документов, который описывает программный продукт и его функциональные возможности, его архитектуру, внутреннюю структуру и правила использования. Она может включать в себя как описание внешнего интерфейса программы (API), так и внутреннего функционирования.

\sphinxAtStartPar
Документация является важной частью процесса разработки программного обеспечения, поскольку она облегчает понимание программного кода, обеспечивает легкий доступ к информации о программном продукте, а также упрощает сопровождение и модификацию программного кода. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{документация, как и тестирование, помогает посмотреть на код, который мы пишем, с другой стороны: если мы не можем описать то, что происходит на этом участке программы, равно как если мы не можем написать для него тест, или мы можем написать документацию, но она будет состоять из множества если… то…, возможно, нам стоит пересмотреть реализацию этого участка программы.}

\sphinxAtStartPar
Существует множество инструментов для создания документации, включая генераторы документации, редакторы документации и инструменты для создания диаграмм и схем. Некоторые из этих инструментов, такие как Doxygen, Javadoc и Sphinx, позволяют автоматически создавать документацию на основе комментариев в исходном коде.

\sphinxAtStartPar
Документация может содержать следующие разделы:

\sphinxAtStartPar
\sphinxstylestrong{Описание программы и ее функциональности}: этот раздел обычно включает описание основных функций, возможностей и особенностей программы, а также ее целевую аудиторию и предполагаемый способ использования.

\sphinxAtStartPar
\sphinxstylestrong{Архитектура и дизайн}: этот раздел обычно описывает внутреннюю структуру программы, ее компоненты, зависимости и отношения между ними.

\sphinxAtStartPar
\sphinxstylestrong{Руководство пользователя}: этот раздел описывает то, как использовать программу, ее функции и возможности, а также особенности пользовательского интерфейса и взаимодействия пользователя с программой. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{Мы бы еще включили туториалы как один из важных видов документации. В строгом смысле они не являются документацией, но существенно ускоряют начало использования, особенно когда речь идет о фреймворке или большой библиотеке. В отличие от руководства пользователя туториалы концентрируются на одной задаче, что позволяет пользователю быстро получить результат и решить, что проект ему полезен. Новый пользователь скорее всего пойдет сначала в туториалы, если они есть.}

\sphinxAtStartPar
\sphinxstylestrong{Руководство по установке и настройке}: этот раздел описывает процесс установки и настройки программы, ее системные требования и зависимости.

\sphinxAtStartPar
\sphinxstylestrong{Руководство по разработке}: этот раздел описывает, как разрабатывать программу, какие инструменты использовать, каким правилам оформления и кодирования следовать.

\sphinxAtStartPar
Хорошо написанная и актуальная документация улучшает качество программного продукта и повышает удобство его использования. Она может также помочь уменьшить количество ошибок, связанных с неправильным использованием программы. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{Здесь под ошибкой подразумевается не только неправильная работа приложения или кода, но и неправильное использование. Каждый проект имеет свои ограничения, и если пользователь пытается использовать его не для того, на что он был рассчитан, он получит негативный опыт.}


\subsection{Релиз}
\label{\detokenize{educational_materials/stages/content:id17}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про релиз.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id18}}
\sphinxAtStartPar
\sphinxstylestrong{Релиз} (от англ. «release») — это процесс публикации программного продукта после его разработки и тестирования. Это конечный этап в жизненном цикле проекта, который предполагает официальный выпуск программы для широкого использования. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{позже на примере проекта на Python мы посмотрим, что релиз можно сделать в виде собранного пакета (Build Distribution) или в виде исходного кода (Source Distribution). Про сборку в виде пакета смотрите в следующей секции}.

\sphinxAtStartPar
Процесс релиза обычно включает следующие этапы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Финальное тестирование: перед выпуском программного продукта должна быть проведена окончательная проверка его работоспособности и соответствия требованиям. Оно может включать автоматические и ручные тесты, проверку безопасности и производительности.

\item {} 
\sphinxAtStartPar
Подготовка к выпуску: на этом этапе происходит подготовка к выпуску, включая подготовку установочных файлов, документации, лицензий и прочего.

\item {} 
\sphinxAtStartPar
Распространение: программный продукт может быть распространен различными способами, включая загрузку с веб\sphinxhyphen{}сайта, установку из магазинов приложений, распространение по сети, установку с флэш\sphinxhyphen{}накопителей и т.д.

\item {} 
\sphinxAtStartPar
Поддержка: после выпуска программного продукта может потребоваться его поддержка, включая предоставление технической поддержки, исправление ошибок и обновление программного кода.

\item {} 
\sphinxAtStartPar
Обновление: после выпуска программного продукта может потребоваться его обновление, которое может включать исправление ошибок, улучшение функциональности и т.д.

\end{itemize}

\sphinxAtStartPar
Для успешного релиза программного продукта необходимо убедиться в его качестве, соответствии требованиям, безопасности и производительности. Для этого можно использовать различные инструменты, такие как системы контроля версий, системы автоматического тестирования, утилиты для анализа кода, системы мониторинга и т.д.

\sphinxAtStartPar
Релиз является важным этапом в жизненном цикле программного продукта, поскольку он позволяет программистам и компаниям получить обратную связь от пользователей, улучшить качество и функциональность программного продукта, а также расширить свою аудиторию и получить коммерческий успех.

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{При разработке open source проекта его код доступен в открытом доступе. Мы все равно можем говорить о релизах проекта как о точках, в которых сообщество разработчиков наиболее уверено в качестве продукта. Также компании могут открыть часть своего кода по open source лицензии.}


\subsection{Сборка}
\label{\detokenize{educational_materials/stages/content:id19}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про сборку в пакет.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id20}}
\sphinxAtStartPar
Сборка в пакет (package build) — это процесс создания программного пакета, который содержит скомпилированный код, необходимые библиотеки, настройки и другие файлы, необходимые для установки и запуска программы на другом компьютере или операционной системе.

\sphinxAtStartPar
Программные пакеты могут быть использованы для упрощения установки и распространения программного обеспечения. Вместо того, чтобы пользователь должен был скачать, компилировать и устанавливать программу вручную, он может просто скачать готовый пакет и установить его на своем компьютере. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{Основная задача — сделать так, чтобы пользователь (не разработчик) смог воспользоваться проектом. Мы можем распространять код через git и собирать его с помощью Make, но это вряд ли захочет делать каждый человек. Он хочет просто нажать на кнопку и получить на своем компьютере приложение. Для этого нужно использовать встроенные в операционную систему менеджеры типа apt и упаковывать свой проект в соответствии с их требованиями.}

\sphinxAtStartPar
Процесс сборки в пакет обычно включает следующие шаги:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Сборка программного кода: перед тем, как собрать пакет, необходимо скомпилировать программный код и создать исполняемый файл или библиотеку.

\item {} 
\sphinxAtStartPar
Упаковка необходимых файлов: после того, как скомпилированный код создан, необходимо упаковать его в пакет вместе с другими необходимыми файлами, такими как настройки, файлы конфигурации, библиотеки и прочее.

\item {} 
\sphinxAtStartPar
Создание метаданных: после того, как пакет сформирован, необходимо создать метаданные, такие как описание пакета, версия, автор и прочее.

\item {} 
\sphinxAtStartPar
Установка и тестирование: после того, как пакет сформирован и упакован, необходимо установить его на тестовой системе и протестировать его, чтобы убедиться, что он работает корректно.

\item {} 
\sphinxAtStartPar
Распространение: после того, как пакет прошел тестирование и готов к использованию, его можно распространять, например, публикуя его на веб\sphinxhyphen{}сайте или дистрибутиве Linux.

\end{itemize}

\sphinxAtStartPar
Сборка в пакет может быть автоматизирована с помощью специальных инструментов, таких как системы управления пакетами, которые могут упростить процесс создания, тестирования и распространения пакетов. \sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{Этот курс собирался с помощью Sphinx и небольшого скрипта на Python, который формировал правильный порядок файлов в index.rst. После этого было достаточно написать \sphinxcode{\sphinxupquote{make latexpdf}} и получить весь курс в виде PDF\sphinxhyphen{}файла.}

\sphinxAtStartPar
Преимущества использования пакетов включают упрощение установки и обновления программного обеспечения, сокращение времени и усилий, необходимых для настройки новой системы, а также более простую и надежную процедуру развертывания программного обеспечения на серверах.


\subsection{Контейнеризация}
\label{\detokenize{educational_materials/stages/content:id21}}
\sphinxAtStartPar
Запрос:
\begin{quote}

\sphinxAtStartPar
Расскажи подробнее про сборку в контейнеризацию.
\end{quote}


\subsubsection{От машины:}
\label{\detokenize{educational_materials/stages/content:id22}}
\sphinxAtStartPar
\sphinxstylestrong{Контейнеризация} — это процесс создания, управления и развертывания приложений в изолированных контейнерах, которые содержат все необходимые для работы приложения компоненты: код, библиотеки, настройки, зависимости и т.д.
\sphinxstyleemphasis{\sphinxstylestrong{Комментарий}}: \sphinxstyleemphasis{Больше похоже на запуск и использование, но нам показалось важным включить этот пункт именно в инструменты разработчика, так как это позволяет решать проблемы с окружением на компьютерах пользователей, а также легче тестировать проект. В системах, состоящих из нескольких взаимодействующих по сети узлов, контейнеры являются очень удобной альтернативой виртуальным машинам.}

\sphinxAtStartPar
Основная идея контейнеризации состоит в том, чтобы создать изолированную среду для приложения, которая не будет зависеть от других приложений или операционной системы, установленной на сервере. Каждый контейнер имеет свои ресурсы, такие как процессы, сетевые интерфейсы, файловые системы и т.д., которые не будут использоваться другими контейнерами. Контейнеры могут быть созданы с использованием различных инструментов, таких как Docker, Kubernetes, LXC и другие. Процесс контейнеризации включает следующие шаги:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Создание образа контейнера: экземпляр контейнера создается на основе образа, который содержит все необходимые компоненты приложения.

\item {} 
\sphinxAtStartPar
Конфигурирование контейнера: после того, как образ создан, необходимо настроить контейнер, например, задать настройки сети, задать переменные окружения и т.д.

\item {} 
\sphinxAtStartPar
Запуск контейнера: после того, как контейнер настроен, он может быть запущен.

\item {} 
\sphinxAtStartPar
Управление контейнерами: после запуска контейнерами можно управлять, например, остановливать и перезапускать.

\end{itemize}

\sphinxAtStartPar
Преимущества контейнеризации:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Улучшенная мобильность и портативность приложений: приложения могут быть легко перенесены между различными хостами, операционными системами и облачными платформами.

\item {} 
\sphinxAtStartPar
Более быстрый и простой процесс развертывания и обновления приложений: развертывание новой версии приложения может быть выполнено всего за несколько минут.

\item {} 
\sphinxAtStartPar
Упрощение управления приложениями: контейнерами можно быстро и легко управлять и мониторить их, а приложения, построенные на основе контейнеров, легко масштабировать, запуская новые экземпляры контейнера.

\item {} 
\sphinxAtStartPar
Уменьшение зависимостей между приложениями: каждый контейнер работает в изолированной среде, что позволяет избежать конфликтов между зависимостями приложений и упрощает управление версиями.

\end{itemize}


\chapter{Минимально полезный продукт}
\label{\detokenize{index:id9}}
\sphinxstepscope


\section{Работа над MVP}
\label{\detokenize{educational_materials/mvp/content:mvp}}\label{\detokenize{educational_materials/mvp/content::doc}}

\subsection{Этапы разработки и проверка гипотез}
\label{\detokenize{educational_materials/mvp/content:id1}}
\sphinxAtStartPar
Знакомим с идеей MVP и Pet\sphinxhyphen{}project. Проект выполняется на языке Python и должен соответствовать всем критериям и рекомендациям, представленным в предыдущих пунктах. Каждое соответствие и наличие выполненного пункта оценивается в +1 балл (если были замечания к реализации — 0,5 балла).


\subsubsection{Что такое MVP и из каких этапов он состоит?}
\label{\detokenize{educational_materials/mvp/content:id2}}
\sphinxAtStartPar
MVP (минимально жизнеспособный продукт) — это концепция разработки продукта, которая относится к прототипу или версии продукта с количеством функций, достаточным, чтобы иметь возможность протестировать идею продукта с реальными пользователями.


\subsubsection{Какова цель MVP?}
\label{\detokenize{educational_materials/mvp/content:id3}}
\sphinxAtStartPar
Цель MVP — протестировать и подтвердить идею продукта на небольшой репрезентативной выборке целевого рынка, прежде чем выделять значительные ресурсы на полномасштабную разработку. MVP предназначен для предоставления информации и отзывов о ценностном предложении продукта, его удобстве использования и его потенциале для успеха.

\sphinxAtStartPar
Запуская MVP, создатели продукта могут глубже понять свой рынок, потребности и болевые точки своих клиентов, а также жизнеспособность концепции своего продукта. Это помогает им принимать обоснованные решения о том, какие функции включить в конечный продукт, как позиционировать его на рынке и как наилучшим образом привлечь и обслужить своих целевых клиентов.

\sphinxAtStartPar
По сути, MVP — это малорискованный и недорогой способ тестирования идеи продукта, сбора отзывов и доработки продукта перед его запуском в более крупном масштабе. Таким образом, это может помочь предпринимателям и продуктовым командам повысить шансы на успех своего продукта.


\subsubsection{MVP обычно состоит из следующих этапов:}
\label{\detokenize{educational_materials/mvp/content:id4}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Идея: этот этап включает в себя создание и оценку идей для продукта.

\item {} 
\sphinxAtStartPar
Исследование: этот этап включает в себя исследование целевого рынка, конкуренции и отрасли в целом, чтобы определить наилучшую концепцию продукта.

\item {} 
\sphinxAtStartPar
Проектирование: этот этап включает в себя создание базового дизайна для MVP с упором на его основные функции и взаимодействие с пользователем.

\item {} 
\sphinxAtStartPar
Разработка: этот этап включает в себя процесс создания MVP, для которого обычно требуется кодирование и тестирование, чтобы убедиться, что он работает должным образом.

\item {} 
\sphinxAtStartPar
Релиз: этот этап включает в себя выпуск MVP для выбранной группы пользователей для тестирования и получения отзывов.

\item {} 
\sphinxAtStartPar
Рефлексия и тестирование: этот этап включает в себя учет отзывов пользователей в продукте и повторение процесса проектирования и разработки, пока продукт не будет готов к полноценному запуску.

\end{enumerate}


\subsection{Вот пример MVP для новой службы доставки еды:}
\label{\detokenize{educational_materials/mvp/content:id5}}
\sphinxAtStartPar
Идея проекта — создать сервис для службы доставки еды людям, которые ведут активный образ жизни, часто передвигаются по городу, и у них нет времени готовить самостоятельно, но они все же хотят есть здоровую и питательную пищу.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Этап исследования: исследование показывает, что спрос на услуги по доставке здоровой пищи растет, особенно среди сотрудников среднего и крупного бизнеса. Однако большинство существующих услуг либо слишком дороги, либо предлагают ограниченный ассортимент блюд.

\item {} 
\sphinxAtStartPar
Проектирование: MVP будет включать в себя простой веб\sphinxhyphen{}сайт и мобильное приложение, которые позволят пользователям размещать заказы на полезные готовые блюда. Дизайн будет минималистичным и простым в использовании, ориентированным на обеспечение удобного процесса заказа здоровой пищи и информирование клиента о его статусе готовности.

\item {} 
\sphinxAtStartPar
Разработка: MVP будет создан с использованием комбинации готовых инструментов и пользовательского кода. Он будет включать в себя базовую систему заказов, платежный шлюз и функцию отслеживания доставки. MVP будет масштабироваться, чтобы его можно было легко расширять в будущем.

\item {} 
\sphinxAtStartPar
Релиз: MVP будет запущен на ограниченной территории, например, в небольшом городе, для избранной группы первых пользователей. Цель — протестировать продукт, собрать отзывы и подтвердить рыночный спрос.

\item {} 
\sphinxAtStartPar
Рефлексия и тестирование: на основе полученных отзывов MVP будет дорабатываться и улучшаться. Это может быть добавление дополнительных опций меню, улучшение процесса доставки или улучшение процесса заказа. Цель в том, чтобы постоянно улучшать продукт и делать его более привлекательным для более широкой аудитории, пока он не будет готов к полноценному запуску.

\end{itemize}


\subsection{Вот пример MVP для нового мобильного приложения:}
\label{\detokenize{educational_materials/mvp/content:id6}}
\sphinxAtStartPar
Идея состоит в том, чтобы создать мобильное приложение, которое помогает людям управлять своими финансами, отслеживая расходы, доходы и сбережения.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Исследование: исследование показывает, что существует растущий спрос на инструменты управления личными финансами, особенно среди молодых людей, которые только начинают управлять своими финансами. Однако большинство существующих инструментов либо слишком сложны, либо слишком ограничены.

\item {} 
\sphinxAtStartPar
Дизайн: MVP будет включать в себя простое и удобное мобильное приложение, позволяющее пользователям отслеживать свои расходы, доходы и сбережения. Приложение будет простым в использовании, с чистым и интуитивно понятным интерфейсом.

\item {} 
\sphinxAtStartPar
Разработка: MVP будет создан с использованием комбинации готовых инструментов и пользовательского кода. Он будет включать в себя такие функции, как отслеживание расходов, отслеживание доходов, составление бюджета и постановка целей сбережений. MVP будет масштабироваться, чтобы его можно было легко расширять в будущем.

\item {} 
\sphinxAtStartPar
Запуск: MVP будет запущен для избранной группы первых пользователей. Цель — протестировать продукт, собрать отзывы и подтвердить рыночный спрос.

\item {} 
\sphinxAtStartPar
Итерация: на основе полученных отзывов MVP будет дорабатываться и улучшаться. Это может включать добавление новых функций, улучшение пользовательского интерфейса или расширение возможностей финансового отслеживания и анализа.

\end{itemize}

\sphinxAtStartPar
Цель в том, чтобы постоянно улучшать продукт и делать его более привлекательным для более широкой аудитории, пока он не будет готов к полноценному запуску.


\subsubsection{Список рекомендаций, чтобы подготовить команду программистов к MVP проекту, посвященному разработке мобильного приложения для школы}
\label{\detokenize{educational_materials/mvp/content:id7}}
\sphinxAtStartPar
Чтобы подготовить команду программистов к разработке проекта MVP для школьного мобильного приложения, вы можете выполнить следующие шаги:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определите объем проекта: четко определите цели, требования и ожидания от MVP и убедитесь, что все в команде понимают, что от них ожидается.

\item {} 
\sphinxAtStartPar
Соберите правильную команду: выберите команду опытных, талантливых и целеустремленных программистов, обладающих навыками и опытом, необходимыми для создания MVP. Убедитесь, что команда разнообразна и включает в себя людей с разным опытом и взглядами.

\item {} 
\sphinxAtStartPar
Установите четкие ожидания. Четко сообщите команде сроки, бюджет и этапы проекта и убедитесь, что все согласны с ожиданиями проекта.

\item {} 
\sphinxAtStartPar
Поощряйте открытое общение: поощряйте открытое и честное общение между членами команды и следите за тем, чтобы каждый знал свои роли и обязанности.

\item {} 
\sphinxAtStartPar
Поощряйте командную работу: поощряйте культуру сотрудничества и командной работы и убедитесь, что каждый член команды чувствует, что его ценят и поддерживают.

\item {} 
\sphinxAtStartPar
Используйте правильные инструменты: предоставьте команде необходимые инструменты, технологии и ресурсы для создания MVP, такие как программное обеспечение для управления проектами, среды разработки и инструменты тестирования.

\item {} 
\sphinxAtStartPar
Предложите обучение и поддержку: предложите обучение и поддержку, чтобы помочь команде развить свои навыки и улучшить свою работу.

\item {} 
\sphinxAtStartPar
Отмечайте успехи: отмечайте успехи и вехи на пути к успеху и убедитесь, что команда чувствует, что ее труд ценят.

\end{enumerate}

\sphinxAtStartPar
Так вы можете помочь своей команде программистов более эффективно и успешно разработать проект MVP для школьного мобильного приложения.


\subsection{Как оценить качество MVP, какие показатели, критерии?}
\label{\detokenize{educational_materials/mvp/content:id8}}
\sphinxAtStartPar
Для оценки качества MVP можно использовать следующие показатели и критерии:
\begin{itemize}
\item {} 
\sphinxAtStartPar
отзывы пользователей: собирайте отзывы клиентов, которые использовали MVP, и анализируйте эти отзывы, чтобы определить области для улучшения и внести соответствующие изменения;

\item {} 
\sphinxAtStartPar
соответствие рынку: оцените, насколько хорошо MVP соответствует потребностям и предпочтениям целевого рынка, и при необходимости внесите коррективы;

\item {} 
\sphinxAtStartPar
вовлеченность пользователей: измерьте, насколько хорошо пользователи взаимодействуют с MVP, и используйте эти данные, чтобы определить области для улучшения;

\item {} 
\sphinxAtStartPar
производительность и надежность: оцените производительность и надежность MVP и определите любые технические проблемы или ошибки, которые необходимо устранить;

\item {} 
\sphinxAtStartPar
простота использования: оцените, насколько легко использовать MVP, и при необходимости внесите изменения, чтобы улучшить взаимодействие с пользователем;

\item {} 
\sphinxAtStartPar
масштабируемость: оцените масштабируемость MVP и определите любые ограничения, которые необходимо устранить;

\item {} 
\sphinxAtStartPar
привлечение и удержание пользователей: измеряйте уровень привлечения и удержания пользователей и при необходимости вносите изменения, чтобы улучшить оба показателя;

\item {} 
\sphinxAtStartPar
доход и рентабельность: оцените доход и прибыльность MVP и при необходимости внесите изменения, чтобы увеличить оба показателя.

\end{itemize}

\sphinxAtStartPar
Используя эти индикаторы и критерии, вы сможете эффективно оценить качество вашего MVP и внести улучшения, чтобы убедиться, что он соответствует потребностям вашего целевого рынка и обеспечивает отличный пользовательский опыт.


\subsubsection{Где используется MVP, в чем отличие от Pet Project?}
\label{\detokenize{educational_materials/mvp/content:mvp-pet-project}}
\sphinxAtStartPar
MVP (минимально жизнеспособный продукт) используется при разработке продукта, это термин, используемый для описания продукта с минимальным набором функций, достаточных для проверки концепции продукта и сбора отзывов клиентов.

\sphinxAtStartPar
PetProject — это личный проект, над которым человек работает для собственного удовольствия или личной выгоды, без каких\sphinxhyphen{}либо конкретных коммерческих или деловых целей.

\sphinxAtStartPar
Ключевое различие между ними заключается в том, что MVP сосредоточен на тестировании идеи продукта и сборе отзывов от клиентов, в то время как Pet\sphinxhyphen{}project ориентирован на личное удовлетворение и развитие навыков разработчика. MVP часто разрабатываются с расчетом на конкретный рынок или целевую аудиторию, а домашние проекты обычно разрабатываются по личным причинам, без учета какого\sphinxhyphen{}либо рынка или аудитории.

\sphinxAtStartPar
Таким образом, MVP используется при разработке продукта как способ проверки концепции продукта и сбора отзывов клиентов, а личный проект — это частный проект без конкретных коммерческих или бизнес\sphinxhyphen{}целей.


\subsection{Задание для проверки}
\label{\detokenize{educational_materials/mvp/content:id9}}
\sphinxAtStartPar
Выше мы познакомились с основными тезисами относительно разработки MVP. Представьте, что вам нужно разработать чат\sphinxhyphen{}бота для поиска информации о доступных олимпиадах с возможностью поиска и формирования списка избранных олимпиад. Ниже представлены шаги, которые вам следует выполнить самостоятельно:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Проведите исследование, какие чат\sphinxhyphen{}боты уже есть на рынке. Посмотрите, что они делают и как они работают, для решения каких задач их используют.

\item {} 
\sphinxAtStartPar
Разберитесь, для кого будет ваш чат\sphinxhyphen{}бот и что он будет делать. Какие задачи он будет выполнять?

\item {} 
\sphinxAtStartPar
Нарисуйте прототип того, как будет выглядеть и работать ваш чат\sphinxhyphen{}бот. Подумайте, как он будет общаться с клиентами (подписчиками).

\item {} 
\sphinxAtStartPar
Выберите примерный список технологий и инструментов, которые могут использоваться для создания чат\sphinxhyphen{}бота (библиотеки, база данных, API, сервер на котором будет развернут бот и т.д.).

\item {} 
\sphinxAtStartPar
Оцените длительность периода разработки: сколько примерно времени и ресурсов вам понадобится для создания чат\sphinxhyphen{}бота. Составьте план работы.

\item {} 
\sphinxAtStartPar
Подумайте, какие проблемы могут возникнуть в процессе разработки и как их решить.

\item {} 
\sphinxAtStartPar
Если у вас есть команда, определите, кто что будет делать и как вы будете общаться и контролировать процесс разработки. Например, можно использовать сервис Trello или его аналог, в котром можно перенести задачи на карточки и обозначить сроки и исполнителей.

\item {} 
\sphinxAtStartPar
Определите, как вы будете проверять, что чат\sphinxhyphen{}бот работает правильно. Разработайте несколько тестов, которые будут проверять работу основных сервисов (пинг API сервиса, проверка подключениия к СУБД, статус приложения/сервера).

\item {} 
\sphinxAtStartPar
Начните разрабатывать чат\sphinxhyphen{}бот, следуя плану, который вы составил ранее. Попробуйте разработать простого бота с парой функций и оцените его работу.

\item {} 
\sphinxAtStartPar
Когда чат\sphinxhyphen{}бот будет готов, проверьте, что он работает так, как задумано, и что пользователи могут им пользоваться.

\end{enumerate}

\sphinxAtStartPar
Вот и все! Таким образом, вы можете получить первый опыт разработки MVP чат\sphinxhyphen{}бота. Удачи!


\chapter{UML диаграммы}
\label{\detokenize{index:uml}}
\sphinxstepscope


\section{Факультатив. Стандартные графические схемы при разработке ПО}
\label{\detokenize{educational_materials/uml/content:id1}}\label{\detokenize{educational_materials/uml/content::doc}}

\subsection{Возможности использования UML (Unified Modeling Language)}
\label{\detokenize{educational_materials/uml/content:uml-unified-modeling-language}}
\sphinxAtStartPar
\sphinxincludegraphics{{uml_uml_logo}.png}
\begin{quote}

\sphinxAtStartPar
Рассматриваются основные схемы для визуализации процессов, которые реализует код. Основы работы с UML диаграммами (Use\sphinxhyphen{}case diagram, sequence diagram, component diagram, class diagram).
\end{quote}

\sphinxAtStartPar
На сегодняшний день разработка программного продукта предполагает использование множества различных высокоуровневых компонентов, таких как сторонние библиотеки, программные модули, фреймворки, ОС и т.д. В результате, с одной стороны, процесс разработки ускоряется за счет использования готовых компонентов, однако, с другой стороны, усложняется прозрачность такого кода. Сложнее отследить внутренние зависимости, появляются зависимости от сторонних разработчиков (модуля, фреймворка). Со временем поддерживать такой проект по ряду причин становится сложнее. Для внедрения систематизации и документирования процесса разработки продукта часто используют различные виды диаграмм в зависимости от задачи, такие как IDEF0, ER\sphinxhyphen{}модель и UML. Все это — методы моделирования, используемые для графического представления систем или процессов.
\begin{itemize}
\item {} 
\sphinxAtStartPar
IDEF0 (Integration Definition for Function Modeling) — это язык моделирования, который используется для описания функций, действий и процессов в организации. Он использует иерархический подход к моделированию системы, при этом каждый уровень представляет различный уровень детализации. IDEF0 обычно используется в правительственных и военных учреждениях для описания и формализации бизнес\sphinxhyphen{}процессов. Особенность IDEF0 заключается в том, что эта методология ориентирована на соподчиненность объектов. IDEF0 была разработана для автоматизации предприятий еще в 1981 году в США.

\item {} 
\sphinxAtStartPar
ER\sphinxhyphen{}модель (Entity\sphinxhyphen{}Relationship Model) — это метод моделирования, используемый для представления данных в базе данных. Он использует сущности (объекты) и их отношения друг к другу для описания данных. ER\sphinxhyphen{}модели обычно используются в разработке программного обеспечения для проектирования баз данных и моделей данных.

\item {} 
\sphinxAtStartPar
UML (унифицированный язык моделирования) — это язык моделирования, используемый для описания программных систем. Он включает в себя набор диаграмм, которые представляют различные аспекты программной системы, такие как варианты использования, классы, компоненты и взаимодействия. UML — это широко используемый язык моделирования в разработке программного обеспечения, который поддерживается многими инструментами и платформами.

\end{itemize}

\sphinxAtStartPar
Таким образом, IDEF0 используется для моделирования функций и процессов внутри организации, ER\sphinxhyphen{}модель используется для моделирования данных в базе данных, а UML используется для моделирования программных систем. На сегодняшний день самым универсальным инструментом проектирования является UML. Она позволяет посмотреть на разрабатываемый программный продукт с разных сторон, с позиции архитектора ПО, архитектора баз данных, программиста (бэкенд, фронтенд) и т.д.
В совокупности ознакомившись с информацией, руководитель проекта получает объективную информацию с возможностью оценить риски, этапы разработки, примерные сроки и требуемый состав команды для распределения нагрузки. Также в процессе реализации первоначальный вариант проекта может трансформироваться с учетом изменений программного продукта.


\subsection{Что такое UML?}
\label{\detokenize{educational_materials/uml/content:uml}}
\sphinxAtStartPar
\sphinxstylestrong{UML} \sphinxstyleemphasis{\sphinxstylestrong{(Unified Modeling Language)}} — унифицированный язык моделирования, который является стандартизированной графической нотацией для моделирования и представления дизайна программных систем и других сложных систем. UML помогает определять, визуализировать и документировать структуру и поведение этих систем, облегчая понимание проекта, взаимодействие с ним и его развитие с течением времени.

\sphinxAtStartPar
\sphinxstylestrong{Для каких задач используют UML? Напишите пример}

\sphinxAtStartPar
UML используется в различных задачах, связанных с разработкой программного обеспечения, таких как:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сбор и анализ требований: UML может быть использован для моделирования требований к системе и отражения взаимодействия между различными компонентами системы.

\item {} 
\sphinxAtStartPar
Проектирование и архитектура: UML может использоваться для моделирования высокоуровневой структуры системы, включая компоненты и отношения между ними, для разработки надежного и поддерживаемого дизайна.

\item {} 
\sphinxAtStartPar
Коммуникация: Диаграммы UML могут быть использованы для передачи информации о дизайне системы заинтересованным сторонам, таким как разработчики, менеджеры и клиенты.

\end{enumerate}

\sphinxAtStartPar
Пример:
Допустим, вы разрабатываете систему для интернет\sphinxhyphen{}магазина. Для моделирования требований к системе вы можете использовать диаграмму сценариев использования, чтобы отразить различные действия, которые пользователи могут выполнять в системе, например, просмотр товаров, добавление товаров в корзину и оформление заказа.

\sphinxAtStartPar
Для проектирования архитектуры системы можно использовать диаграмму классов для моделирования объектов системы, таких как продукты, клиенты и заказы, а также связей между ними. Вы также можете использовать диаграмму последовательности для описания взаимодействия между объектами, когда клиент размещает заказ.

\sphinxAtStartPar
Эти UML\sphinxhyphen{}диаграммы могут быть использованы для передачи проекта системы заинтересованным сторонам, что облегчит понимание структуры и поведения системы.


\subsubsection{Как UML помогает в работе над проектами? Кто их разрабатывает?}
\label{\detokenize{educational_materials/uml/content:id2}}
\sphinxAtStartPar
UML помогает в работе над проектами несколькими способами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
улучшение коммуникации: UML обеспечивает общий визуальный язык для всех заинтересованных сторон, участвующих в проекте, облегчая передачу сложных концепций проектирования и понимание разрабатываемой системы;

\item {} 
\sphinxAtStartPar
облегчение проектирования: UML предоставляет набор графических элементов, которые могут быть использованы для моделирования структуры и поведения системы, помогая проектировщикам исследовать различные варианты дизайна и принимать обоснованные решения о дизайне;

\item {} 
\sphinxAtStartPar
захват требований: UML предоставляет диаграммы, специально разработанные для фиксации требований, такие как диаграммы вариантов использования, которые нужны для моделирования взаимодействия между системой и ее пользователями;

\item {} 
\sphinxAtStartPar
улучшение совместной работы: UML облегчает совместную работу команд над проектом, предоставляя визуальное представление разрабатываемой системы, которым можно легко делиться и обсуждать его.

\end{itemize}

\sphinxAtStartPar
Разработчики, архитекторы, дизайнеры и бизнес\sphinxhyphen{}аналитики являются одними из заинтересованных сторон, которые могут использовать UML в проекте. Однако он не ограничивается конкретной ролью или группой людей, и любой человек, участвующий в разработке программной системы, может использовать UML для моделирования и передачи проекта системы.


\subsection{Каковы основные типы диаграмм в UML?}
\label{\detokenize{educational_materials/uml/content:id3}}
\sphinxAtStartPar
\sphinxincludegraphics{{uml_typical_type_diagrams}.png}

\sphinxAtStartPar
\sphinxstylestrong{UML} (\sphinxstyleemphasis{унифицированный язык моделирования}) имеет несколько типов диаграмм, которые используются для моделирования различных аспектов системы. Вот основные типы диаграмм в \sphinxstylestrong{UML}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма классов (Class Diagram)}: Диаграмма классов моделирует статическую структуру системы, включая классы, интерфейсы, объекты и их отношения.
\sphinxincludegraphics{{uml_sample_class_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма объектов (Object Diagram).} Диаграмма объектов похожа на диаграмму классов, но она моделирует экземпляры классов, а не сами классы.
\sphinxincludegraphics{{uml_sample_object_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма прецидентов (Use Case Diagram):} Диаграмма вариантов использования моделирует взаимодействие между субъектами и системой, а также поток событий в конкретном сценарии или варианте использования.
\sphinxincludegraphics{{uml_use_case_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма последовательности (Sequence Diagram)}: Диаграмма последовательности моделирует взаимодействия между объектами или компонентами в системе и порядок, в котором эти взаимодействия происходят.
\sphinxincludegraphics{{uml_sequence_diagram}.png}
\sphinxincludegraphics{{uml_sequence_diagram_2}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма конечного автомата (State Machine Diagram)}: Диаграмма конечного автомата моделирует поведение объекта или системы, включая переходы между состояниями и действия, которые происходят в каждом состоянии.
\sphinxincludegraphics{{uml_state_machine_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма действий (Activity Diagram)}: Диаграмма действий — это диаграмма поведения, которая показывает поток действий в системе и то, как они связаны друг с другом.
\sphinxincludegraphics{{uml_activity_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма компонентов (Component Diagram)}: Диаграмма компонентов моделирует статическую структуру системы, включая компоненты и отношения между ними.
\sphinxincludegraphics{{uml_component_diagram}.png}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Диаграмма развертывания (Deployment Diagram)}: Диаграмма развертывания моделирует физическое развертывание компонентов в системе, включая аппаратные и программные элементы и отношения между ними.
\sphinxincludegraphics{{uml_deployment_diagram}.png}

\end{enumerate}

\sphinxAtStartPar
Это основные типы диаграмм в UML. В зависимости от сложности моделируемой системы могут потребоваться дополнительные диаграммы для полного представления системы.

\sphinxAtStartPar
Рассмотрим пример — диаграмму последовательности (\sphinxstyleemphasis{\sphinxstylestrong{Sequence Diagram}}).
Диаграмма последовательности \sphinxstylestrong{UML} — это тип диаграммы взаимодействия, который показывает взаимодействие между объектами или компонентами в системе и порядок, в котором эти взаимодействия происходят. Диаграмма последовательности может использоваться для моделирования потока сообщений между объектами в сценарии использования.

\sphinxAtStartPar
Вот пример диаграммы последовательности для описания процесса «Загрузка мобильного приложения» с использованием маркетплейса (store) мобильных приложений:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Browse\PYGZus{}Apps}\PYG{p}{:} \PYG{n}{initiate}
\PYG{n}{Browse\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Apps\PYGZus{}Market}\PYG{p}{:} \PYG{n}{request} \PYG{n}{app} \PYG{n+nb}{list}
\PYG{n}{Apps\PYGZus{}Market}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Browse\PYGZus{}Apps}\PYG{p}{:} \PYG{k}{return} \PYG{n}{app} \PYG{n+nb}{list}
\PYG{n}{Browse\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{User}\PYG{p}{:} \PYG{n}{display} \PYG{n}{app} \PYG{n+nb}{list}
\PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Browse\PYGZus{}Apps}\PYG{p}{:} \PYG{n}{select} \PYG{n}{app}
\PYG{n}{Browse\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Search\PYGZus{}Apps}\PYG{p}{:} \PYG{n}{forward} \PYG{n}{app} \PYG{n}{selection}
\PYG{n}{Search\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Apps\PYGZus{}Market}\PYG{p}{:} \PYG{n}{request} \PYG{n}{app} \PYG{n}{information}
\PYG{n}{Apps\PYGZus{}Market}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Search\PYGZus{}Apps}\PYG{p}{:} \PYG{k}{return} \PYG{n}{app} \PYG{n}{information}
\PYG{n}{Search\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{User}\PYG{p}{:} \PYG{n}{display} \PYG{n}{app} \PYG{n}{information}
\PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Search\PYGZus{}Apps}\PYG{p}{:} \PYG{n}{initiate} \PYG{n}{download}
\PYG{n}{Search\PYGZus{}Apps}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Download\PYGZus{}App}\PYG{p}{:} \PYG{n}{download} \PYG{n}{request}
\PYG{n}{Download\PYGZus{}App}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Apps\PYGZus{}Market}\PYG{p}{:} \PYG{n}{request} \PYG{n}{app} \PYG{n}{download}
\PYG{n}{Apps\PYGZus{}Market}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Download\PYGZus{}App}\PYG{p}{:} \PYG{k}{return} \PYG{n}{app} \PYG{n}{download}
\PYG{n}{Download\PYGZus{}App}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{User}\PYG{p}{:} \PYG{n}{deliver\PYGZus{}app}
\PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Application}\PYG{p}{:} \PYG{n}{install\PYGZus{}app}
\end{sphinxVerbatim}

\sphinxAtStartPar
В этом примере пользователь (\sphinxstyleemphasis{\sphinxstylestrong{User}}) инициирует процесс загрузки, просматривая доступные приложения и выбирая приложение для загрузки. Вариант использования \sphinxstyleemphasis{\sphinxstylestrong{Browse Apps}} связывается с \sphinxstyleemphasis{\sphinxstylestrong{Apps Market}} для запроса списка доступных приложений и возвращает список пользователю. Затем пользователь выбирает приложение, и прикладная программа \sphinxstyleemphasis{\sphinxstylestrong{Browse Apps}} передает выбор прикладной программе \sphinxstyleemphasis{\sphinxstylestrong{Search Apps}}. Вариант использования \sphinxstyleemphasis{\sphinxstylestrong{Search Apps}} запрашивает информацию о выбранном приложении из \sphinxstyleemphasis{\sphinxstylestrong{Apps Market}} и возвращает ее пользователю. Затем пользователь инициирует загрузку приложения, и сценарий \sphinxstyleemphasis{\sphinxstylestrong{Search Apps}} передает запрос на загрузку сценарию \sphinxstyleemphasis{\sphinxstylestrong{Download App}}. Вариант использования \sphinxstyleemphasis{\sphinxstylestrong{Download App}} взаимодействует с \sphinxstyleemphasis{\sphinxstylestrong{Apps Market}} для запроса загрузки приложения и возвращает приложение пользователю. Пользователь устанавливает приложение на свое устройство.

\sphinxAtStartPar
Обратите внимание, что это лишь одно из возможных представлений сценария использования «Загрузить приложение» (\sphinxstyleemphasis{\sphinxstylestrong{Download App}}), и фактическая диаграмма последовательности может отличаться в зависимости от конкретных требований и ограничений проектируемой системы.


\subsubsection{В каких случаях использование UML избыточно и можно обойтись без него?}
\label{\detokenize{educational_materials/uml/content:id4}}
\sphinxAtStartPar
Использование UML может быть излишним в следующих случаях:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Простые системы. Для небольших и простых систем диаграммы UML могут быть излишними и пустой тратой времени. В этих случаях систему можно описать несколькими строками текста или кода, а диаграммы UML могут не иметь никакой ценности.

\item {} 
\sphinxAtStartPar
Знакомая область: если группа разработчиков знакома с областью разрабатываемой системы, им не нужны диаграммы UML для понимания требований и дизайна системы.

\item {} 
\sphinxAtStartPar
Быстрое прототипирование: при разработке быстрого прототипа основное внимание обычно уделяется максимально быстрому созданию работающей модели. В этих случаях диаграммы UML могут замедлить процесс разработки, и лучше их пропустить.

\item {} 
\sphinxAtStartPar
Гибкая разработка: методологии гибкой разработки ценят рабочий код выше документации, и диаграммы UML не могут считаться приоритетом в этой среде.

\item {} 
\sphinxAtStartPar
Как правило, использование UML является излишним, когда команду разработчиков устраивают требования и дизайн системы и когда основное внимание уделяется быстрой доставке работающего решения. Однако для более крупных и сложных систем UML\sphinxhyphen{}диаграммы могут обеспечить визуальное представление системы и помочь гарантировать, что все заинтересованные стороны имеют четкое представление о требованиях и дизайне.

\end{enumerate}


\subsubsection{В чем разница между описанием программы в виде блок\sphinxhyphen{}схемы и описанием программы с использованием диаграммы UML?}
\label{\detokenize{educational_materials/uml/content:id5}}
\sphinxAtStartPar
Блок\sphinxhyphen{}схема и диаграмма UML — это инструменты, используемые для описания логики и структуры программы, но они имеют некоторые отличия:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Назначение: Блок\sphinxhyphen{}схема в основном используется для представления потока управления в программе и для описания шагов, которые выполняются в определенном порядке. UML, с другой стороны, представляет собой язык моделирования, который можно использовать для описания различных аспектов системы, включая статическую структуру, динамическое поведение и взаимодействие между объектами или компонентами;

\item {} 
\sphinxAtStartPar
Уровень детализации: блок\sphinxhyphen{}схема дает общее представление о программе и ее структуре, но может не отражать всех подробностей, необходимых для полного понимания программы. Диаграммы UML, с другой стороны, могут обеспечить более подробное представление системы, включая отношения между объектами и потоком событий в конкретном сценарии;

\item {} 
\sphinxAtStartPar
Целевая аудитория. Блок\sphinxhyphen{}схемы, как правило, легче понять не техническим специалистам, тогда как UML\sphinxhyphen{}диаграммы в основном используют разработчики, архитекторы систем и дизайнеры UI/UX;

\item {} 
\sphinxAtStartPar
Представление: блок\sphinxhyphen{}схемы представляют логику и структуру программы с помощью символов и фигур, соединенных стрелками. Диаграммы UML используют комбинацию различных типов диаграмм, каждая из которых представляет отдельный аспект моделируемой системы.

\end{itemize}

\sphinxAtStartPar
Таким образом, блок\sphinxhyphen{}схемы — это простой и интуитивно понятный способ представления потока управления в программе, в то время как диаграммы UML обеспечивают более полное представление системы и могут использоваться для описания различных аспектов системы. Выбор между блок\sphinxhyphen{}схемой и диаграммой UML зависит от сложности программы, требуемого уровня детализации и аудитории для описания программы.


\subsubsection{Преимущества и недостатки UML}
\label{\detokenize{educational_materials/uml/content:id6}}

\paragraph{Преимущества UML}
\label{\detokenize{educational_materials/uml/content:id7}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Стандартизация: UML — это стандартизированный язык моделирования, что означает, что все заинтересованные стороны могут эффективно общаться, используя общий язык. Это помогает уменьшить недопонимание и улучшает качество дизайна.

\item {} 
\sphinxAtStartPar
Визуализация: диаграммы UML обеспечивают визуальное представление системы, которое может быть легче понять, чем письменное описание. Это помогает заинтересованным сторонам лучше понять требования и структуру системы.

\item {} 
\sphinxAtStartPar
Улучшенная коммуникация: диаграммы UML могут помочь улучшить коммуникацию между разработчиками, дизайнерами, менеджерами и другими заинтересованными сторонами, обеспечивая общее понимание системы.

\item {} 
\sphinxAtStartPar
Раннее выявление проблем. Диаграммы UML могут помочь выявить проблемы в требованиях и дизайне системы на ранней стадии, что сэкономит время и ресурсы в долгосрочной перспективе.

\item {} 
\sphinxAtStartPar
Улучшенная документация: UML\sphinxhyphen{}диаграммы обеспечивают всестороннее представление системы, которое может служить источником документации для дальнейшего использования.

\end{enumerate}


\paragraph{Недостатки UML}
\label{\detokenize{educational_materials/uml/content:id8}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сложность: Для неопытного разработчика UML — сложный язык, и разработчикам, которые только начинают им пользоваться, может быть весьма сложно его изучить за короткое время.

\item {} 
\sphinxAtStartPar
Длительный жизненный цикл: Разработка диаграмм UML может занимать длительное время, что увеличит продолжительность разработки и затраты на проработку проекта. Перед разработкой моделей необходимо собрать большой объем информации, содержащей подробные данные о разрабатываемом продукте. Для многих проектов разработка полного пакета UML\sphinxhyphen{}диаграмм является избыточной. В случае масштабирования продукта, расширения функционала и увеличения количества используемых компонентов можно преобразовать имеющуюся техническую документацию в UML.

\item {} 
\sphinxAtStartPar
Ограниченная возможность повторного использования: диаграммы UML нельзя использовать повторно для разработки новых продуктов без внесения изменений, поскольку может потребоваться обновлять и изменять их по мере развития требований и дизайна системы.

\item {} 
\sphinxAtStartPar
Незнакомость: UML может быть малоизвестным, широко использоваться только в некоторых отраслях, что затруднит понимание или эффективное использование диаграмм заинтересованными сторонами.

\item {} 
\sphinxAtStartPar
Ограниченная функциональность: UML — это, прежде всего, язык моделирования. Он не предоставляет прямого способа генерации кода. Это означает, что диаграммы UML могут не подходить для некоторых типов систем, таких как очень сложные системы или системы реального времени.

\end{enumerate}

\sphinxAtStartPar
Итак, UML имеет как преимущества, так и недостатки, и решение об использовании UML должно основываться на конкретных потребностях проекта и целях группы разработчиков. UML может быть ценным инструментом для улучшения коммуникации и документации, но он может не подходить для всех проектов из\sphinxhyphen{}за его сложности и дополнительных расходов.


\subsubsection{Этапы разработки UML\sphinxhyphen{}диаграмм для чат\sphinxhyphen{}бота}
\label{\detokenize{educational_materials/uml/content:id9}}
\sphinxAtStartPar
Рассмотрим небольшой пример разработки UML\sphinxhyphen{}диаграмм для чат\sphinxhyphen{}бота. Например, нужно разработать чат\sphinxhyphen{}бота, который будет информировать о разных событиях и отвечать на вопросы клиентов. Перед тем, как приступить к разработке UML\sphinxhyphen{}диаграмм, следует выполнить следующее:


\paragraph{1. Определить требования}
\label{\detokenize{educational_materials/uml/content:id10}}
\sphinxAtStartPar
Начните с определения основных требований к чат\sphinxhyphen{}боту. Это включает функциональные и нефункциональные требования, например, какие функции бота должны поддерживаться, на каких платформах он будет работать, какая должна быть его производительность и т.д.
Пример содержания определения требований для чат\sphinxhyphen{}бота:

\sphinxAtStartPar
1.1 Функциональные требования:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен иметь возможность приветствовать пользователей и предлагать помощь.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен уметь отвечать на вопросы пользователей и предоставлять информацию по различным темам.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен поддерживать возможность регистрации и авторизации пользователей.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен предоставлять информацию о различных мероприятиях, новостях и акциях.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен уметь предлагать пользователю различные варианты ответов на вопросы и действий.

\end{itemize}

\sphinxAtStartPar
1.2 Нефункциональные требования:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен быть доступен на платформах Telegram и VK.

\item {} 
\sphinxAtStartPar
Время ответа чат\sphinxhyphen{}бота на сообщения пользователя не должно превышать 5 секунд.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен обладать высокой производительностью, чтобы обслуживать большое количество пользователей одновременно.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен быть простым в использовании и иметь интуитивно понятный интерфейс.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот должен обеспечивать безопасное хранение и обработку пользовательских данных.

\end{itemize}

\sphinxAtStartPar
1.3 Ограничения и допущения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот будет разрабатываться на языке программирования Python.

\item {} 
\sphinxAtStartPar
Чат\sphinxhyphen{}бот будет использовать базу данных для хранения информации о пользователях и мероприятиях.

\item {} 
\sphinxAtStartPar
При разработке чат\sphinxhyphen{}бота будет использоваться библиотека для работы с API платформ Telegram и Facebook Messenger.

\end{itemize}

\sphinxAtStartPar
1.4 Запланированные улучшения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
В будущем планируется добавить функционал платежей и возможность заказа товаров через чат\sphinxhyphen{}бота.

\item {} 
\sphinxAtStartPar
Предполагается улучшить алгоритмы обработки естественного языка для более точного и информативного ответа на вопросы пользователей.

\item {} 
\sphinxAtStartPar
В дальнейшем можно добавить функцию уведомлений для пользователей о предстоящих событиях и акциях.

\end{itemize}

\sphinxAtStartPar
Это всего лишь пример, и фактические требования могут сильно различаться в зависимости от конкретного проекта чат\sphinxhyphen{}бота. Важно учитывать потребности и ожидания целевой аудитории, а также технические возможности и ограничения разработки.


\paragraph{2. Изучить существующие решения}
\label{\detokenize{educational_materials/uml/content:id11}}
\sphinxAtStartPar
Проведите исследование рынка и познакомьтесь с существующими чат\sphinxhyphen{}ботами, которые решают похожую задачу, близкую к той, которую вы решаете. Посмотрите, как устроен интерфейс пользователя, какие есть варианты меню, как бот реагирует в случае отсутствия у него ответа и в каком виде выдает результат (текст, картинка, таблица, список). Попробуйте составить сценарий работы бота\sphinxhyphen{}аналога, чтобы учесть возможные ошибки и реакции поведения в различных ситуациях при общении с пользователем. Это поможет вам понять, какие функции можно включить в бот и какие дизайн\sphinxhyphen{}паттерны и архитектуры можно применить.
2.1 Исследование рынка чат\sphinxhyphen{}ботов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Проведите анализ популярных чат\sphinxhyphen{}ботов на рынке, работающих в схожей сфере или предоставляющих аналогичные услуги.

\item {} 
\sphinxAtStartPar
Изучите их функциональность, возможности и особенности взаимодействия с пользователем.

\item {} 
\sphinxAtStartPar
Оцените отзывы и оценки пользователей для выявления сильных и слабых сторон существующих решений.

\end{itemize}

\sphinxAtStartPar
2.2 Ознакомление с дизайн\sphinxhyphen{}паттернами и архитектурами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Изучите различные дизайн\sphinxhyphen{}паттерны, используемые в разработке чат\sphinxhyphen{}ботов, такие как State Pattern, Command Pattern и другие.

\item {} 
\sphinxAtStartPar
Познакомьтесь с архитектурными подходами для разработки чат\sphinxhyphen{}ботов, включая Model\sphinxhyphen{}View\sphinxhyphen{}Controller (MVC), Event\sphinxhyphen{}Driven и другие.

\item {} 
\sphinxAtStartPar
Рассмотрите преимущества и недостатки каждого подхода и выберите наиболее подходящие для вашего проекта.

\end{itemize}

\sphinxAtStartPar
2.3 Определение возможностей для улучшения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Изучите сильные стороны существующих чат\sphinxhyphen{}ботов и определите, какие из них можно использовать в своем проекте.

\item {} 
\sphinxAtStartPar
Выявите слабые стороны и ошибки в существующих решениях, чтобы избежать их повторения в вашем чат\sphinxhyphen{}боте.

\item {} 
\sphinxAtStartPar
Определите функции и особенности, которые вы хотите добавить в свой бот для улучшения пользовательского опыта.

\end{itemize}

\sphinxAtStartPar
2.4 Применение лучших практик:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Воспользуйтесь полученными знаниями и опытом, чтобы разработать оптимальную функциональность и архитектуру для своего чат\sphinxhyphen{}бота.

\item {} 
\sphinxAtStartPar
Учтите успешные решения, которые были применены в существующих чат\sphinxhyphen{}ботах, и внедрите их в свой проект.

\item {} 
\sphinxAtStartPar
Не ограничивайтесь прямым копированием, а адаптируйте лучшие практики к специфике вашего проекта.

\end{itemize}

\sphinxAtStartPar
Изучение существующих решений позволит вам получить ценную информацию о том, как создать успешный и функциональный чат\sphinxhyphen{}бот, а также избежать распространенных ошибок и проблем, которые могут возникнуть в процессе разработки. Это поможет вам создать чат\sphinxhyphen{}бот, который будет эффективно выполнять свои функции и удовлетворять потребности пользователей.


\paragraph{3. Определить архитектуру}
\label{\detokenize{educational_materials/uml/content:id12}}
\sphinxAtStartPar
На основе требований и изучения существующих решений определите архитектуру вашего чат\sphinxhyphen{}бота. Решите, какие компоненты и функциональности будут включены в бота, как они будут взаимодействовать между собой и с внешними системами. Например, вам может потребоваться взаимодействие с внешними сервисами посредством API (Application Program Interface), для получения и обработки информации в процессе формирования ответа пользователю. Разрабатывая первый прототип (MVP/Pet project) чат\sphinxhyphen{}бота, рекомендуется использовать язык программирования Python. Он прост в изучении и обладает широким набором библиотек, в том числе для разработки чат\sphinxhyphen{}ботов. Вот несколько популярных библиотек:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/python-telegram-bot/python-telegram-bot}{python\sphinxhyphen{}telegram\sphinxhyphen{}bot}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/eternnoir/pyTelegramBotAPI}{pyTelegramBotAPI}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/aiogram/aiogram}{AIOGram}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/KeralaBots/TGramBot}{TGramBot}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/cmd410/OrigamiBot}{OrigamiBot}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/luckydonald/pytgbot}{pytgbot}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/luckydonald/teleflask}{teleflask}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SKY-ALIN/telegram-text}{telegram\sphinxhyphen{}text}

\end{itemize}

\sphinxAtStartPar
В качестве источника данных можно выбрать бесплатный API сервис \sphinxhref{https://rapidapi.com/collection/list-of-free-apis}{RapidAPI}.
\sphinxincludegraphics{{uml_rapid_api_service}.png}

\sphinxAtStartPar
RapidAPI содержит множество открытых источников данных, что пригодится в разработке чат\sphinxhyphen{}бота для большинства направлений.\\
RapidAPI — это онлайн\sphinxhyphen{}платформа, которая предоставляет доступ к тысячам бесплатных и платных API (интерфейсов программирования приложений) от различных провайдеров. API — это набор программных инструкций и методов, которые позволяют различным приложениям и сервисам обмениваться данными и функциональностью между собой.


\paragraph{Порядок действий для использования API сервиса RapidAPI}
\label{\detokenize{educational_materials/uml/content:api-rapidapi}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Регистрация: Для использования RapidAPI необходимо зарегистрироваться на платформе. Регистрация бесплатна и занимает всего несколько минут.

\item {} 
\sphinxAtStartPar
Поиск API: После регистрации можно начать поиск нужных API. RapidAPI предоставляет обширный каталог бесплатных API по различным категориям, таким как социальные сети, погода, геолокация, машинное обучение, финансы и многое другое.

\item {} 
\sphinxAtStartPar
Просмотр информации о API: При выборе интересующего API можно ознакомиться с его документацией, функциональностью, ограничениями и примерами использования.

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{uml_sample_api_service}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Получение ключа API: Для использования большинства API необходимо получить API\sphinxhyphen{}ключ. Обычно это бесплатный процесс, который требует регистрации на сайте провайдера API. Ключ используется для аутентификации и предотвращения злоупотребления.

\item {} 
\sphinxAtStartPar
Подключение к API: После получения ключа API можно подключиться к выбранному API через RapidAPI. Платформа предоставляет простой и удобный интерфейс для вызова методов API и обработки результатов.

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{uml_sample_code_api_service}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
Ограничения и лимиты: Важно обратить внимание на ограничения и лимиты использования бесплатных API. Некоторые API могут иметь ограничения на количество запросов в день или на определенный период времени.

\item {} 
\sphinxAtStartPar
Обработка результатов: После получения ответов от API можно обрабатывать и использовать данные в своих приложениях или проектах.

\item {} 
\sphinxAtStartPar
Мониторинг использования: Некоторые API предоставляют возможность мониторинга использования и статистики запросов для лучшего контроля над вашими приложениями.

\end{enumerate}

\sphinxAtStartPar
Помните, что при использовании бесплатных API также могут применяться ограничения по скорости запросов и доступности, поэтому перед использованием API в коммерческих проектах или с большим объемом запросов рекомендуется ознакомиться с платными вариантами и условиями использования. RapidAPI предоставляет удобный способ объединить доступ к различным API и сделать процесс интеграции в ваши проекты более простым и эффективным.

\sphinxAtStartPar
3.1 Определение основных компонентов чат\sphinxhyphen{}бота:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Идентифицируйте основные компоненты, необходимые для функционирования чат\sphinxhyphen{}бота. Например, интерфейс пользователя, обработчик сообщений, база данных и т.д.

\item {} 
\sphinxAtStartPar
Определите роли и функции каждого компонента в архитектуре бота.

\end{itemize}

\sphinxAtStartPar
3.2 Разработка схемы взаимодействия компонентов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите взаимодействие между компонентами чат\sphinxhyphen{}бота. Например, как пользовательские запросы будут передаваться обработчику сообщений, какие данные будут храниться в базе данных и т.д.

\item {} 
\sphinxAtStartPar
Рассмотрите возможные сценарии взаимодействия и определите наилучшие подходы для обеспечения эффективной работы бота.

\end{itemize}

\sphinxAtStartPar
3.3 Интеграция с внешними системами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Решите, какие внешние системы будут интегрированы с чат\sphinxhyphen{}ботом. Например, для получения новостей, данных о результатах олимпиады или рейтинга игры «Берлога».

\item {} 
\sphinxAtStartPar
Определите протоколы и форматы данных для обмена информацией между ботом и внешними системами.

\end{itemize}

\sphinxAtStartPar
3.4 Обработка ошибок и исключительных ситуаций:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разработайте механизмы обработки ошибок и исключительных ситуаций. Например, как бот будет реагировать на неправильные запросы или ошибки при обращении к внешним системам.

\item {} 
\sphinxAtStartPar
Предусмотрите механизмы логирования и отслеживания ошибок для облегчения отладки и улучшения производительности бота.

\end{itemize}

\sphinxAtStartPar
3.5 Выбор технологий и инструментов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите наиболее подходящие технологии и инструменты для реализации каждого компонента чат\sphinxhyphen{}бота. Например, выберите язык программирования, фреймворк для работы с базой данных и т.д.

\item {} 
\sphinxAtStartPar
Обратите внимание на производительность, масштабируемость и удобство использования выбранных технологий.

\end{itemize}

\sphinxAtStartPar
Определение архитектуры чат\sphinxhyphen{}бота позволит вам сформировать четкий план разработки и обеспечит эффективное взаимодействие компонентов, что обеспечит успешную реализацию задачи разработки чат\sphinxhyphen{}бота и его функционирование в соответствии с поставленными требованиями.


\paragraph{4. Разработать диаграмму прецедентов}
\label{\detokenize{educational_materials/uml/content:id13}}
\sphinxAtStartPar
Создайте диаграмму прецедентов, которая описывает функциональность бота и его взаимодействие с пользователями. Определите основные сценарии использования бота и взаимодействия с ним.

\sphinxAtStartPar
4.1 Определение «актеров»:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите актеров, которые будут взаимодействовать с чат\sphinxhyphen{}ботом. Например, «пользователь\sphinxhyphen{}клиент», «разработчик» и «тестировщик». Каждому актеру свойственнен определенный (уникальный) набор прецедентов (действий). Например, чаще всего у бота есть администратор и пользователь (клиент). Администратор управляет контентом (загрузка постов, управление рассылкой, обработка запросов рекламодателей и пользователей). С другой стороны, к прецедентам клиента могут относиться следующие действия: подписаться на бота, отправить сообщение боту, выбрать интересующие темы контента с помощью фильтра в главном меню бота и т.д.

\item {} 
\sphinxAtStartPar
Уточните роли каждого актера и их взаимодействие с ботом. Важно знать что несколько «актеров» могут выполнять один прецедент. Например, и администратор и клиент могут отправлять сообщения боту, выбирать действия в пунктах меню и получать информацию от бота. Однако должен быть минимум один прецедент, который будет уникальным у каждого актера. Так, например, клиент не может управлять контентом, в то время как администратор может.

\end{itemize}

\sphinxAtStartPar
4.2 Идентификация прецедентов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Идентифицируйте основные функциональности чат\sphinxhyphen{}бота, которые будут доступны для каждого актера.

\item {} 
\sphinxAtStartPar
Определите прецеденты как действия или задачи, которые могут быть выполнены взаимодействием с ботом. Например, «Получить информацию о новостях», «Получить результаты олимпиады», «Получить рейтинг игры „Берлога“» и т.д.

\end{itemize}

\sphinxAtStartPar
4.3 Описание сценариев использования:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Проведите анализ сценариев использования для каждого прецедента. Например, опишите шаги, которые пользователь\sphinxhyphen{}клиент будет выполнять для получения информации от бота.

\item {} 
\sphinxAtStartPar
Определите возможные варианты взаимодействия с ботом и учтите различные ситуации, которые могут возникнуть в процессе общения.

\end{itemize}

\sphinxAtStartPar
4.4 Взаимодействие с разработчиком и тестировщиком:
Помимо пользователя и администратора, нужно учитывать возможность взаимодействия с ботом разработчика/тестировщика. Это может потребоваться при разработке MVP для организации эффективной работы в команде. Так вы сможете заранее «запланировать» прецеденты участников команды разработки.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите прецеденты, связанные с взаимодействием разработчика и тестировщика с чат\sphinxhyphen{}ботом. Например, «Разработать новую функциональность», «Протестировать функциональность бота» и т.д.

\item {} 
\sphinxAtStartPar
Опишите взаимодействие и обязанности каждой роли в процессе разработки и тестирования бота.

\end{itemize}

\sphinxAtStartPar
4.5 Взаимодействие с внешними системами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите прецеденты, связанные с взаимодействием чат\sphinxhyphen{}бота с внешними системами для получения информации. Например, с базой данных для новостей, олимпиад и рейтинга игры «Берлога». Любо другими бесплатными сервисами предоставления информации посредством API.

\item {} 
\sphinxAtStartPar
Уточните, какие данные будут передаваться между ботом и внешними системами и какие протоколы будут использоваться.

\end{itemize}

\sphinxAtStartPar
Разработка диаграммы прецедентов позволит вам лучше понять функциональность чат\sphinxhyphen{}бота и его взаимодействие с пользователями, а также обеспечит более ясное представление о том, как пользователи будут взаимодействовать с ботом и какие функции должны быть реализованы в приложении.


\paragraph{5. Разработать диаграммы классов}
\label{\detokenize{educational_materials/uml/content:id14}}
\sphinxAtStartPar
Составьте диаграммы классов, которые покажут структуру классов в вашем чат\sphinxhyphen{}боте и их взаимосвязи. Определите основные классы, их атрибуты и методы.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определение основных классов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Идентифицируйте основные классы, которые будут использоваться в чат\sphinxhyphen{}боте. Например, «ChatBot», «User», «Developer», «Tester», «News», «Olympiad», «GameRating» и т.д.

\item {} 
\sphinxAtStartPar
Уточните функциональность каждого класса и его назначение в системе.

\end{itemize}

\item {} 
\sphinxAtStartPar
Атрибуты классов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Для каждого класса определите его атрибуты. Например, у класса «User» могут быть атрибуты: «Имя», «ID пользователя», «Последний запрос» и т.д.

\item {} 
\sphinxAtStartPar
Определите типы данных для каждого атрибута и их свойства (например, публичный или приватный доступ).

\end{itemize}

\item {} 
\sphinxAtStartPar
Методы классов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите для каждого класса методы, которые будут реализовывать функциональность бота. Например, у класса «ChatBot» может быть метод «Отправить сообщение», у класса «User» — метод «Запросить информацию» и т.д.

\item {} 
\sphinxAtStartPar
Опишите, что делает каждый метод и какие параметры принимает.

\end{itemize}

\item {} 
\sphinxAtStartPar
Взаимосвязи между классами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Укажите связи между классами на диаграмме. Например, связь «ассоциация» между классами «ChatBot» и «User» для обозначения взаимодействия бота с пользователем.

\item {} 
\sphinxAtStartPar
Определите типы связей (например, «агрегация», «композиция» и т.д.) и их характеристики.

\end{itemize}

\item {} 
\sphinxAtStartPar
Дополнительные аспекты:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Уточните, какие классы являются абстрактными или интерфейсами, если такие есть в вашем проекте.

\item {} 
\sphinxAtStartPar
Обратите внимание на наследование классов и иерархию наследования, если она присутствует.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Разработка диаграмм классов позволит вам лучше понять структуру вашего чат\sphinxhyphen{}бота, определить его компоненты и взаимосвязи, а также обеспечит более ясное представление о том, как будут организованы данные и функциональность в вашем приложении.


\paragraph{6. Разработать диаграммы последовательностей}
\label{\detokenize{educational_materials/uml/content:id15}}
\sphinxAtStartPar
Создайте диаграммы последовательностей для ключевых сценариев использования бота. Эти диаграммы покажут последовательность сообщений и взаимодействие между компонентами во время выполнения сценариев.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определение ключевых сценариев:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Идентифицируйте ключевые сценарии использования вашего чат\sphinxhyphen{}бота. Например, «Отправка новостей», «Запрос рейтинга игры», «Ответ на вопросы пользователей» и т.д.

\item {} 
\sphinxAtStartPar
Определите общий поток выполнения для каждого сценария.

\end{itemize}

\item {} 
\sphinxAtStartPar
Создание диаграммы последовательности:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Для каждого ключевого сценария разработайте соответствующую диаграмму последовательности.

\item {} 
\sphinxAtStartPar
Укажите объекты (компоненты) в диаграмме, которые участвуют в сценарии. Например, «User», «ChatBot», «News», «GameRating» и т.д.

\item {} 
\sphinxAtStartPar
Определите сообщения, которые передаются между компонентами во время выполнения сценария. Например, «User» отправляет запрос на «ChatBot», «ChatBot» обрабатывает запрос и отправляет ответ «User».

\end{itemize}

\item {} 
\sphinxAtStartPar
Последовательность сообщений:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Уточните последовательность отправки и получения сообщений между компонентами в каждом сценарии.

\item {} 
\sphinxAtStartPar
Определите условия и ветвления в сценариях, если они есть.

\end{itemize}

\item {} 
\sphinxAtStartPar
Обработка и отображение данных:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Покажите, какие данные обрабатываются во время выполнения каждого сценария и какие результаты возвращаются пользователю.

\end{itemize}

\item {} 
\sphinxAtStartPar
Дополнительные аспекты:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Обратите внимание на взаимодействие с внешними системами, если они присутствуют в сценариях.

\item {} 
\sphinxAtStartPar
Укажите возможные исключения или ошибки, которые могут возникнуть во время выполнения сценариев.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Разработка диаграмм последовательностей позволит вам визуализировать последовательность сообщений и взаимодействие между компонентами во время выполнения ключевых сценариев вашего чат\sphinxhyphen{}бота. Это поможет улучшить понимание работы вашего приложения и обеспечит более ясное представление о том, как будут выполняться задачи и обрабатываться данные.


\paragraph{7. Разработать диаграммы компонентов и развертывания}
\label{\detokenize{educational_materials/uml/content:id16}}
\sphinxAtStartPar
Создайте диаграммы компонентов и развертывания для описания архитектуры и размещения компонентов вашего бота. Эти диаграммы помогут понять, как компоненты взаимодействуют между собой и как они размещены на сервере.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Определение компонентов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Идентифицируйте основные компоненты вашего чат\sphinxhyphen{}бота, которые были определены на предыдущих этапах разработки.

\item {} 
\sphinxAtStartPar
Обозначьте каждый компонент, опишите его функциональность и взаимосвязи с другими компонентами.

\end{itemize}

\item {} 
\sphinxAtStartPar
Создание диаграммы компонентов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Составьте диаграмму компонентов, которая покажет структуру вашего чат\sphinxhyphen{}бота и его компонентов.

\item {} 
\sphinxAtStartPar
Укажите каждый компонент в диаграмме и его связи с другими компонентами.

\item {} 
\sphinxAtStartPar
Определите интерфейсы, которые используются для взаимодействия между компонентами.

\end{itemize}

\item {} 
\sphinxAtStartPar
Размещение компонентов на сервере:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Создайте диаграмму развертывания, которая покажет, как компоненты вашего чат\sphinxhyphen{}бота размещены на сервере.

\item {} 
\sphinxAtStartPar
Укажите сервер и его характеристики, такие как операционная система, процессор, память и т.д.

\item {} 
\sphinxAtStartPar
Определите, как каждый компонент размещен на сервере и как они взаимодействуют друг с другом.

\end{itemize}

\item {} 
\sphinxAtStartPar
Взаимодействие компонентов:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите, как компоненты взаимодействуют друг с другом на уровне кода и какие интерфейсы используются для этого.

\item {} 
\sphinxAtStartPar
Покажите последовательность сообщений и обмен данных между компонентами на диаграмме компонентов и развертывания.

\end{itemize}

\item {} 
\sphinxAtStartPar
Дополнительные аспекты:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Обратите внимание на безопасность и защиту данных при размещении компонентов на сервере.

\item {} 
\sphinxAtStartPar
Укажите возможные сценарии масштабирования и расширения системы при необходимости.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Разработка диаграмм компонентов и развертывания позволит вам визуализировать структуру и размещение компонентов вашего чат\sphinxhyphen{}бота на сервере. Это поможет более полно понять архитектуру вашего приложения и обеспечит более четкое представление о взаимодействии компонентов в системе.


\paragraph{8. Протестируйте и оптимизируйте диаграммы}
\label{\detokenize{educational_materials/uml/content:id17}}
\sphinxAtStartPar
После создания диаграмм убедитесь, что они полно и точно отражают архитектуру и функциональность вашего бота. Проведите тестирование и оптимизацию диаграмм, чтобы улучшить их качество и понимание.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Проверка полноты и точности диаграмм:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Проведите проверку каждой диаграммы на предмет полноты и точности отражения архитектуры и функциональности вашего чат\sphinxhyphen{}бота.

\item {} 
\sphinxAtStartPar
Убедитесь, что все ключевые компоненты и функции бота отображены на диаграммах и взаимосвязи между ними корректно представлены.

\end{itemize}

\item {} 
\sphinxAtStartPar
Тестирование диаграмм:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Протестируйте диаграммы с помощью коллег или экспертов в области разработки и архитектуры программного обеспечения.

\item {} 
\sphinxAtStartPar
При тестировании диаграмм обратите внимание на их понятность, читаемость и соответствие спецификациям и требованиям.

\end{itemize}

\item {} 
\sphinxAtStartPar
Оптимизация диаграмм:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Если необходимо, внесите корректировки в диаграммы для повышения их читаемости и понятности.

\item {} 
\sphinxAtStartPar
Убедитесь, что каждая диаграмма является лаконичной и содержит только необходимую информацию, чтобы избежать избыточности и путаницы.

\end{itemize}

\item {} 
\sphinxAtStartPar
Обратная связь и доработка:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Получите обратную связь от команды разработки, аналитиков и заказчика на предмет качества диаграмм и их соответствия требованиям.

\item {} 
\sphinxAtStartPar
Внесите необходимые доработки и улучшения в диаграммы на основе обратной связи и результатов тестирования.

\end{itemize}

\item {} 
\sphinxAtStartPar
Документирование и сохранение:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Завершив тестирование и оптимизацию, документируйте окончательные версии диаграмм и сохраните их для будущего использования и сопровождения проекта.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Протестированные и оптимизированные диаграммы обеспечат более четкое и понятное представление о структуре и функциональности вашего чат\sphinxhyphen{}бота. Это также поможет улучшить сотрудничество между членами команды разработки и обеспечит более эффективное планирование и управление проектом.


\paragraph{9. Итеративное развитие}
\label{\detokenize{educational_materials/uml/content:id18}}
\sphinxAtStartPar
Постепенно уточняйте и дополняйте диаграммы по мере разработки бота. UML\sphinxhyphen{}диаграммы должны быть гибким инструментом, который помогает вам понять и описать архитектуру вашего проекта на каждом этапе разработки.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Постепенное уточнение диаграмм:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Начните с создания основных диаграмм на ранних этапах разработки чат\sphinxhyphen{}бота, таких как диаграммы прецедентов, классов и последовательностей.

\item {} 
\sphinxAtStartPar
Постепенно уточняйте диаграммы с учетом изменений в требованиях, дополнительных функциональностей и отклика команды разработки.

\end{itemize}

\item {} 
\sphinxAtStartPar
Гибкий инструмент для архитектуры проекта:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Используйте UML диаграммы в качестве гибкого инструмента для понимания и описания архитектуры вашего проекта на различных этапах разработки.

\item {} 
\sphinxAtStartPar
Уточнение и дополнение диаграмм поможет вам лучше понять структуру и взаимосвязи компонентов вашего чат\sphinxhyphen{}бота.

\end{itemize}

\item {} 
\sphinxAtStartPar
Итеративный подход:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Применяйте итеративный подход к разработке и использованию диаграмм, что позволит вам улучшать их постепенно на протяжении всего процесса разработки.

\item {} 
\sphinxAtStartPar
Вносите изменения в диаграммы, когда появляются новые идеи или когда требования к проекту меняются.

\end{itemize}

\item {} 
\sphinxAtStartPar
Связь с командой разработки:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Поддерживайте постоянную связь с командой разработки и обновляйте диаграммы на основе их обратной связи и предложений.

\item {} 
\sphinxAtStartPar
Диаграммы должны быть актуальными и отражать текущее состояние разработки проекта.

\end{itemize}

\item {} 
\sphinxAtStartPar
Визуализация прогресса:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Используйте диаграммы для визуализации прогресса разработки и коммуникации с заинтересованными сторонами, такими как заказчики и руководство.

\item {} 
\sphinxAtStartPar
Диаграммы позволят лучше представить архитектуру и функциональность бота на каждом этапе разработки.

\end{itemize}

\item {} 
\sphinxAtStartPar
Документирование и сохранение:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Документируйте каждое обновление диаграмм и сохраняйте их для последующего анализа и сопровождения проекта.

\item {} 
\sphinxAtStartPar
Это поможет вам возвращаться к предыдущим версиям и отслеживать изменения в архитектуре вашего чат\sphinxhyphen{}бота.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Итеративная разработка UML\sphinxhyphen{}диаграмм позволит вам создавать более точные и актуальные представления архитектуры вашего чат\sphinxhyphen{}бота, а также облегчит процесс коммуникации и совместной работы в команде разработки.


\paragraph{Какие инструменты с открытым исходным кодом доступны для работы с UML?}
\label{\detokenize{educational_materials/uml/content:id19}}
\sphinxAtStartPar
Существует множество инструментов с открытым исходным кодом для работы с UML, некоторые из популярных:
\begin{itemize}
\item {} 
\sphinxAtStartPar
StarUML: комплексный инструмент моделирования UML, который поддерживает все диаграммы UML и доступен для Windows, macOS и Linux.

\item {} 
\sphinxAtStartPar
Umbrello UML Modeller: простой в использовании инструмент моделирования UML, который поддерживает все диаграммы UML и доступен для Linux.

\item {} 
\sphinxAtStartPar
BOUML: быстрый и легкий инструмент моделирования UML, который поддерживает все диаграммы UML и доступен для Windows, macOS и Linux.

\item {} 
\sphinxAtStartPar
ArgoUML: простой и удобный в использовании инструмент моделирования UML, который поддерживает большинство диаграмм UML и доступен для Windows, macOS и Linux.

\item {} 
\sphinxAtStartPar
Visual Paradigm: комплексный инструмент моделирования UML, который поддерживает все диаграммы UML и доступен для Windows, macOS и Linux.

\item {} 
\sphinxAtStartPar
PlantUML: простой и легкий инструмент моделирования UML, который поддерживает большинство диаграмм UML и доступен в виде подключаемого модуля для популярных IDE, таких как Eclipse и IntelliJ IDEA.

\end{itemize}

\sphinxAtStartPar
Эти инструменты предлагают ряд функций, включая поддержку всех диаграмм UML, настройку диаграмм, генерацию кода и обратный инжиниринг. Они идеально подходят для разработчиков и дизайнеров, которым необходимо создавать диаграммы UML для своих проектов.


\paragraph{Как оценить качество модели UML?}
\label{\detokenize{educational_materials/uml/content:id20}}
\sphinxAtStartPar
Для оценки качества модели UML можно учитывать следующие факторы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Полнота: модель UML должна включать все необходимые элементы, отношения и атрибуты для точного представления моделируемой системы;

\item {} 
\sphinxAtStartPar
Непротиворечивость: модель UML должна быть согласованной с точки зрения соглашений об именах, отношений и атрибутов;

\item {} 
\sphinxAtStartPar
Корректность: модель UML должна точно отражать моделируемую систему реального мира, включая все ее функциональные и нефункциональные требования;

\item {} 
\sphinxAtStartPar
Ясность: модель UML должна быть ясной и легкой для понимания, без двусмысленности и ненужной сложности;

\item {} 
\sphinxAtStartPar
Повторное использование: модель UML должна быть разработана таким образом, чтобы можно было повторно использовать компоненты в других моделях или системах;

\item {} 
\sphinxAtStartPar
Масштабируемость: модель UML должна быть масштабируемой, чтобы приспосабливаться к изменениям и росту моделируемой реальной системы;

\item {} 
\sphinxAtStartPar
Валидация: модель UML должна быть проверена путем тестирования ее на реальной системе или проведения приемочного тестирования пользователями.

\end{itemize}

\sphinxAtStartPar
Оценка качества модели UML является непрерывным процессом и должна выполняться на разных этапах процесса моделирования. Регулярный просмотр и проверка могут гарантировать, что модель UML останется точной и актуальной на протяжении всего проекта.

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/uml/exercises:id1}}\label{\detokenize{educational_materials/uml/exercises::doc}}

\subsection{1. Построение диаграммы классов для чат\sphinxhyphen{}бота Telegram:}
\label{\detokenize{educational_materials/uml/exercises:telegram}}
\sphinxAtStartPar
Задача: Разработать диаграмму классов для чат\sphinxhyphen{}бота Telegram, который имеет функционал отправки и приема текстовых сообщений от пользователей. Учесть основные классы, такие как «Бот», «Пользователь», «Сообщение», и связи между ними.


\subsection{2. Создание диаграммы последовательности для обработки запросов от пользователя:}
\label{\detokenize{educational_materials/uml/exercises:id2}}
\sphinxAtStartPar
Задача: Разработать диаграмму последовательности, иллюстрирующую взаимодействие между пользователем и чат\sphinxhyphen{}ботом Telegram. Учесть различные сценарии, такие как отправка команды, получение ответа от бота и обработка ошибок.


\subsection{3. Построение диаграммы состояний для управления состоянием чат\sphinxhyphen{}бота:}
\label{\detokenize{educational_materials/uml/exercises:id3}}
\sphinxAtStartPar
Задача: Создать диаграмму состояний, которая описывает различные состояния чат\sphinxhyphen{}бота Telegram, например, «Ожидание команды», «Отправка ответа», «Ошибка». Учесть переходы между состояниями и условия перехода.


\subsection{4. Разработка диаграммы компонентов для чат\sphinxhyphen{}бота Telegram:}
\label{\detokenize{educational_materials/uml/exercises:id4}}
\sphinxAtStartPar
Задача: Построить диаграмму компонентов для чат\sphinxhyphen{}бота Telegram, которая отображает его структуру и взаимосвязи с другими компонентами. Учесть компоненты, такие как «Интерфейс Telegram», «Модуль обработки сообщений», «База данных», и связи между ними.


\subsection{5. Построение диаграммы прецедентов для чат\sphinxhyphen{}бота Telegram:}
\label{\detokenize{educational_materials/uml/exercises:id5}}
\sphinxAtStartPar
Задача: Разработать диаграмму прецедентов, которая описывает функциональность чат\sphinxhyphen{}бота Telegram и взаимодействие с пользователями. Учесть прецеденты, такие как «Отправка сообщения», «Получение команды», «Обработка ошибок», и связи между ними.

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/uml/quiz:id1}}\label{\detokenize{educational_materials/uml/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое UML и для чего он используется?

\item {} 
\sphinxAtStartPar
Какие основные виды диаграмм в UML вы знаете?

\item {} 
\sphinxAtStartPar
Что представляет собой диаграмма классов в UML?

\item {} 
\sphinxAtStartPar
Какие элементы включает диаграмма классов?

\item {} 
\sphinxAtStartPar
Какие основные элементы включает диаграмма последовательности?

\item {} 
\sphinxAtStartPar
Как можно представить взаимодействие между объектами на диаграмме последовательности?

\item {} 
\sphinxAtStartPar
Какие основные элементы включает диаграмма состояний?

\item {} 
\sphinxAtStartPar
Что такое начальное и конечное состояние на диаграмме состояний?

\item {} 
\sphinxAtStartPar
Как можно задать переходы между состояниями на диаграмме состояний?

\item {} 
\sphinxAtStartPar
Что такое диаграмма компонентов в UML и для чего она используется?

\item {} 
\sphinxAtStartPar
Какие элементы включает диаграмма компонентов?

\item {} 
\sphinxAtStartPar
Какие дополнительные диаграммы включает стандарт UML, кроме уже упомянутых?

\item {} 
\sphinxAtStartPar
Каким образом можно использовать UML в процессе разработки программного обеспечения?

\item {} 
\sphinxAtStartPar
Какая роль у UML в проектировании систем и коммуникации между участниками команды разработки?

\item {} 
\sphinxAtStartPar
Какие преимущества и недостатки имеет использование UML в процессе разработки программного обеспечения?

\end{enumerate}


\chapter{Код vs. Библиотека}
\label{\detokenize{index:vs}}
\sphinxstepscope


\section{Код \sphinxhyphen{}\textgreater{} Библиотека}
\label{\detokenize{educational_materials/code_to_lib/content:id1}}\label{\detokenize{educational_materials/code_to_lib/content::doc}}

\subsection{Мотивация}
\label{\detokenize{educational_materials/code_to_lib/content:id2}}
\sphinxAtStartPar
Каждый, кто пишет код, рано или поздно упирается в необходимость использовать свои наработки в нескольких проектах. Мы можем просто копировать участки кода каждый раз в новый проект, но это несет в себе большие издержки, так как мы теряем единую точку «входа», т.е. возможность внести изменения в одном месте и получить их везде, где мы используем этот код. Поэтому мы хотим сделать из нашего кода библиотеку, которая может быть полезна как нам, так и сторонним разработчикам, которую мы сможем поддерживать, функции которой будут описаны, а также автоматически тестироваться, чтобы уменьшить вероятность ошибок. В этом уроке мы поговорим о том, что должно быть в проекте помимо кода, чтобы его можно было назвать библиотекой, а в следующем — рассмотрим, как упаковать наш код, чтобы его могли устанавливать себе другие разработчики.


\subsection{Определяем функциональность библиотеки}
\label{\detokenize{educational_materials/code_to_lib/content:id3}}
\sphinxAtStartPar
Например, мы пишем функцию, которая будет сообщать нам, сколько памяти потребляет та или иная функция. Воспользуемся \sphinxhref{https://docs.python.org/3/library/tracemalloc.html}{документацией} к библиотеке \sphinxcode{\sphinxupquote{tracemalloc}}. Она позволит нам отследить выделенное место. Также можно использовать библиотеку \sphinxcode{\sphinxupquote{sys}}, которая позволит определить только ту память, которую занимает непосредственно объект с данными.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{n}{data} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Пример вывода:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{72}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{32}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{104}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{104}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{104}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{104}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{64}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{136}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{136}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{136}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{136}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{128}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{200}
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{0}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{200}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что даже пустой массив занимает какое\sphinxhyphen{}то место в памяти (для 64\sphinxhyphen{}разрядной системы это 72 байта), и не каждое добавление элементов вызывает выделение памяти. Оговоримся, что в зависимости от того, как заполнять данные, результат будет разным. Ниже приведены примеры кода, которые дадут несколько другой вывод при том же результирующем массиве.

\sphinxAtStartPar
Альтернативный пример:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{i}
   \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Еще альтернативный пример:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы не будет обсуждать разницу в выводе, она связана с особенностями реализации списков в Python и способе создания конкретного списка. Для наших задач необязательно знать точные числа, но нужно иметь оценку объема памяти, выделяемой на те или иные операции, для того чтобы разбить полный массив данных на части (\sphinxcode{\sphinxupquote{chunk}}) и обрабатывать так, чтобы все умещалось в памяти. Практически всегда можно сделать оценку потребляемой памяти вручную, но такой подход требует погружения в детали задачи.

\sphinxAtStartPar
Давайте попробуем разделить код выше на функциональную часть, которая делает что\sphinxhyphen{}то полезное для нас, и ту, которая оценивает память:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}something\PYGZus{}usefull}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}    
    \PYG{k}{return} \PYG{n}{data}
    
\PYG{k}{def} \PYG{n+nf}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{function}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{function}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{data} 
    
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{do\PYGZus{}something\PYGZus{}usefull}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь можно попробовать сделать \sphinxcode{\sphinxupquote{execute\_and\_get\_memory\_usage}} более универсальным, так, чтобы эта функция могла работать с любой функцией, а не только с \sphinxcode{\sphinxupquote{do\_something\_usefull}}. Так как мы не знаем, какие аргументы будут у функций, нужен способ, который позволит не ограничиваться определенным количеством аргументов. Для этого в Python используются \sphinxcode{\sphinxupquote{*args}} и \sphinxcode{\sphinxupquote{**kwargs}}.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}something\PYGZus{}usefull}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}    
    \PYG{k}{return} \PYG{n}{data}

\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}something\PYGZus{}else\PYGZus{}usefull}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{step}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{data}
    
\PYG{k}{def} \PYG{n+nf}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{function}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{function}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to sys: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{getsizeof}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1D example:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{do\PYGZus{}something\PYGZus{}usefull}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{2D example:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{do\PYGZus{}something\PYGZus{}else\PYGZus{}usefull}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Пример вывода:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1D\PYG{+w}{ }example:
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{320}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{200}

2D\PYG{+w}{ }example:
According\PYG{+w}{ }to\PYG{+w}{ }tracemalloc:\PYG{+w}{ }\PYG{l+m}{1112}
According\PYG{+w}{ }to\PYG{+w}{ }sys:\PYG{+w}{ }\PYG{l+m}{136}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что \sphinxcode{\sphinxupquote{sys.getsizeof()}} не информативен для вложенных объектов, поэтому оставим только tracemalloc. *Примечание: функции типа \sphinxcode{\sphinxupquote{execute\_and\_get\_memory\_usage}} в Python называются декораторы, мы не будем подробно на этом останавливаться, так как этот курс не про само программирование и изучение языка. Вы можете легко найти материалы для изучения самостоятельно, наподобие \sphinxhref{https://www.programiz.com/python-programming/decorator}{таких} или \sphinxhref{https://www.geeksforgeeks.org/decorators-in-python/}{таких}.

\sphinxAtStartPar
Мы получили инструмент для оценки памяти, которая требуется для выполнения той или иной функции с определенным набором входных данных. Теперь мы хотим использовать ее в других наших проектах. Возможно даже, она будет интересна другим разработчикам, поэтому нужно оформить все как принято при распространении кода. Здесь мы пока не будем говорить о менеджерах установки, таких как \sphinxcode{\sphinxupquote{pip}} или \sphinxcode{\sphinxupquote{apt}} (используется в Ubuntu), поговорим пока о том, что должно быть помимо кода, чтобы кодом можно было воспользоваться.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Первое, что должно сопровождать код, — это файл \sphinxstylestrong{README}.md. Мы будем использовать Markdown для разметки, также часто используется \sphinxcode{\sphinxupquote{reStructedText}}, тогда вы увидите \sphinxcode{\sphinxupquote{README.rst}} в списке файлов проекта. Файл README нужен для того, чтобы понять, будет ли полезен данный проект тому, кто его читает. В README могут содержаться короткие примеры того, как использовать API библиотеки, и другая полезная информация, которую разработчик пожелал добавить. \sphinxhref{https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/}{Пункты}, которые обычно включает README:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
название проекта;

\item {} 
\sphinxAtStartPar
описание;

\item {} 
\sphinxAtStartPar
содержание для удобной навигации;

\item {} 
\sphinxAtStartPar
инструкции по установке;

\item {} 
\sphinxAtStartPar
примеры использования приложения;

\item {} 
\sphinxAtStartPar
упоминание участников, которые внесли вклад в проект;

\item {} 
\sphinxAtStartPar
информация о лицензии (текст лицензии содержится в отдельном файле);

\item {} 
\sphinxAtStartPar
бейджи;

\item {} 
\sphinxAtStartPar
способы поучаствовать в проекте.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{badge}.png}

\sphinxAtStartPar
Научиться писать хороший README можно только через практику и примеры, которые вы сами считаете хорошими. \sphinxhref{https://github.com/matiassingers/awesome-readme}{Здесь} собран список проектов, которые, по мнению авторов списка, являются хорошими, обратитесь к нему и составьте свое мнение о том, что должен включать это файл.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Далее проект должен содержать файл \sphinxstylestrong{LICENSE} с текстом лицензии. По лицензиям в курсе есть \sphinxhref{https://github.com/kruzhok-team/fossdev/blob/devel/educational\_materials/open\_license/content.md}{отдельный материал}, посмотрите его и выберите подходящую.

\item {} 
\sphinxAtStartPar
Как мы уже говорили ранее, в README должны быть инструкции по установке. Установка может быть как полностью ручная, так и с той или иной степенью автоматизации. Например, в проектах на Python часто содержится файл \sphinxcode{\sphinxupquote{setup.py}}, в котором прописан код для установки. Тогда инструкция по установке выглядит как одна строка:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }setup.py
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Любой код использует другой код, поэтому в проекте нужно прописать список используемых библиотек, \sphinxstylestrong{зависимостей}. Его можно как вести вручную, например, в файле \sphinxcode{\sphinxupquote{requirements.txt}}, который используется \sphinxcode{\sphinxupquote{pip}} для установки зависимостей, так и автоматически, если мы используем другой инструмент, например, \sphinxcode{\sphinxupquote{poetry}}.

\item {} 
\sphinxAtStartPar
Каталог, который содержит код проекта. Для разных языков программирования он будет называть по\sphinxhyphen{}разному. Для проектов на Python название каталога совпадает с названием проекта. В С++ это будут \sphinxcode{\sphinxupquote{src}} и \sphinxcode{\sphinxupquote{include}}.

\item {} 
\sphinxAtStartPar
Очень хорошая идея иметь тесты в проекте, это поможет понять пользователю вашей библиотеки, что код выполнился штатно, хотя бы для тестовых данных. Файлы с тестами будут иметь разную структуру для разных языков программирования.

\end{enumerate}

\sphinxAtStartPar
Для Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
my\PYGZus{}project
├──\PYG{+w}{ }mtracker
│\PYG{+w}{   }├──\PYG{+w}{ }utils
│\PYG{+w}{   }│\PYG{+w}{   }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
│\PYG{+w}{   }│\PYG{+w}{   }└──\PYG{+w}{ }futils.py
│\PYG{+w}{   }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
│\PYG{+w}{   }└──\PYG{+w}{ }mtracker.py
└──\PYG{+w}{ }\PYG{n+nb}{test}
\PYG{+w}{    }├──\PYG{+w}{ }utils
\PYG{+w}{    }│\PYG{+w}{   }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
\PYG{+w}{    }│\PYG{+w}{   }└──\PYG{+w}{ }test\PYGZus{}futils.py
\PYG{+w}{    }├──\PYG{+w}{ }\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
\PYG{+w}{    }└──\PYG{+w}{ }test\PYGZus{}mtracker.py
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Примечание: \sphinxcode{\sphinxupquote{\_\_init\_\_.py}} нужен для того, чтобы Python воспринимал каталог как пакет}


\subsection{Собираем проект}
\label{\detokenize{educational_materials/code_to_lib/content:id4}}
\sphinxAtStartPar
Напишем файл для установки \sphinxcode{\sphinxupquote{setup.py}}, для данного примера воспользуемся библиотекой \sphinxcode{\sphinxupquote{setuptools}}.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{setuptools} \PYG{k+kn}{import} \PYG{n}{setup}

\PYG{n}{setup}\PYG{p}{(}
   \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mtraker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Provides a decorator for memory usage tracking. The part of FOSS course.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{license}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MIT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{author}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Artem Vesnin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{author\PYGZus{}email}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{artemvesnin@gmail.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{url}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://github.com/standlab/mtracker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
   \PYG{n}{packages}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mtracker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
   \PYG{n}{install\PYGZus{}requires}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} it is empty since we use standard python library}
   \PYG{n}{extras\PYGZus{}require}\PYG{o}{=}\PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pytest}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coverage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{p}{]}\PYG{p}{,}
   \PYG{p}{\PYGZcb{}}\PYG{p}{,}
   \PYG{n}{python\PYGZus{}requires}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}=3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы устанавливаем пакет \sphinxcode{\sphinxupquote{mtracker}}, \sphinxcode{\sphinxupquote{install\_requires}} пустое, поскольку мы не используем зависимости не из стандартной библиотеки Python. \sphinxcode{\sphinxupquote{extras\_require}} содержат модули, которые не нужны при работе приложения, но понадобятся, если мы захотим прогнать тесты для проекта. Также указываем версию Python, под которой проект должен запуститься.

\sphinxAtStartPar
README можно посмотреть на \sphinxhref{https://github.com/standlab/mtracker}{странице} проекта на GitHub.

\sphinxAtStartPar
От кода, который мы разрабатывали выше, оставим только часть с \sphinxcode{\sphinxupquote{tracemalloc}}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tracemalloc}

\PYG{k}{def} \PYG{n+nf}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{function}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{before} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{function}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{after} \PYG{o}{=} \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{get\PYGZus{}traced\PYGZus{}memory}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{tracemalloc}\PYG{o}{.}\PYG{n}{stop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{According to tracemalloc: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{after}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{before}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\sphinxAtStartPar
И снабдим наш проект тестом. Здесь мы написали всего один тест, который проверит, не ломает ли наш трекер работу функций, на примере функции, которая возвращает список.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pytest}
\PYG{k+kn}{from} \PYG{n+nn}{mtracker}\PYG{n+nn}{.}\PYG{n+nn}{mtracker} \PYG{k+kn}{import} \PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}

\PYG{k}{def} \PYG{n+nf}{\PYGZus{}generate\PYGZus{}list}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lst} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{lst}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{lst}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}no\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{lst1} \PYG{o}{=} \PYG{n}{\PYGZus{}generate\PYGZus{}list}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{lst2} \PYG{o}{=} \PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}\PYG{p}{(}\PYG{n}{\PYGZus{}generate\PYGZus{}list}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lst1}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lst2}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{l1}\PYG{p}{,} \PYG{n}{l2} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{lst1}\PYG{p}{,} \PYG{n}{lst2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{l1} \PYG{o}{==} \PYG{n}{l2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверим тесты:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}/foss/mtracker\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{pytest}
\PYG{+w}{    }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }session\PYG{+w}{ }\PYG{n+nv}{starts}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\PYG{+w}{    }platform\PYG{+w}{ }linux\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }Python\PYG{+w}{ }\PYG{l+m}{3}.7.4,\PYG{+w}{ }pytest\PYGZhy{}5.2.1,\PYG{+w}{ }py\PYGZhy{}1.8.0,\PYG{+w}{ }pluggy\PYGZhy{}0.13.0
\PYG{+w}{    }rootdir:\PYG{+w}{ }/home/artem/swdev/gitrepo/edu/toolchain\PYGZus{}proj/mtracker
\PYG{+w}{    }plugins:\PYG{+w}{ }doctestplus\PYGZhy{}0.4.0,\PYG{+w}{ }arraydiff\PYGZhy{}0.3,\PYG{+w}{ }remotedata\PYGZhy{}0.3.2,\PYG{+w}{ }openfiles\PYGZhy{}0.4.0
\PYG{+w}{    }collected\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }item\PYG{+w}{                                                               }
\PYG{+w}{    }
\PYG{+w}{    }test/test\PYGZus{}mtracker.py\PYG{+w}{ }.\PYG{+w}{                                                  }\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }passed\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{0}.04s\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\end{sphinxVerbatim}

\sphinxAtStartPar
Устанавливаем:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}/foss/mtracker\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }.
\PYG{+w}{    }Processing\PYG{+w}{ }/home/artem/foss/mtracker
\PYG{+w}{    }Building\PYG{+w}{ }wheels\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }collected\PYG{+w}{ }packages:\PYG{+w}{ }mtracker
\PYG{+w}{    }...
\PYG{+w}{    }Successfully\PYG{+w}{ }installed\PYG{+w}{ }mtracker\PYGZhy{}1.0
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверяем:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{mtracker} \PYG{k+kn}{import} \PYG{n}{mtracker}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mtracker}\PYG{o}{.}\PYG{n}{execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage}
\PYG{g+go}{\PYGZlt{}function execute\PYGZus{}and\PYGZus{}get\PYGZus{}memory\PYGZus{}usage at 0x7effef7b1cb0\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверяем установку как в README:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }git+https://github.com/standlab/mtracker.git\PYGZsh{}egg\PYG{o}{=}mtracker
\PYG{+w}{    }Collecting\PYG{+w}{ }mtracker\PYG{+w}{ }from\PYG{+w}{ }git+https://github.com/standlab/mtracker.git\PYGZsh{}egg\PYG{o}{=}mtracker
\PYG{+w}{    }...
\PYG{+w}{    }Installing\PYG{+w}{ }collected\PYG{+w}{ }packages:\PYG{+w}{ }mtracker
\PYG{+w}{    }Successfully\PYG{+w}{ }installed\PYG{+w}{ }mtracker\PYGZhy{}1.0
\end{sphinxVerbatim}


\subsection{Выводы}
\label{\detokenize{educational_materials/code_to_lib/content:id5}}
\sphinxAtStartPar
Мы снабдили написанную нами функцию необходимыми файлами, чтобы ее можно было выложить в открытый доступ и позволить другим разработчикам устанавливать ее себе и использовать ее API.

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/code_to_lib/exercises:id1}}\label{\detokenize{educational_materials/code_to_lib/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/code_to_lib/exercises:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Организуйте код библиотеки \sphinxcode{\sphinxupquote{useful\_utils}}, который содержит модули для математических операций и работы со строками, в виде библиотеки.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Определите модули и их функциональность: в структуре каталогов создайте отдельные файлы модулей для представления различных функций вашей библиотеки: math\_operations.py и string\_utils.py.

\item {} 
\sphinxAtStartPar
Функции в math\_operations.py:
\begin{itemize}
\item {} 
\sphinxAtStartPar
add(a, b): принимает два аргумента a и b и возвращает их сумму.

\item {} 
\sphinxAtStartPar
subtract(a, b): принимает два аргумента a и b и возвращает их разницу.

\item {} 
\sphinxAtStartPar
multiply(а, b): принимает два аргумента a и b и возвращает их произведение.

\item {} 
\sphinxAtStartPar
devide(а, b): принимает два аргумента a и b и возвращает результат деления a на b.

\end{itemize}

\item {} 
\sphinxAtStartPar
Функции для string\_utils.py:
\begin{itemize}
\item {} 
\sphinxAtStartPar
concatenate(a, b): принимает две строки a и b и возвращает их конкатенацию.

\item {} 
\sphinxAtStartPar
reverse(s): принимает строку s и возвращает ее реверс.

\item {} 
\sphinxAtStartPar
substring(s, i, j): принимает строку s и возвращает подстроку.

\end{itemize}

\item {} 
\sphinxAtStartPar
Создайте файл \sphinxcode{\sphinxupquote{\_\_init\_\_.py}} и напишите содержимое так, чтобы функции из модулей были доступны, когда кто\sphinxhyphen{}то импортирует вашу библиотеку, т.е. чтобы можно было выполнить импорт таким образом.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{useful\PYGZus{}utils} \PYG{k+kn}{import} \PYG{n}{add}\PYG{p}{,} \PYG{n}{subtract}\PYG{p}{,} \PYG{n}{multiply}\PYG{p}{,} \PYG{n}{divide}\PYG{p}{,} \PYG{n}{concatenate}\PYG{p}{,} \PYG{n}{reverse}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Протестируйте свой код: создайте отдельный каталог тестов для написания тестовых случаев для вашей библиотеки. Реализуйте тесты для каждой функции.

\item {} 
\sphinxAtStartPar
Напишите \sphinxcode{\sphinxupquote{setup.py}}

\item {} 
\sphinxAtStartPar
Добавьте README: Создайте файл README.md с кратким описанием вашей библиотеки, инструкциями по ее установке и использованию и примерами использования каждой функции.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
Структура проекта:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}library}\PYG{o}{/}
    \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{useful\PYGZus{}utils}\PYG{o}{/}
    \PYG{o}{|}   \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}   \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{math\PYGZus{}operations}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}   \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{string\PYGZus{}utils}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{tests}\PYG{o}{/}
    \PYG{o}{|}   \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{test\PYGZus{}math\PYGZus{}operations}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}   \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{test\PYGZus{}string\PYGZus{}utils}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{README}\PYG{o}{.}\PYG{n}{md}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{math\_operations.py}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return the sum of two numbers.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{subtract}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return the difference between two numbers.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return the product of two numbers.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{divide}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the result of dividing two numbers.}

\PYG{l+s+sd}{    If b is zero, raise a ValueError.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cannot divide by zero}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{string\_utils.py}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{concatenate}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Concatenate two strings and return the result.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return the reverse of the input string.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{s}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    
\PYG{k}{def} \PYG{n+nf}{substring}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return the substring of the input string.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{\_\_init\_\_.py}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py}

\PYG{c+c1}{\PYGZsh{} Import functions from math\PYGZus{}operations.py}
\PYG{k+kn}{from} \PYG{n+nn}{.}\PYG{n+nn}{math\PYGZus{}operations} \PYG{k+kn}{import} \PYG{n}{add}\PYG{p}{,} \PYG{n}{subtract}\PYG{p}{,} \PYG{n}{multiply}\PYG{p}{,} \PYG{n}{divide}

\PYG{c+c1}{\PYGZsh{} Import functions from string\PYGZus{}utils.py}
\PYG{k+kn}{from} \PYG{n+nn}{.}\PYG{n+nn}{string\PYGZus{}utils} \PYG{k+kn}{import} \PYG{n}{concatenate}\PYG{p}{,} \PYG{n}{reverse}\PYG{p}{,} \PYG{n}{substring}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{setup.py}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{setuptools} \PYG{k+kn}{import} \PYG{n}{setup}\PYG{p}{,} \PYG{n}{find\PYGZus{}packages}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useful\PYGZhy{}utils}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.0.0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{packages}\PYG{o}{=}\PYG{n}{find\PYGZus{}packages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Utils to make life easier}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{author}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Your Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{author\PYGZus{}email}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{your\PYGZus{}name@example.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{url}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://github.com/your\PYGZus{}username/your\PYGZus{}repository}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{install\PYGZus{}requires}\PYG{o}{=}\PYG{p}{[}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pytest}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{]}\PYG{p}{,}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое тестов (может отличаться):

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{useful\PYGZus{}utils}\PYG{n+nn}{.}\PYG{n+nn}{math\PYGZus{}operations} \PYG{k+kn}{import} \PYG{n}{add}\PYG{p}{,} \PYG{n}{subtract}\PYG{p}{,} \PYG{n}{multiply}\PYG{p}{,} \PYG{n}{divide}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}add}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{5}
    \PYG{k}{assert} \PYG{n}{add}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{4}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}subtract}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{subtract}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}
    \PYG{k}{assert} \PYG{n}{subtract}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}multiply}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{multiply}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{12}
    \PYG{k}{assert} \PYG{n}{multiply}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}divide}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{5}
    \PYG{k}{assert} \PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{5}
    \PYG{k}{assert} \PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{3.5}
\end{sphinxVerbatim}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{useful\PYGZus{}utils}\PYG{n+nn}{.}\PYG{n+nn}{string\PYGZus{}utils} \PYG{k+kn}{import} \PYG{n}{concatenate}\PYG{p}{,} \PYG{n}{reverse}\PYG{p}{,} \PYG{n}{substring}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}concatenate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{concatenate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{World}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HelloWorld}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{assert} \PYG{n}{concatenate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ is awesome}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python is awesome}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}reverse}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{reverse}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{olleh}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{assert} \PYG{n}{reverse}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nohtyP}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}substring}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{substring}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ll}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{assert} \PYG{n}{substring}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{assert} \PYG{n}{substring}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/code_to_lib/exercises:id3}}
\sphinxAtStartPar
Добавьте дополнительные данные в setup.py.

\sphinxAtStartPar
В этой задаче вы улучшите файл setup.py, который писали для предыдущей задачи. Также можно выполнить это задание для любого другого проекта, над которым мы работаем, или придумать новый. Это нужно, если мы будем публиковать библиотеку для других разработчиков: добавив больше данных, мы дадим дополнительную информацию о библиотеке. Дополнительная информация будет включать лицензию вашей библиотеки, подробное описание, классификаторы и ключевые слова.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Лицензия: выберите подходящую лицензию для своей библиотеки и добавьте ее в файл setup.py. Выбирайте из MIT, BSD, Apache License 2.0 и GPL или используйте свою. Добавьте лицензию непосредственно в функцию setup().

* Подробное описание: создайте файл README.md в корневом каталоге вашего проекта и напишите подробное описание вашей библиотеки. Затем измените файл setup.py, чтобы включить это подробное описание при упаковке библиотеки. Вы можете использовать функции open() и read() для чтения содержимого файла README.md.

* Классификаторы: Классификаторы — это способ категоризировать вашу библиотеку. Вы можете добавить классификаторы, чтобы указать целевую аудиторию, статус разработки, язык программирования и многое другое. Доступные параметры см. в списке классификаторов PyPI.

* Ключевые слова: добавьте список ключевых слов, описывающих основные функции и возможности вашей библиотеки. Это поможет пользователям найти вашу библиотеку в указателях пакетов.
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{README.md}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{long\PYGZus{}description} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useful\PYGZhy{}utils}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{version}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.0.0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{packages}\PYG{o}{=}\PYG{n}{find\PYGZus{}packages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Utils to make life easier}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{long\PYGZus{}description}\PYG{o}{=}\PYG{n}{long\PYGZus{}description}\PYG{p}{,}
    \PYG{n}{long\PYGZus{}description\PYGZus{}content\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{text/markdown}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Specify the type of long description}
    \PYG{n}{author}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Your Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{author\PYGZus{}email}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{your\PYGZus{}name@example.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{url}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://github.com/your\PYGZus{}username/your\PYGZus{}repository}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{install\PYGZus{}requires}\PYG{o}{=}\PYG{p}{[}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pytest}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  
    \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{license}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MIT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Add your library\PYGZsq{}s license here}
    \PYG{n}{classifiers}\PYG{o}{=}\PYG{p}{[}
        \PYG{c+c1}{\PYGZsh{} Add classifiers that describe your library}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Development Status :: 4 \PYGZhy{} Beta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Intended Audience :: Developers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{License :: OSI Approved :: MIT License}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Programming Language :: Python :: 3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Programming Language :: Python :: 3.6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Programming Language :: Python :: 3.7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Programming Language :: Python :: 3.8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Programming Language :: Python :: 3.9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{keywords}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{python library example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Add keywords that describe your library}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/code_to_lib/exercises:id4}}
\sphinxAtStartPar
Напишите makefile, который будет автоматизировать некоторые процедуры, которые мы осуществляем с библиотекой. Определите следующие задачи (target):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Задача **install** устанавливает зависимости проекта, указанные в файле requirements.txt.
* Задача **test** запускает тесты с помощью pytest.
* Задача **clean** удаляет временные файлы, созданные в процессе упаковки.
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{PACKAGE\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }my\PYGZhy{}library
\PYG{n+nv}{PYTHON}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }python3

\PYG{n+nf}{.PHONY}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{install} \PYG{n}{test} \PYG{n}{clean}

\PYG{n+nf}{install}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Installing dependencies...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }requirements.txt

\PYG{n+nf}{test}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Running tests...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pytest

\PYG{n+nf}{clean}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Cleaning up...\PYGZdq{}}
\PYG{+w}{	}rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }dist/\PYG{+w}{ }build/\PYG{+w}{ }*.egg\PYGZhy{}info
\end{sphinxVerbatim}


\subsection{Задача 4}
\label{\detokenize{educational_materials/code_to_lib/exercises:id5}}
\sphinxAtStartPar
Напишите комментарии в виде docstring, которые описывают работу функций и параметры. Помните, что в некоторых случаях порядок параметров неважен, например, при сложении, поэтому можно описать их как первое число и второе число. В других случаях, например, при вычитании, порядок важен, и мы должны описать числа соответствующим образом, даже если интуитивно понятно, что из первого вычитается второе. Написать docstring нужно для функции в модуле math\_operations.py:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* add(a, b): принимает два аргумента a и b и возвращает их сумму.
* subtract(a, b): принимает два аргумента a и b и возвращает их разницу.
* multiply(а, b): принимает два аргумента a и b и возвращает их произведение.
* devide(а, b): принимает два аргумента a и b и возвращает результат деления a на b.
\end{sphinxVerbatim}

\sphinxAtStartPar
Добавьте задачу \sphinxstylestrong{docs} в makefile  для сборки документации с помощью \sphinxhref{https://pdoc.dev/docs/pdoc.html}{pdoc}. Собранная документация не должна попасть в репозиторий git, поэтому нужно модифицировать задачу \sphinxstylestrong{clean}.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the sum of two numbers.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        a (int or float): The first number.}
\PYG{l+s+sd}{        b (int or float): The second number.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        int or float: The sum of a and b.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{subtract}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the difference between two numbers.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        a (int or float): The minuend.}
\PYG{l+s+sd}{        b (int or float): The subtrahend.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        int or float: The result of subtracting b from a.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the product of two numbers.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        a (int or float): The first factor.}
\PYG{l+s+sd}{        b (int or float): The second factor.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        int or float: The product of a and b.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{divide}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the result of dividing two numbers.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        a (int or float): The dividend.}
\PYG{l+s+sd}{        b (int or float): The divisor.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        int or float: The result of dividing a by b.}

\PYG{l+s+sd}{    Raises:}
\PYG{l+s+sd}{        ValueError: If b is zero (0).}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cannot divide by zero}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}

\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{makefile}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{PACKAGE\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }useful\PYGZhy{}utils
\PYG{n+nv}{PYTHON}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }python3
\PYG{n+nv}{DOCS\PYGZus{}DIR}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }docs

\PYG{n+nf}{.PHONY}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{install} \PYG{n}{test} \PYG{n}{clean} \PYG{n}{package} \PYG{n}{docs}

\PYG{n+nf}{install}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Installing dependencies...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }requirements.txt

\PYG{n+nf}{test}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Running tests...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pytest

\PYG{n+nf}{clean}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Cleaning up...\PYGZdq{}}
\PYG{+w}{	}rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }dist/\PYG{+w}{ }build/\PYG{+w}{ }docs/\PYG{+w}{ }*.egg\PYGZhy{}info

\PYG{n+nf}{docs}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Generating documentation...\PYGZdq{}}
\PYG{+w}{	}pdoc\PYG{+w}{ }\PYGZhy{}\PYGZhy{}html\PYG{+w}{ }\PYG{k}{\PYGZdl{}(}PACKAGE\PYGZus{}NAME\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}output\PYGZhy{}dir\PYG{+w}{ }\PYG{k}{\PYGZdl{}(}DOCS\PYGZus{}DIR\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}force
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/code_to_lib/quiz:id1}}\label{\detokenize{educational_materials/code_to_lib/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какова цель создания библиотеки кода?
а) Чтобы продемонстрировать свои навыки программирования потенциальным работодателям.
б) Для организации и повторного использования часто используемого кода.
в) Чтобы заменить систему контроля версий.
г) Чтобы увеличить сложность вашего проекта.

\item {} 
\sphinxAtStartPar
Каков рекомендуемый способ организации библиотеки кода в Python?
а) Создать один большой файл Python со всеми функциями.
б) Разделить связанные функции в разные модули, а модули в пакеты.
в) Использовать несколько файлов Python, при это организация по смыслу не важна.
г) Хранить все функции в одном списке или словаре.

\item {} 
\sphinxAtStartPar
Какова обычная практика документирования функций в библиотеке кода?
а) Добавление комментариев перед каждой функцией.
б) Написание многострочных комментариев внутри тела каждой функции.
в) Предоставление отдельного файла README для документации назначения функций.
г) Встраивание документации в код с помощью специальных тегов, содержимое которых определено в отдельном файле.

\item {} 
\sphinxAtStartPar
Какое из следующих утверждений об упаковке (packaging) кода в виде библиотеки в Python верно?
а) Упаковка не является обязательной для библиотеки кода.
б) Упаковка гарантирует, что библиотека кода работает только на компьютерах с Windows.
в) Упаковка делает библиотеку кода независимой и гарантирует установку, а также работоспособность (при надлежащем покрытии тестами).
г) Упаковка полезна только для крупномасштабных коммерческих проектов.

\item {} 
\sphinxAtStartPar
Каково назначение файла \sphinxcode{\sphinxupquote{setup.py}} в библиотеке кода Python?
а) Используется для указания имени автора и адреса электронной почты.
б) Это файл конфигурации, используемый для настройки виртуальных сред.
в) Он используется для определения зависимостей проекта и инструкций по установке.
г) Это сценарий, используемый для автоматизации процесса тестирования библиотеки кода.

\item {} 
\sphinxAtStartPar
Как создать устанавливаемый пакет (wheel) из библиотеки кода Python?
а) Путем сжатия исходных файлов библиотеки в ZIP\sphinxhyphen{}архив.
б) С помощью команды \sphinxcode{\sphinxupquote{pip package}} в основном файле библиотеки.
в) Выполнив команду \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m build}} в каталоге библиотеки.
г) Вручную скопировав файлы библиотеки в каталог \sphinxcode{\sphinxupquote{site\sphinxhyphen{}packages}} Python.

\item {} 
\sphinxAtStartPar
Какова цель использования виртуальной среды при разработке библиотеки?
а) Чтобы избежать установки каких\sphinxhyphen{}либо зависимостей для библиотеки.
б) Изолировать библиотеку от других проектов Python и зависимостей, которые эти проекты несут с собой.
в) Чтобы библиотеку можно было использовать только в определенной операционной системе.
г) Увеличить скорость запуска тестов для библиотеки.

\item {} 
\sphinxAtStartPar
Какое из следующих утверждений о контроле версий в контексте создания библиотеки кода верно?
а) Контроль версий используется для документирования изменений, внесенных в библиотеку кода.
б) Контроль версий не нужен при работе с личной библиотекой кода.
в) Контроль версий помогает управлять изменениями кода и документации и отслеживать их с течением времени.
г) Контроль версий используется только для совместных проектов с несколькими участниками.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\end{enumerate}


\chapter{Основы Open Source}
\label{\detokenize{index:open-source}}
\sphinxstepscope


\section{Основы Open Source, базовые определения и принципы устройства}
\label{\detokenize{educational_materials/open_source/content:open-source}}\label{\detokenize{educational_materials/open_source/content::doc}}

\subsection{Что такое Open Source?}
\label{\detokenize{educational_materials/open_source/content:id1}}
\sphinxAtStartPar
Открытый исходный код относится к типу лицензии, которая позволяет сделать исходный код программного обеспечения общедоступным, что позволяет любому использовать, модифицировать или распространять код. Это способствует сотрудничеству и прозрачности в разработке программного обеспечения и часто приводит к созданию более надежных и безопасных продуктов.

\sphinxAtStartPar
Программное обеспечение с открытым исходным кодом не только находится в свободном доступе, но и основано на принципах сотрудничества и сообщества. Разработчики со всего мира могут вносить свой вклад в код, исправляя ошибки и добавляя новые функции, что может привести к более быстрому внедрению инноваций и повышению безопасности.

\sphinxAtStartPar
Программное обеспечение с открытым исходным кодом также имеет тенденцию быть более прозрачным и настраиваемым, поскольку пользователи имеют доступ к базовому коду и могут вносить изменения для удовлетворения своих конкретных потребностей.

\sphinxAtStartPar
Это контрастирует с проприетарным программным обеспечением, исходный код которого обычно хранится в тайне, а пользователи могут использовать программное обеспечение только в том виде, в каком оно предоставляется поставщиком.


\subsection{Как развивалось сообщество открытого исходного кода?}
\label{\detokenize{educational_materials/open_source/content:id2}}
\sphinxAtStartPar
Сообщество разработчиков программного обеспечения с открытым исходным кодом претерпело значительные изменения с момента своего создания в конце 1980\sphinxhyphen{}х и начале 1990\sphinxhyphen{}х годов. Вот некоторые из ключевых моментов, в которых сообщество открытого исходного кода изменилось за эти годы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Рост и расширение. Сообщество разработчиков ПО с открытым исходным кодом за последние годы значительно выросло в размерах и влиянии. Сегодня существуют миллионы проектов с открытым исходным кодом, и подавляющее большинство проектов по разработке программного обеспечения так или иначе используют компоненты с открытым исходным кодом. Это стало возможным благодаря развитию Интернета и онлайн\sphinxhyphen{}инструментов для совместной работы.

\item {} 
\sphinxAtStartPar
Процесс взросления. Сообщество разработчиков ПО с открытым исходным кодом с годами стало более структурированным и профессиональным. Многие крупные организации теперь имеют специализированные программы с открытым исходным кодом, и есть много хорошо зарекомендовавших себя сообществ, таких как сообщество Linux, у которых есть четкие процессы для разработки и совместной работы.

\item {} 
\sphinxAtStartPar
Более широкое внедрение. Модель с открытым исходным кодом была принята более широким кругом организаций и отраслей, включая правительства, университеты и коммерческие предприятия. Это привело к разработке новых проектов с открытым исходным кодом и росту существующих, а также к увеличению инвестиций в программное обеспечение с открытым исходным кодом.

\item {} 
\sphinxAtStartPar
Рост коммерциализации. С годами модель с открытым исходным кодом становится все более коммерциализированной, поскольку компании стремятся монетизировать проекты с открытым исходным кодом с помощью услуг, поддержки и обучения. Это привело к созданию новых бизнес\sphinxhyphen{}моделей, таких как программное обеспечение с открытым исходным кодом как услуга (SaaS), и помогло обеспечить устойчивость многих проектов с открытым исходным кодом.

\item {} 
\sphinxAtStartPar
Растущее разнообразие. Сообщество разработчиков открытого исходного кода стало более разнообразным, что отражает растущее разнообразие технологической отрасли в целом. Это привело к более широкому представительству недостаточно представленных групп в сфере технологий, в частности, женщин и национальных меньшинств, и способствовало инклюзивности и разнообразию в технологической отрасли.

\end{itemize}

\sphinxAtStartPar
Подводя итог, можно сказать, что сообщество открытого исходного кода значительно эволюционировало за эти годы, увеличившись в размерах и влиянии, взрослея и становясь более структурированными, будучи принятым более широким кругом организаций и отраслей, становясь более коммерциализированными и увеличивая разнообразие.


\subsection{Как открытый исходный код помогает развивать технологии и ускорять прогресс?}
\label{\detokenize{educational_materials/open_source/content:id3}}
\sphinxAtStartPar
Открытый исходный код помогает развивать технологии и ускорять прогресс несколькими способами:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сотрудничество: открытый исходный код позволяет разработчикам со всего мира сотрудничать в проекте, объединяя свои знания и ресурсы для создания лучшего программного обеспечения.

\item {} 
\sphinxAtStartPar
Инновации: открытый исходный код поощряет инновации, позволяя разработчикам использовать существующий код, экспериментировать с новыми идеями и создавать новые технологии.

\item {} 
\sphinxAtStartPar
Сообщество: сообщество с открытым исходным кодом предоставляет разработчикам платформу для обмена знаниями, идеями и помощи друг другу в решении проблем. Это способствует развитию чувства общности и сотрудничества, которые могут способствовать техническому прогрессу.

\item {} 
\sphinxAtStartPar
Доступность: открытый исходный код делает технологию более доступной для более широкого круга людей, в том числе для тех, у кого может не быть финансовых ресурсов для покупки проприетарного программного обеспечения.

\item {} 
\sphinxAtStartPar
Качество: проекты с открытым исходным кодом часто разрабатываются большими сообществами добровольцев, которые могут быстрее выявлять и исправлять ошибки и уязвимости. Это помогает повысить качество и надежность программного обеспечения с открытым исходным кодом.

\item {} 
\sphinxAtStartPar
Рентабельность: программное обеспечение с открытым исходным кодом часто можно использовать бесплатно, что может быть экономичным вариантом для предприятий и организаций, которым необходимо развивать технологии.

\end{enumerate}

\sphinxAtStartPar
В целом открытый исходный код играет важную роль в развитии технического прогресса, способствуя развитию и сотрудничеству среди разработчиков и коллективов, инновациям, формированию сообществ, доступности и качеству разработки программного обеспечения.


\chapter{Лицензии Open Source}
\label{\detokenize{index:id10}}
\sphinxstepscope


\section{Лицензии Open Source}
\label{\detokenize{educational_materials/open_license/content:open-source}}\label{\detokenize{educational_materials/open_license/content::doc}}\begin{quote}

\sphinxAtStartPar
Принципы работы лицензий, выбор лицензии и применение. Что можно и что нельзя делать с кодом, опубликованным под открытыми лицензиями разных типов. Примеры проектов, в которых используются те или иные лицензии.
\end{quote}


\subsection{Самые распространенные лицензии Open Source}
\label{\detokenize{educational_materials/open_license/content:id1}}
\sphinxAtStartPar
Лицензии с открытым исходным кодом — это юридические соглашения, которые определяют, как можно использовать, изменять и распространять исходный код программного обеспечения с открытым исходным кодом. Некоторые из самых популярных лицензий:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{GPL}} (Стандартная общественная лицензия GNU): вирусная лицензия, которая требует, чтобы производные работы также были с открытым исходным кодом и лицензировались по GPL.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Лицензия MIT}}: разрешающая лицензия, которая позволяет использовать, изменять и распространять программное обеспечение даже в коммерческих приложениях.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Лицензия Apache 2.0}}: разрешающая лицензия, которая позволяет использовать, изменять и распространять программное обеспечение, если пользователи включают в дистрибутив лицензию Apache и уведомление об авторских правах.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Лицензия BSD (Berkeley Software Distribution)}}: разрешающая лицензия, которая позволяет использовать, изменять и распространять программное обеспечение, если пользователи включают в дистрибутив лицензию BSD и уведомление об авторских правах.

\end{itemize}

\sphinxAtStartPar
Выбор лицензии с открытым исходным кодом — важное решение для разработчиков программного обеспечения, поскольку оно определяет, как другие могут использовать их код, и может повлиять на рост и внедрение программного обеспечения.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{1. GPL (GNU General Public License).}} Одна из самых известных и популярных лицензий с открытым исходным кодом. Ее особенности:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Вирусный характер}}: требуется, чтобы все производные работы также были с открытым исходным кодом и распространялись под лицензией GPL.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Доступность исходного кода}}: любой, кто получает копию программного обеспечения под лицензией GPL, имеет право на получение исходного кода.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Открытость}}: любой может использовать, модифицировать и распространять программное обеспечение под лицензией GPL.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Бесплатное использование}}: для использования программного обеспечения под лицензией GPL не требуется никаких дополнительных сборов или лицензионных платежей.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Copyleft}}: положение, требующее, чтобы все производные работы имели одну и ту же лицензию с открытым исходным кодом.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{GPL является}} вирусной лицензией, поэтому все производные работы также должны лицензироваться по GPL, гарантируя, что программное обеспечение остается открытым и свободно доступным для использования и распространения любым лицом.

\end{itemize}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{2. Лицензия MIT}} — это разрешительная лицензия с открытым исходным кодом, которая позволяет использовать, модифицировать и распространять программное обеспечение с очень небольшими ограничениями. Некоторые из ключевых особенностей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Вседозволенность: лицензия MIT — одна из самых гибких разрешительных лицензий на ПО с открытым исходным кодом, допускающая широкий спектр вариантов использования, включая коммерческое.

\item {} 
\sphinxAtStartPar
Отсутствие авторского лева: в отличие от некоторых других лицензий с открытым исходным кодом, таких как GPL, лицензия MIT не требует выпуска производных работ под той же лицензией.

\item {} 
\sphinxAtStartPar
Простая и понятная: лицензия MIT короткая, простая и понятная, что делает ее популярным выбором среди разработчиков.

\item {} 
\sphinxAtStartPar
Ограниченная ответственность: лицензия включает отказ от ответственности, защищающий лицензиара от любых убытков, которые могут возникнуть в результате использования программного обеспечения.

\item {} 
\sphinxAtStartPar
Совместимость: лицензия MIT совместима со многими другими лицензиями с открытым исходным кодом, что позволяет легко комбинировать ее с другими проектами с открытым исходным кодом.

\end{itemize}

\sphinxAtStartPar
Таким образом, \sphinxstyleemphasis{\sphinxstylestrong{лицензия MIT}} — это гибкая разрешительная лицензия, которая позволяет легко интегрироваться с другими проектами с открытым исходным кодом, что делает ее популярным выбором среди разработчиков.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{3. Лицензия Apache}} — это широко используемая лицензия с открытым исходным кодом, которая позволяет использовать, модифицировать и распространять программное обеспечение с некоторыми ограничениями. Некоторые из ключевых особенностей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Разрешение: лицензия Apache — это разрешающая лицензия с открытым исходным кодом, которая допускает широкий спектр вариантов использования, включая коммерческое.

\item {} 
\sphinxAtStartPar
Нет авторского лева: в отличие от некоторых других лицензий с открытым исходным кодом, таких как GPL, лицензия Apache не требует выпуска производных работ под той же лицензией.

\item {} 
\sphinxAtStartPar
Патенты: лицензия включает формулировку, связанную с патентами, что позволяет лицензиару предоставлять патентную лицензию пользователям программного обеспечения.

\item {} 
\sphinxAtStartPar
Ограниченная ответственность: лицензия включает отказ от ответственности, защищающий лицензиара от любых убытков, которые могут возникнуть в результате использования программного обеспечения.

\item {} 
\sphinxAtStartPar
Совместимость: лицензия Apache совместима со многими другими лицензиями с открытым исходным кодом, что позволяет легко комбинировать ее с другими проектами с открытым исходным кодом.

\end{itemize}

\sphinxAtStartPar
Таким образом, \sphinxstyleemphasis{\sphinxstylestrong{лицензия Apache}} — это разрешающая лицензия, которая обеспечивает баланс между защитой прав лицензиара и предоставлением пользователям возможности свободно использовать, модифицировать и распространять программное обеспечение. Она широко используется и пользуется уважением в сообществе открытого исходного кода.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{4. Лицензия BSD (Berkeley Software Distribution)}} — это разрешительная лицензия с открытым исходным кодом, которая позволяет использовать, модифицировать и распространять программное обеспечение с очень небольшими ограничениями. Некоторые из ключевых особенностей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Вседозволенность: лицензия \sphinxstyleemphasis{\sphinxstylestrong{BSD}} является одной из наиболее гибких разрешительных лицензий с открытым исходным кодом, допускающей широкий спектр вариантов использования, включая коммерческое.

\item {} 
\sphinxAtStartPar
Отсутствие авторского лева: в отличие от некоторых других лицензий с открытым исходным кодом, таких как \sphinxstyleemphasis{\sphinxstylestrong{GPL}}, лицензия \sphinxstyleemphasis{\sphinxstylestrong{BSD}} не требует выпуска производных работ под той же лицензией.

\item {} 
\sphinxAtStartPar
Простота: лицензия \sphinxstyleemphasis{\sphinxstylestrong{BSD}} короткая, простая и понятная, что делает ее популярным выбором среди разработчиков.

\item {} 
\sphinxAtStartPar
Ограниченная ответственность: лицензия включает отказ от ответственности, защищающий лицензиара от любых убытков, которые могут возникнуть в результате использования программного обеспечения.

\item {} 
\sphinxAtStartPar
Совместимость: лицензия BSD совместима со многими другими лицензиями с открытым исходным кодом, что позволяет легко комбинировать ее с другими проектами с открытым исходным кодом.

\end{itemize}

\sphinxAtStartPar
Таким образом, лицензия \sphinxstyleemphasis{\sphinxstylestrong{BSD}} является разрешающей лицензией, которая обеспечивает баланс между защитой прав лицензиара и разрешением пользователям свободно использовать, модифицировать и распространять программное обеспечение. Она также широко используется и пользуется уважением в сообществе открытого исходного кода.


\subsection{Какая лицензия ПО позволяет использовать исходный код для коммерческой разработки ПО?}
\label{\detokenize{educational_materials/open_license/content:id2}}
\sphinxAtStartPar
Многие лицензии с открытым исходным кодом, в том числе лицензия MIT, лицензия Apache и лицензия BSD, позволяют использовать исходный код для разработки коммерческого программного обеспечения. Эти лицензии являются разрешительными, то есть они накладывают очень мало ограничений на использование и распространение программного обеспечения. Пока вы соблюдаете условия, указанные в лицензии, вы можете свободно использовать код в коммерческих целях, в том числе включать его в проприетарные программные продукты.

\sphinxAtStartPar
Однако важно отметить, что разные лицензии могут иметь разные условия, такие как требования к установлению авторства или выпуску производных работ по одной и той же лицензии. Всегда полезно внимательно ознакомиться с условиями лицензии, прежде чем использовать код в коммерческом контексте.


\subsection{Какая лицензия ПО запрещает использование кода в коммерческих целях, для получения прибыли?}
\label{\detokenize{educational_materials/open_license/content:id3}}
\sphinxAtStartPar
Стандартная общественная лицензия (GPL) — это лицензия, которая позволяет коммерческое использование при условии, что исходный код будет открыт. GPL способствует совместному использованию и распространению бесплатного программного обеспечения, требуя, чтобы исходный код был доступен любому, кто получит копию программного обеспечения. Это гарантирует, что код остается открытым и доступным, а также поощряет сотрудничество и инновации в сообществе открытого исходного кода. GPL является лицензией с авторским левом, что означает, что любые производные работы также должны быть выпущены под той же лицензией, и что исходный код должен быть доступен любому, кто получит копию программного обеспечения.

\sphinxAtStartPar
Важно отметить, что GPL является лишь одной из многих лицензий с открытым исходным кодом, и не все лицензии с открытым исходным кодом имеют одинаковые ограничения на коммерческое использование. Некоторые лицензии, такие как лицензия MIT и лицензия BSD, являются разрешительными и накладывают очень мало ограничений на коммерческое использование.


\subsubsection{В чем отличие лицензий GPL от LGPL?}
\label{\detokenize{educational_materials/open_license/content:gpl-lgpl}}
\sphinxAtStartPar
Стандартная общественная лицензия (GPL) и Стандартная общественная лицензия ограниченного применения (LGPL) являются лицензиями на программное обеспечение с открытым исходным кодом, но у них есть некоторые ключевые отличия:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Копилефт, или авторское лево: GPL является сильной лицензией с авторским левом, что означает, что любые производные работы также должны быть выпущены под той же лицензией. LGPL, с другой стороны, является более слабой лицензией с авторским левом, которая позволяет выпускать производные работы под другой лицензией, пока исходный код LGPL остается неповрежденным и открытым.

\item {} 
\sphinxAtStartPar
Использование библиотек: LGPL была разработана специально для использования с библиотеками, что упрощает разработчикам использование кода под лицензией LGPL в своих собственных программных продуктах. С другой стороны, GPL больше подходит для автономных программных приложений.

\item {} 
\sphinxAtStartPar
Коммерческое использование: и GPL, и LGPL допускают коммерческое использование кода, но требования к предоставлению исходного кода и выпуску производных работ под одной и той же лицензией более строгие для кода под лицензией GPL.

\item {} 
\sphinxAtStartPar
Совместимость: GPL совместима с ограниченным набором других лицензий с открытым исходным кодом, в то время как LGPL более совместима с более широким спектром лицензий, включая разрешающие лицензии, такие как лицензия MIT и лицензия BSD.

\end{itemize}

\sphinxAtStartPar
Таким образом, GPL и LGPL являются лицензиями с открытым исходным кодом, но они имеют разные требования к авторскому леву и подходят для разных типов программных проектов. GPL больше подходит для автономных программных приложений, тогда как LGPL больше подходит для библиотек и других компонентов, которые могут использоваться в других программных проектах.


\subsection{Какие есть варианты использования лицензии GPL?}
\label{\detokenize{educational_materials/open_license/content:gpl}}
\sphinxAtStartPar
Стандартная общественная лицензия (GPL) — это популярная лицензия с открытым исходным кодом, которая предоставляет несколько вариантов использования программного обеспечения. Вот некоторые варианты.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Использование кода как есть: вы можете использовать код без внесения каких\sphinxhyphen{}либо изменений, если вы соблюдаете условия лицензии GPL, которая может включать требования об указании авторства или предоставлении доступа к исходному коду другим лицам.

\item {} 
\sphinxAtStartPar
Модификация кода: вы можете модифицировать код и использовать его в своих целях, но вы должны выпустить измененный код под той же лицензией GPL и сделать его доступным для других.

\item {} 
\sphinxAtStartPar
Распространение кода: вы можете распространять код как в его исходной форме, так и в виде измененной версии, но вы должны сделать исходный код доступным для всех, кто получит копию программного обеспечения.

\item {} 
\sphinxAtStartPar
Коммерческое использование: вы можете использовать код в коммерческих целях, но вы должны соблюдать условия лицензии GPL, которая может включать требования о предоставлении исходного кода другим лицам или о выпуске производных работ под той же лицензией.

\end{itemize}

\sphinxAtStartPar
Важно отметить, что лицензия GPL является строгой лицензией с авторским левом, что означает, что любые производные работы должны выпускаться под той же лицензией. Это может повлиять на распространение и использование проприетарного программного обеспечения, включающего код под лицензией GPL.

\sphinxAtStartPar
Таким образом, есть несколько вариантов использования программного обеспечения под лицензией GPL, включая использование кода как есть, изменение кода, распространение кода и его использование в коммерческих целях. Однако соблюдение условий лицензии, в том числе требований авторского лева, необходимо во всех случаях.


\bigskip\hrule\bigskip

\begin{quote}

\sphinxAtStartPar
Microsoft Windows является проприетарным программным обеспечением, а это означает, что оно не имеет открытого исходного кода, и его исходный код не является общедоступным. Microsoft владеет исключительными правами на код и контролирует, как его можно использовать и распространять. Microsoft предоставляет пользователям Windows лицензию на основании проприетарного лицензионного соглашения, в котором изложены условия использования программного обеспечения. Конкретное лицензионное соглашение для Windows может различаться в зависимости от версии Windows и типа пользователя, но в целом оно ограничивает использование программного обеспечения лицензированным устройством и запрещает несанкционированное копирование или распространение программного обеспечения.
\end{quote}


\subsection{Какая лицензия у ОС Android?}
\label{\detokenize{educational_materials/open_license/content:android}}
\sphinxAtStartPar
Операционная система Android — это программное обеспечение с открытым исходным кодом, выпущенное под лицензией Apache License 2.0. Apache License 2.0 — это разрешительная лицензия с открытым исходным кодом, которая позволяет пользователям использовать, изменять и распространять программное обеспечение, в том числе в коммерческих целях, без необходимости делать исходный код доступным для других.

\sphinxAtStartPar
В соответствии с лицензией Apache 2.0 пользователи должны включать копию лицензии и уведомление о любых изменениях, внесенных в исходный код. Лицензия также включает положения о патентной защите, которые помогают гарантировать, что пользователи программного обеспечения не будут привлечены к ответственности за нарушение патентных прав.

\sphinxAtStartPar
Таким образом, Android — это операционная система с открытым исходным кодом, выпущенная под лицензией Apache License 2.0, которая позволяет широко использовать, модифицировать и распространять программное обеспечение, обеспечивая при этом патентную защиту пользователей.
\begin{quote}

\sphinxAtStartPar
Google Chrome является проприетарным программным обеспечением, а это означает, что его исходный код не является общедоступным и контролируется Google. Google лицензирует Chrome для пользователей в соответствии с проприетарным лицензионным соглашением, в котором изложены условия использования программного обеспечения.
\end{quote}

\sphinxAtStartPar
Однако некоторые части браузера Chrome, в том числе проект с открытым исходным кодом Chromium, выпускаются под разрешительной лицензией BSD, которая позволяет использовать, модифицировать и распространять программное обеспечение как в коммерческих, так и в некоммерческих целях. Исходный код этих частей браузера находится в свободном доступе для всех желающих.

\sphinxAtStartPar
Таким образом, браузер Google Chrome является проприетарным программным обеспечением, но некоторые его компоненты, в том числе проект с открытым исходным кодом Chromium, выпускаются под лицензией BSD, что позволяет широко использовать, модифицировать и распространять программное обеспечение.


\subsection{Какую лицензию выбрать, если я хочу использовать чужой код в своем проекте?}
\label{\detokenize{educational_materials/open_license/content:id4}}
\sphinxAtStartPar
Выбор лицензии зависит от ваших конкретных потребностей и целей вашего проекта. Вот некоторые распространенные сценарии и типы лицензий, которые часто используются в каждом случае:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Если вы хотите использовать чужой код как часть проприетарного проекта с закрытым исходным кодом, вам следует искать лицензию, допускающую коммерческое использование, например, лицензию Apache 2.0 или лицензию BSD.

\item {} 
\sphinxAtStartPar
Если вы хотите использовать чужой код в проекте с открытым исходным кодом, но не хотите делиться своими изменениями с другими, вам следует искать разрешающую лицензию, такую как Apache License 2.0 или BSD.

\item {} 
\sphinxAtStartPar
Если вы хотите использовать чужой код в проекте с открытым исходным кодом и хотите убедиться, что любые изменения, которые вы вносите в код, также являются открытым исходным кодом, вам следует искать лицензию с авторским левом, например, лицензию GPL.

\item {} 
\sphinxAtStartPar
Если вы хотите использовать чужой код в проекте с открытым исходным кодом и хотите убедиться, что любые изменения, которые вы вносите в код, также являются открытым исходным кодом, но вы не хотите ограничивать использование кода в коммерческих приложениях, вам следует искать лицензию, такую как лицензия LGPL.

\item {} 
\sphinxAtStartPar
Важно внимательно прочитать положения и условия любой лицензии, которую вы рассматриваете, и при необходимости обратиться за юридической консультацией, чтобы убедиться, что вы понимаете требования и обязательства лицензии и что она соответствует вашим потребностям.

\end{itemize}

\sphinxAtStartPar
Таким образом, выбор лицензии на использование чужого кода в вашем проекте зависит от ваших конкретных потребностей и целей и может включать разрешительные лицензии, такие как лицензия Apache 2.0 или лицензия BSD, или лицензии с авторским левом, такие как лицензия GPL или LGPL.


\subsection{Несколько общих советов по лицензированию и защите прав разработчиков программного обеспечения}
\label{\detokenize{educational_materials/open_license/content:id5}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Выберите правильную лицензию: при выпуске программного обеспечения важно выбрать лицензию, которая соответствует вашим целям и ценностям. Рассмотрите доступные лицензии с открытым исходным кодом и подумайте, какое использование вы хотите разрешить и какие ограничения вы хотите наложить на пользователей вашего кода.

\item {} 
\sphinxAtStartPar
Прочтите и поймите лицензию: прежде чем использовать чужой код в своем проекте, обязательно прочтите и полностью поймите условия лицензии. Убедитесь, что вы соблюдаете лицензионные требования, включая любые обязательства по атрибуции или совместному использованию, и помните о любых ограничениях на использование или распространение.

\item {} 
\sphinxAtStartPar
Защитите свою интеллектуальную собственность. Если вы разработали программное обеспечение, которое вы считаете проприетарным, примите меры для защиты своей интеллектуальной собственности, например, подайте заявку на патенты, товарные знаки или авторские права. Подумайте о том, чтобы обратиться за консультацией к юристу, если у вас есть вопросы или опасения по поводу защиты ваших прав.

\item {} 
\sphinxAtStartPar
Помните о сторонних лицензиях: при использовании стороннего кода в вашем проекте помните о лицензиях используемых вами компонентов и убедитесь, что вы соблюдаете условия этих лицензий. Если вы распространяете программный продукт, будьте прозрачны в отношении используемых вами лицензий и включите необходимые уведомления и указания авторства.

\item {} 
\sphinxAtStartPar
Общайтесь со своим сообществом: если вы выпускаете программное обеспечение с открытым исходным кодом, взаимодействуйте со своим сообществом и открыто сообщайте о своих намерениях и целях. Поощряйте вклад и сотрудничество и помните о правах и интересах других участников.

\item {} 
\sphinxAtStartPar
Будьте в курсе последних событий. Лицензирование программного обеспечения и законодательство об интеллектуальной собственности могут со временем меняться, поэтому важно быть в курсе последних разработок и передового опыта в этой области. Рассмотрите возможность вступления в соответствующие организации и профессиональные сообщества и ищите ресурсы и информацию, которые помогут вам быть в курсе.

\end{enumerate}

\sphinxAtStartPar
Таким образом, выбор правильной лицензии, понимание условий лицензии, защита вашей интеллектуальной собственности, соблюдение сторонних лицензий, общение с вашим сообществом и отслеживание последних событий — все это важные факторы, которые следует учитывать, когда речь идет о лицензировании и защите прав разработчиков программного обеспечения.


\subsection{Интересный вопрос: кому принадлежат права на результат работы искусственного интеллекта?}
\label{\detokenize{educational_materials/open_license/content:id6}}
\sphinxAtStartPar
Право собственности на результат работы искусственного интеллекта — сложный вопрос, и ответы на него могут быть разными в зависимости от юрисдикции и конкретных обстоятельств.

\sphinxAtStartPar
Как правило, создатель или владелец системы ИИ будет владеть правами на результат, созданный системой. Однако выходные данные также могут быть защищены авторским правом или другими формами защиты интеллектуальной собственности. В некоторых случаях результат может считаться работой по найму, а владелец системы ИИ будет считаться автором и владельцем авторских прав на результат.

\sphinxAtStartPar
Однако есть также случаи, когда результат системы ИИ не может считаться охраняемым произведением в соответствии с законом об авторском праве, например, когда он носит чисто фактический или функциональный характер.

\sphinxAtStartPar
Важно отметить, что законы и правила, касающиеся ИИ и прав интеллектуальной собственности, все еще развиваются и могут различаться в разных юрисдикциях. Если у вас есть конкретные вопросы или опасения по поводу владения правами на результат работы ИИ, целесообразно обратиться за консультацией к юристу.

\sphinxAtStartPar
Во многих юрисдикциях законы, регулирующие ИИ и права интеллектуальной собственности, все еще находятся в процессе развития. Это может затруднить определение того, кому принадлежат права на результат работы ИИ.

\sphinxAtStartPar
В некоторых случаях может быть необходимо учитывать такие факторы, как степень человеческого творчества и авторства в создании выходных данных ИИ, или был ли результат создан системой ИИ автономно.

\sphinxAtStartPar
В некоторых случаях также может быть необходимо рассмотреть вопросы ответственности при возникновения проблем или ошибок в системе ИИ или ее выходных данных. Например, если система ИИ используется для получения юридических или медицинских рекомендаций, могут возникнуть вопросы о том, кто несет ответственность за ошибки или неточности в предоставленных рекомендациях.

\sphinxAtStartPar
В некоторых случаях можно договориться о лицензиях или других соглашениях, позволяющих использовать результаты ИИ в определенных обстоятельствах или для определенных целей.


\chapter{GitHub Pages}
\label{\detokenize{index:github-pages}}
\sphinxstepscope


\section{Github Pages}
\label{\detokenize{educational_materials/github_pages/content:github-pages}}\label{\detokenize{educational_materials/github_pages/content::doc}}
\sphinxAtStartPar
\sphinxincludegraphics{{bfbf2eb24fd001dcda5daf4c32d84ff677aaff9f}.png}

\sphinxAtStartPar
GitHub Pages — это служба веб\sphinxhyphen{}хостинга, предоставляемая GitHub, которая позволяет пользователям бесплатно размещать статические веб\sphinxhyphen{}сайты. Пользователи могут создать репозиторий на GitHub, содержащий файлы HTML, CSS и JavaScript своего веб\sphinxhyphen{}сайта, а затем GitHub Pages автоматически создаст и развернет веб\sphinxhyphen{}сайт на основе содержимого репозитория.

\sphinxAtStartPar
GitHub Pages поддерживает несколько генераторов статических сайтов, таких как Jekyll, Hugo и Gatsby, которые упрощают создание профессионально выглядящих веб\sphinxhyphen{}сайтов без необходимости написания всего кода HTML и CSS с нуля. Кроме того, GitHub Pages поддерживает пользовательские домены, поэтому пользователи могут использовать собственное доменное имя вместо домена username.github.io по умолчанию.

\sphinxAtStartPar
GitHub Pages также поддерживает управление версиями, что означает, что пользователи могут отслеживать изменения на своем веб\sphinxhyphen{}сайте с течением времени и в сотрудничестве с другими работать над одной и той же кодовой базой. Это делает его идеальным выбором для разработчиков, блоггеров и представителей малого бизнеса, которые хотят быстро и легко создать веб\sphinxhyphen{}сайт, не беспокоясь о настройке или обслуживании сервера.

\sphinxAtStartPar
\sphinxstylestrong{Как устроен сервис GitHub Pages?}
GitHub Pages работает, размещая статические файлы на серверах GitHub и обслуживая их через Интернет. Вот общий обзор того, как это работает:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Создайте репозиторий GitHub. В первую очередь вам нужно создать новый репозиторий на GitHub или использовать существующий. Этот репозиторий будет содержать исходный код вашего веб\sphinxhyphen{}сайта, включая HTML, CSS, JavaScript и любые другие активы, которые вы хотите включить.

\item {} 
\sphinxAtStartPar
Выберите способ публикации. Вы можете выбрать один из двух способов публикации своего веб\sphinxhyphen{}сайта на страницах GitHub. Первый — создать отдельную ветку в вашем репозитории под названием gh\sphinxhyphen{}pages, где вы храните собранную версию своего веб\sphinxhyphen{}сайта. Второй способ — хранить файлы вашего веб\sphinxhyphen{}сайта в папке docs в основной ветке вашего репозитория.

\item {} 
\sphinxAtStartPar
Настройте конфигурацию вашего веб\sphinxhyphen{}сайта: вам необходимо создать файл конфигурации для вашего веб\sphinxhyphen{}сайта, который сообщает GitHub Pages, как создавать и обслуживать ваш веб\sphinxhyphen{}сайт. Файл конфигурации может включать такую информацию, как используемый вами генератор статических сайтов, URL\sphinxhyphen{}адрес вашего личного домена (если он у вас есть) и любые другие параметры, которые вы хотите настроить.

\item {} 
\sphinxAtStartPar
Создайте свой веб\sphinxhyphen{}сайт: с помощью предпочитаемого вами генератора статических сайтов вы можете создавать файлы HTML, CSS и JavaScript для своего веб\sphinxhyphen{}сайта. При необходимости вы можете добавить дополнительные функции, такие как пользовательские шрифты, изображения и другие ресурсы.

\item {} 
\sphinxAtStartPar
Отправьте внесенные изменения на GitHub: после того, как вы создали свой веб\sphinxhyphen{}сайт, вы можете отправить внесенные изменения в свой репозиторий GitHub. В зависимости от вашего метода публикации GitHub Pages автоматически создаст и развернет ваш веб\sphinxhyphen{}сайт на своих серверах.

\item {} 
\sphinxAtStartPar
Просмотрите свой веб\sphinxhyphen{}сайт: после того, как GitHub Pages завершит создание и развертывание вашего веб\sphinxhyphen{}сайта, вы сможете просмотреть его, посетив URL\sphinxhyphen{}адрес, предоставленный GitHub (например, https://username.github.io/repo\sphinxhyphen{}name или ваш личный домен, если у вас есть один).

\end{enumerate}

\sphinxAtStartPar
В целом, GitHub Pages — это простой и удобный способ размещения статических веб\sphinxhyphen{}сайтов, и он может стать отличным выбором для разработчиков, блоггеров и других лиц, которые хотят быстро запустить веб\sphinxhyphen{}сайт, не беспокоясь о настройке или обслуживании сервера.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Какова цель проекта GitHub Pages?}
Цель GitHub Pages — предоставить пользователям простой и бесплатный способ размещения статических веб\sphinxhyphen{}сайтов непосредственно из их репозиториев GitHub. Проект предназначен для того, чтобы пользователи могли легко создавать и публиковать свои собственные веб\sphinxhyphen{}сайты и делиться ими, не беспокоясь о настройке сервера, настройке программного обеспечения для веб\sphinxhyphen{}хостинга или оплате услуг хостинга.

\sphinxAtStartPar
\sphinxstylestrong{GitHub Pages можно использовать для различных целей, например:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Личные веб\sphinxhyphen{}сайты и блоги. GitHub Pages можно использовать для создания личных веб\sphinxhyphen{}сайтов или блогов, где пользователи могут делиться информацией о себе, своих интересах или своей работе.

\item {} 
\sphinxAtStartPar
Документация и учебные пособия. GitHub Pages можно использовать для размещения технической документации, учебных пособий или других типов учебных материалов.

\item {} 
\sphinxAtStartPar
Веб\sphinxhyphen{}сайты проектов. GitHub Pages можно использовать для создания веб\sphinxhyphen{}сайтов для проектов с открытым исходным кодом, предоставляя информацию о проекте, его участниках и его функциях.

\item {} 
\sphinxAtStartPar
Портфолио и резюме. GitHub Pages можно использовать для создания онлайн\sphinxhyphen{}портфолио или резюме, демонстрирующих навыки, опыт и достижения пользователя.

\item {} 
\sphinxAtStartPar
Веб\sphinxhyphen{}сайты для малого бизнеса. GitHub Pages можно использовать для создания простых веб\sphinxhyphen{}сайтов для малого бизнеса, предоставляющих информацию о бизнесе, его продуктах или услугах, а также его контактную информацию.

\end{itemize}

\sphinxAtStartPar
В целом, цель сервиса GitHub Pages — упростить пользователям создание и совместное использование собственных веб\sphinxhyphen{}сайтов, будь то в личных, образовательных или профессиональных целях, без необходимости освоения передовых технических навыков или использования дорогостоящих услуг хостинга.

\sphinxAtStartPar
\sphinxstylestrong{Как программисты используют сервис GitHub Pages?}
Программисты могут использовать GitHub Pages для создания и размещения статических веб\sphinxhyphen{}сайтов несколькими способами, в том числе:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Создание портфолио. Программисты могут использовать GitHub Pages для создания веб\sphinxhyphen{}сайта портфолио, демонстрирующего их проекты, навыки и опыт. Они могут использовать свой репозиторий GitHub для хранения исходного кода своего портфолио и использовать генератор статических сайтов, такой как Jekyll или Hugo, для создания веб\sphinxhyphen{}сайта.

\item {} 
\sphinxAtStartPar
Создание блога. Программисты могут использовать страницы GitHub для создания блога, где они делятся своими идеями, мнениями и знаниями с другими. Они могут использовать генератор статических сайтов, такой как Jekyll или Gatsby, для создания блога и сохранения сообщений в своем репозитории GitHub.

\item {} 
\sphinxAtStartPar
Размещение документации. Программисты могут использовать GitHub Pages для размещения технической документации по своим проектам, что упрощает поиск и использование документации другими пользователями. Они могут использовать генератор статических сайтов, такой как Sphinx или DocFX, для создания документации и сохранения ее в своем репозитории GitHub.

\item {} 
\sphinxAtStartPar
Обмен примерами кода. Программисты могут использовать GitHub Pages для обмена примерами кода или фрагментами кода, предоставляя полезный ресурс для тех, кто учится программировать. Они могут использовать генератор статических сайтов, такой как Jekyll или Gatsby, для создания веб\sphinxhyphen{}сайта и сохранения примеров кода в своем репозитории GitHub.

\item {} 
\sphinxAtStartPar
Создание веб\sphinxhyphen{}сайта проекта. Программисты могут использовать GitHub Pages для создания веб\sphinxhyphen{}сайта для своих проектов с открытым исходным кодом, предоставляя информацию о проекте, его участниках и его функциях. Они могут использовать генератор статических сайтов, такой как Jekyll или Gatsby, для создания веб\sphinxhyphen{}сайта и сохранения исходного кода в своем репозитории GitHub.

\item {} 
\sphinxAtStartPar
В целом, программисты могут использовать GitHub Pages для создания и размещения широкого спектра статических веб\sphinxhyphen{}сайтов, что делает его полезным инструментом для обмена информацией, продвижения своей работы и вовлечения в более широкое сообщество программистов.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Как создать страницу портфолио на страницах GitHub?}
Чтобы создать страницу портфолио на GitHub Pages, нужно выполнить следующие шаги:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Создайте новый репозиторий на GitHub: войдите в свою учетную запись GitHub и создайте новый репозиторий для страницы своего портфолио. Вы можете назвать его по аналогии с  «username.github.io», где «username» — это ваше имя пользователя GitHub.

\item {} 
\sphinxAtStartPar
Создайте новую ветку или папку «docs»: в зависимости от ваших предпочтений, вы можете либо создать новую ветку с именем «gh\sphinxhyphen{}pages», либо создать папку «docs» в своей основной ветке, где будут храниться файлы вашего веб\sphinxhyphen{}сайта портфолио.

\item {} 
\sphinxAtStartPar
Выберите генератор статического сайта: вы можете использовать генератор статического сайта, такой как Jekyll, Hugo или Gatsby, для создания своего веб\sphinxhyphen{}сайта\sphinxhyphen{}портфолио. Эти генераторы позволяют создавать шаблоны для вашего веб\sphinxhyphen{}сайта и автоматически генерировать статические файлы HTML, CSS и JavaScript.

\item {} 
\sphinxAtStartPar
Создайте свой веб\sphinxhyphen{}сайт\sphinxhyphen{}портфолио. После того, как вы выбрали генератор статических сайтов, вы можете приступить к созданию своего веб\sphinxhyphen{}сайта\sphinxhyphen{}портфолио, настроив шаблоны и добавив свой собственный контент: ваша биография, проекты, навыки и опыт. Вы также можете добавлять изображения, видео и другие медиафайлы, чтобы сделать ваше портфолио более привлекательным.

\item {} 
\sphinxAtStartPar
Отправляйте изменения на GitHub. Создав веб\sphinxhyphen{}сайт портфолио, вы можете отправить изменения в репозиторий GitHub. В зависимости от вашего метода публикации, GitHub Pages автоматически создаст и развернет ваш веб\sphinxhyphen{}сайт на своих серверах.

\item {} 
\sphinxAtStartPar
Просмотр веб\sphinxhyphen{}сайта вашего портфолио: после того, как GitHub Pages завершит создание и развертывание веб\sphinxhyphen{}сайта вашего портфолио, вы сможете просмотреть его, посетив URL\sphinxhyphen{}адрес, предоставленный GitHub (например, https://username.github.io).

\end{enumerate}

\sphinxAtStartPar
В целом, создание страницы портфолио на GitHub Pages включает в себя настройку репозитория, выбор генератора статических сайтов, создание веб\sphinxhyphen{}сайта и его публикацию на GitHub Pages. Используя правильные инструменты и немного творчества, вы можете создать профессионально выглядящее портфолио, демонстрирующее ваши навыки и опыт программиста.

\sphinxAtStartPar
Вот пример HTML\sphinxhyphen{}страницы для портфолио на GitHub Pages.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}!DOCTYPE html\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{html} \PYG{n+na}{lang}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}en\PYGZdq{}}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{meta} \PYG{n+na}{charset}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{meta} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}viewport\PYGZdq{}} \PYG{n+na}{content}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}width=device\PYGZhy{}width, initial\PYGZhy{}scale=1.0\PYGZdq{}}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{title}\PYG{p}{\PYGZgt{}}My Portfolio\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{title}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{header}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}}My Portfolio\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{nav}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}about\PYGZdq{}}\PYG{p}{\PYGZgt{}}About Me\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}projects\PYGZdq{}}\PYG{p}{\PYGZgt{}}Projects\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}skills\PYGZdq{}}\PYG{p}{\PYGZgt{}}Skills\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}contact\PYGZdq{}}\PYG{p}{\PYGZgt{}}Contact\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{nav}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{header}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{main}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}about\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}About Me\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Hi, I\PYGZsq{}m Ivan Ivanov, a web developer based in Moscow. I specialize in building responsive websites using HTML, CSS, and JavaScript.\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}projects\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Projects\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}Project 1\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}Project 2\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}Project 3\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}skills\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Skills\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}HTML\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}CSS\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}JavaScript\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}jQuery\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}Bootstrap\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}contact\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Contact\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{form}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{\PYGZgt{}}Name:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{input} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}text\PYGZdq{}} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}}\PYG{p}{\PYGZgt{}}Email:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{input} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}}\PYG{p}{\PYGZgt{}}Message:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{textarea} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{textarea}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{button} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}submit\PYGZdq{}}\PYG{p}{\PYGZgt{}}Send\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{button}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{form}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{main}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{footer}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Copyright \PYG{n+ni}{\PYGZam{}copy;} 2023 Ivan Ivanov\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{footer}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{html}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Этот пример HTML\sphinxhyphen{}страницы включает заголовок с меню навигации, основной раздел с информацией о владельце портфолио (в разделе «Обо мне»), раздел, посвященный прошлым проектам, раздел, в котором перечислены соответствующие навыки, и раздел контактов с формой для отправки сообщения. Нижний колонтитул содержит уведомление об авторских правах. Вы можете настроить этот пример кода в соответствии со своими потребностями и предпочтениями.

\sphinxAtStartPar
Вот пример HTML\sphinxhyphen{}страницы с CSS и JavaScript для портфолио на GitHub Pages:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}!DOCTYPE html\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{html} \PYG{n+na}{lang}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}en\PYGZdq{}}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{meta} \PYG{n+na}{charset}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{meta} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}viewport\PYGZdq{}} \PYG{n+na}{content}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}width=device\PYGZhy{}width, initial\PYGZhy{}scale=1.0\PYGZdq{}}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{title}\PYG{p}{\PYGZgt{}}My Portfolio\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{title}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{link} \PYG{n+na}{rel}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}stylesheet\PYGZdq{}} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}style.css\PYGZdq{}}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{header}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}}My Portfolio\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{nav}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}about\PYGZdq{}}\PYG{p}{\PYGZgt{}}About Me\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}projects\PYGZdq{}}\PYG{p}{\PYGZgt{}}Projects\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}skills\PYGZdq{}}\PYG{p}{\PYGZgt{}}Skills\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}contact\PYGZdq{}}\PYG{p}{\PYGZgt{}}Contact\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{nav}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{header}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{main}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}about\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}About Me\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{img} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}profile.jpg\PYGZdq{}} \PYG{n+na}{alt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Profile Picture\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Hi, I\PYGZsq{}m John Doe, a web developer based in San Francisco. I specialize in building responsive websites using HTML, CSS, and JavaScript.\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}projects\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Projects\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{div} \PYG{n+na}{class}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{img} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project1.jpg\PYGZdq{}} \PYG{n+na}{alt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Project 1\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}Project 1\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla vitae felis quis diam suscipit rhoncus. Ut dapibus purus in massa maximus gravida. Fusce ut nunc vitae nulla tincidunt volutpat sed ut mauris.\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}View Project\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{div}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{div} \PYG{n+na}{class}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{img} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project2.jpg\PYGZdq{}} \PYG{n+na}{alt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Project 2\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}Project 2\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla vitae felis quis diam suscipit rhoncus. Ut dapibus purus in massa maximus gravida. Fusce ut nunc vitae nulla tincidunt volutpat sed ut mauris.\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}View Project\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{div}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{div} \PYG{n+na}{class}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{img} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}project3.jpg\PYGZdq{}} \PYG{n+na}{alt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Project 3\PYGZdq{}}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}Project 3\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h3}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla vitae felis quis diam suscipit rhoncus. Ut dapibus purus in massa maximus gravida. Fusce ut nunc vitae nulla tincidunt volutpat sed ut mauris.\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{a} \PYG{n+na}{href}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}\PYGZdq{}}\PYG{p}{\PYGZgt{}}View Project\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{a}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{div}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}skills\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Skills\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}HTML\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}CSS\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}JavaScript\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}jQuery\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}Bootstrap\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{li}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{ul}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{section} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}contact\PYGZdq{}}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}Contact\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h2}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{n+nt}{form}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{\PYGZgt{}}Name:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{input} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}text\PYGZdq{}} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}}\PYG{p}{\PYGZgt{}}Email:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{input} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}email\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{label} \PYG{n+na}{for}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}}\PYG{p}{\PYGZgt{}}Message:\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{label}\PYG{p}{\PYGZgt{}}
                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{textarea} \PYG{n+na}{id}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}} \PYG{n+na}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}message\PYGZdq{}}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{textarea}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{n+nt}{br}\PYG{p}{\PYGZgt{}}

                \PYG{p}{\PYGZlt{}}\PYG{n+nt}{button} \PYG{n+na}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}submit\PYGZdq{}}\PYG{p}{\PYGZgt{}}Send\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{button}\PYG{p}{\PYGZgt{}}
            \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{form}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{section}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{main}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{n+nt}{footer}\PYG{p}{\PYGZgt{}}
        \PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}Copyright \PYG{n+ni}{\PYGZam{}copy;} 2023 Ivan Ivanov\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
    \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{footer}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{html}\PYG{p}{\PYGZgt{}}S
\end{sphinxVerbatim}


\subsection{С какой целью используют сервис GitHub Pages?}
\label{\detokenize{educational_materials/github_pages/content:id1}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Демонстрация своих проектов: разработчики и дизайнеры могут использовать GitHub Pages для демонстрации своей работы и проектов профессионально и легко доступным образом. Это может быть отличным способом привлечь потенциальных клиентов, сотрудников или работодателей.

\item {} 
\sphinxAtStartPar
Размещение личных веб\sphinxhyphen{}сайтов/блогов: GitHub Pages также можно использовать для размещения личных веб\sphinxhyphen{}сайтов или блогов, позволяя людям делиться своими мыслями, опытом и знаниями с другими.

\item {} 
\sphinxAtStartPar
Документация: разработчики могут использовать GitHub Pages для размещения документации по своим проектам, чтобы другим было проще понять их работу и внести свой вклад в нее.

\item {} 
\sphinxAtStartPar
Что касается поиска работы или интересных проектов, GitHub Pages, безусловно, также может помочь. Наличие хорошо разработанного и профессионально выглядящего веб\sphinxhyphen{}сайта портфолио может произвести отличное первое впечатление на потенциальных работодателей или сотрудников. Кроме того, GitHub Pages позволяют разработчикам демонстрировать свои навыки и вклад в проекты с открытым исходным кодом, что может помочь привлечь внимание потенциальных работодателей или сотрудников.

\end{enumerate}


\subsection{Преимущества и недостатки сервиса GitHub Pages}
\label{\detokenize{educational_materials/github_pages/content:id2}}

\subsubsection{Преимущества:}
\label{\detokenize{educational_materials/github_pages/content:id3}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Бесплатный хостинг: GitHub Pages предлагает бесплатный хостинг для статических веб\sphinxhyphen{}сайтов, что делает его доступным вариантом для частных лиц или малого бизнеса.

\item {} 
\sphinxAtStartPar
Простота настройки: создать веб\sphinxhyphen{}сайт GitHub Pages относительно легко и просто, особенно для тех, кто уже знаком с Git и GitHub.

\item {} 
\sphinxAtStartPar
Пользовательские домены: GitHub Pages позволяет пользователям использовать свое собственное доменное имя, что может помочь сделать их веб\sphinxhyphen{}сайт более профессиональным.

\item {} 
\sphinxAtStartPar
Совместная работа: GitHub Pages построен на основе Git и GitHub, что упрощает совместную работу нескольких людей над веб\sphinxhyphen{}сайтом.

\item {} 
\sphinxAtStartPar
Интеграция с другими сервисами: GitHub Pages можно легко интегрировать с другими сервисами, такими как Jekyll, популярный генератор статических сайтов.

\end{enumerate}


\subsubsection{Недостатки:}
\label{\detokenize{educational_materials/github_pages/content:id4}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Ограниченная функциональность: GitHub Pages предназначен только для размещения статических веб\sphinxhyphen{}сайтов, что означает, что он может не подходить для более сложных веб\sphinxhyphen{}сайтов или веб\sphinxhyphen{}приложений.

\item {} 
\sphinxAtStartPar
Ограниченный контроль: поскольку GitHub Pages является службой размещения, пользователи имеют ограниченный контроль над серверной средой и конфигурацией.

\item {} 
\sphinxAtStartPar
Ограниченное хранилище: GitHub Pages имеет ограничение хранилища в 1 ГБ на учетную запись, чего может быть недостаточно для крупных веб\sphinxhyphen{}сайтов.

\item {} 
\sphinxAtStartPar
Кривая обучения: несмотря на то, что GitHub Pages относительно прост в настройке, для пользователей, незнакомых с Git и GitHub, все же может потребоваться кривая обучения.

\item {} 
\sphinxAtStartPar
Ограниченная поддержка: поскольку GitHub Pages является бесплатным сервисом, для пользователей, сталкивающихся с проблемами или проблемами, доступна только ограниченная поддержка.

\end{enumerate}

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/github_pages/exercises:id1}}\label{\detokenize{educational_materials/github_pages/exercises::doc}}
\sphinxAtStartPar
Составьте страницу учебного проекта чат\sphinxhyphen{}бота «EducationBot» на GitPage, который позволяет получать информацию об олимпиадах, конкурсах и событиях в мире образования. Ниже представлен шаблон страницы в формате Markdown. Стили и графическое оформление выберите на свое усмотрение.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Добро пожаловать на официальную страницу проекта EducationBot! Наш чат\PYGZhy{}бот создан с целью помочь вам получать актуальную информацию о различных образовательных событиях, олимпиадах, конкурсах и мероприятиях в образовательной сфере.

\PYGZsh{}\PYGZsh{}\PYGZsh{} Как пользоваться EducationBot?

EducationBot предоставляет простой и интуитивно понятный интерфейс для получения информации. Просто напишите боту интересующий вас вопрос или выберите одну из предложенных категорий:

\PYGZhy{} Олимпиады
\PYGZhy{} Конкурсы
\PYGZhy{} Мероприятия
\PYGZhy{} Анонсы

Выберите нужную категорию и получите актуальные новости и события из образовательного мира.

\PYGZsh{}\PYGZsh{}\PYGZsh{} Основные функции:

\PYGZhy{} Получение информации об олимпиадах, конкурсах, мероприятиях и анонсах в мире образования
\PYGZhy{} Актуальные новости и события в реальном времени
\PYGZhy{} Поддержка различных категорий и фильтров для удобного поиска информации

\PYGZsh{}\PYGZsh{}\PYGZsh{} О проекте:

EducationBot разрабатывается как pet\PYGZhy{}project учебного проекта. Целью проекта является изучение и применение основ программирования на языке Python, работы с API и создание простого, но полезного чат\PYGZhy{}бота для образовательного сообщества.

\PYGZsh{}\PYGZsh{}\PYGZsh{} Как связаться с нами?

Если у вас есть вопросы или предложения по улучшению EducationBot, не стесняйтесь связаться с нами:

\PYGZhy{} Email: educationbot@example.com
\PYGZhy{} Telegram: @EducationBotSupport

\PYGZsh{}\PYGZsh{}\PYGZsh{} Статус проекта:

EducationBot находится в стадии разработки MVP (Minimum Viable Product). Мы стремимся создать функциональный и удобный чат\PYGZhy{}бот для пользователей и всегда открыты для обратной связи и предложений.

\PYGZsh{}\PYGZsh{}\PYGZsh{} Лицензия:

Проект EducationBot распространяется по лицензии MIT. Вы можете свободно использовать и изменять код проекта с указанием авторства.

\PYGZsh{}\PYGZsh{}\PYGZsh{} Установка и запуск:

Если вы хотите развернуть EducationBot на своем сервере, следуйте инструкциям в разделе [Installation Guide](/docs/installation.md).

\PYGZsh{}\PYGZsh{}\PYGZsh{} Помощь в разработке:

Если вы хотите внести свой вклад в развитие проекта, ознакомьтесь с разделом [Contribution Guidelines](/docs/contributing.md) и присоединяйтесь к нашей команде разработчиков.

Мы надеемся, что EducationBot будет полезен для всех, кто интересуется образованием и стремится быть в курсе всех актуальных событий. Благодарим вас за поддержку нашего проекта!

\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/github_pages/quiz:id1}}\label{\detokenize{educational_materials/github_pages/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое GitPages и какова его роль в системах контроля версий?

\item {} 
\sphinxAtStartPar
Как создать GitPages?

\item {} 
\sphinxAtStartPar
В чем разница между GitPages и другими популярными платформами для размещения веб\sphinxhyphen{}сайтов?

\item {} 
\sphinxAtStartPar
Как развернуть статический веб\sphinxhyphen{}сайт с использованием GitPages?

\item {} 
\sphinxAtStartPar
Можно ли иметь несколько GitPages для разных веток в одном репозитории? Если да, как это настроить?

\item {} 
\sphinxAtStartPar
Какой максимальный размер репозитория для GitPages?

\item {} 
\sphinxAtStartPar
Как настроить пользовательскую тему для вашего веб\sphinxhyphen{}сайта GitPages?

\item {} 
\sphinxAtStartPar
Опишите процесс обновления вашего веб\sphinxhyphen{}сайта GitPages после внесения изменений в репозиторий.

\item {} 
\sphinxAtStartPar
Можно ли размещать веб\sphinxhyphen{}сайт с динамическим контентом с использованием GitPages? Почему да или почему нет?

\item {} 
\sphinxAtStartPar
Как ограничить доступ к вашему веб\sphinxhyphen{}сайту GitPages и разрешить просмотр только определенным пользователям?

\item {} 
\sphinxAtStartPar
Что такое тема Jekyll и как ее использовать для настройки внешнего вида вашего веб\sphinxhyphen{}сайта GitPages?

\item {} 
\sphinxAtStartPar
Как включить HTTPS для вашего веб\sphinxhyphen{}сайта GitPages?

\item {} 
\sphinxAtStartPar
Можно ли использовать GitPages для размещения частных репозиториев? Почему да или почему нет?

\item {} 
\sphinxAtStartPar
Как включить непрерывное развертывание с помощью GitPages?

\item {} 
\sphinxAtStartPar
Опишите процесс настройки пользовательской страницы ошибки 404 для вашего веб\sphinxhyphen{}сайта GitPages.

\end{enumerate}


\chapter{Раздел 3. Инструменты разработки}
\label{\detokenize{index:id11}}

\chapter{Виртуальное окружение}
\label{\detokenize{index:id12}}
\sphinxstepscope


\section{Знакомство с рабочим окружением}
\label{\detokenize{educational_materials/path_venv/content:id1}}\label{\detokenize{educational_materials/path_venv/content::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{Path — пути к системному окружению. Создание виртуального окружения venv для проекта.}

\sphinxAtStartPar
\sphinxincludegraphics{{path_view_discover_virtual_environments}.png}
\begin{quote}

\sphinxAtStartPar
Знакомимся с темой рабочего окружения. Что это такое? Начнем с рабочего окружения Windows и перейдем к созданию отдельных окружений для проектов Python. Научимся переключаться между локальным и глобальным окружениями. Разберемся почему это важно, а также узнаем, как легко и просто поделиться проектом с другими разработчиками, используя виртуальное рабочее окружение, и как это помогает экономить трафик и управлять размером проекта.
\end{quote}

\sphinxAtStartPar
После запуска операционной системы пользователю доступны различные инструменты, как системные (входящие в состав ОС), так и сторонние (установленные дополнительно). Часто в процессе работы возникает необходимость использования командной строки для вызова различных утилит, помогающих в процессе работы. Например, в случае, когда браузеру не удается открыть страницу удаленного веб\sphinxhyphen{}сервиса: зайти на почту или открыть новостную ленту, мы можем наблюдать следующую ошибку — «404 NotFound». Чтобы определить, на чьей стороне ошибка: вашей сети или удаленного сервера, часто используют системные утилиты, консоли для работы с сетью. Такие как PING, IPCONFIG, ARP, NETSTAT и т.д. Например, вызовем утилиту ping с параметром «www.ya.ru», чтобы проверить наличие связи с серверами. Если в окно терминала в Windows ввести команду «explorer», откроется графическое окно.

\sphinxAtStartPar
\sphinxincludegraphics{{path_view_result_ping}.png}

\sphinxAtStartPar
Рисунок 1 — Терминал с результатом работы команды ping.

\sphinxAtStartPar
\sphinxstylestrong{Как это работает?}
Дело в том, что операционная система (ОС) ищет введенную команду в рабочем окружении системы. В случае ОС Windows это объект \sphinxcode{\sphinxupquote{PATH}}. В этом объекте хранятся все пути, по которым выполняется поиск исполняемых файлов.
Чтобы посмотреть содержание \sphinxcode{\sphinxupquote{PATH}}, достаточно ввести в окно командной строки:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo}\PYG{+w}{ }\PYGZpc{}PATH\PYGZpc{}
\end{sphinxVerbatim}

\sphinxAtStartPar
На рисунке 2 видно, что в окне терминала отобразилось множество путей к различным программам, не входящим в состав ОС Windows. Все они разделены символом точка с запятой «;». Одним из таких программ является интерпретатор языка программирования Python.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYG{l+s+se}{\PYGZbs{}P}ython39\PYG{l+s+se}{\PYGZbs{}S}cripts\PYG{l+s+se}{\PYGZbs{};}\PYG{+w}{ }C:\PYG{l+s+se}{\PYGZbs{}P}ython39\PYG{l+s+se}{\PYGZbs{};}
\end{sphinxVerbatim}

\sphinxAtStartPar
Таким образом, интерпретатор команд консоли Windows «понимает», по какому пути ему обратиться в случае ввода в окно терминала python. Во время установки Python предлагает установить галочку «AddPythontoPATH» (Рисунок 3).

\sphinxAtStartPar
\sphinxincludegraphics{{path_view_result_echo_path}.png}

\sphinxAtStartPar
Рисунок 2 — Терминал с результатом работы команды \sphinxcode{\sphinxupquote{echo \%PATH\%}}

\sphinxAtStartPar
\sphinxincludegraphics{{path_view_add_path_system_environment}.png}

\sphinxAtStartPar
Рисунок 3 — Окно установки Python с опцией записи в системное окружение \sphinxcode{\sphinxupquote{PATH}}


\subsection{Добавить директорию в PATH}
\label{\detokenize{educational_materials/path_venv/content:path}}
\sphinxAtStartPar
В Windows 10 можно добраться до настройки \sphinxcode{\sphinxupquote{PATH}} следующим образом:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Мой компьютер \(\rightarrow\) Свойства \(\rightarrow\) Дополнительные параметры системы \(\rightarrow\) Дополнительно \(\rightarrow\) Переменные среды.}}

\sphinxAtStartPar
Или вызовом «Изменение переменных среды текущего пользователя» в результатах поиска.
В окошке «Переменные среды» в блоке «Переменные среды пользователя \%USERNAME\%» находим строку \sphinxcode{\sphinxupquote{PATH}}, выделяем кликом, нажимаем кнопку «Изменить…» и в появившемся окошке нажимаем «Создать» для добавления еще одного элемента.

\sphinxAtStartPar
Как посмотреть содержимое переменной окружения \sphinxcode{\sphinxupquote{PATH}} в Linux, внести в нее временные и постоянные изменения, просматривать содержимое всех переменных окружения одновременно?

\sphinxAtStartPar
Посмотреть содержание \sphinxcode{\sphinxupquote{PATH}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}PATH}
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
\end{sphinxVerbatim}

\sphinxAtStartPar
Временно добавить директорию в \sphinxcode{\sphinxupquote{PATH}}
Добавить \sphinxcode{\sphinxupquote{/home/andrei/.local/bin}} в \sphinxcode{\sphinxupquote{PATH}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export PATH="/home/andrei/.local/bin:\$PATH"}}

\sphinxAtStartPar
Проверка:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}PATH}
/home/andrei/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/game
\end{sphinxVerbatim}

\sphinxAtStartPar
Добавить директорию в \sphinxcode{\sphinxupquote{PATH}} через \sphinxcode{\sphinxupquote{.bashrc}}
Чтобы добавить директорию не постоянной основе, пропишите ее в \sphinxcode{\sphinxupquote{.bashrc}}.
Перейдите в домашнюю директорию, выполнив:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZti{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Там, скорее всего, находится файл \sphinxcode{\sphinxupquote{.bashrc}}. Отредактируйте его в любом текстовом редакторе:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi\PYG{+w}{ }.bashrc
\PYG{n+nv}{PATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/your\PYGZus{}folder:}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PATH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
exportPATH
\end{sphinxVerbatim}

\sphinxAtStartPar
Обратите внимание, что после \sphinxcode{\sphinxupquote{PATH}} нет пробела, как и после знака равенства.
\sphinxcode{\sphinxupquote{:\$\{PATH\}}} означает, что вы добавляете директорию \sphinxstyleemphasis{\sphinxstylestrong{your\_folder}} к уже существующему \sphinxcode{\sphinxupquote{PATH}}, а не переписываете его с нуля.

\sphinxAtStartPar
\sphinxstylestrong{Посмотреть содержимое всех переменных окружения}
Чтобы изучить не только \sphinxcode{\sphinxupquote{PATH}}, а вообще все переменные окружения, выполните:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
env
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{LC\PYGZus{}PAPER}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{XDG\PYGZus{}SESSION\PYGZus{}ID}\PYG{o}{=}\PYG{l+m}{2}\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}ADDRESS}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{HOSTNAME}\PYG{o}{=}localhost.localdomainLC\PYGZus{}MONETARY\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{SELINUX\PYGZus{}ROLE\PYGZus{}REQUESTED}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nv}{TERM}\PYG{o}{=}xterm\PYGZhy{}256colorSHELL\PYG{o}{=}/bin/bashHISTSIZE\PYG{o}{=}\PYG{l+m}{1000}\PYG{+w}{ }\PYG{n+nv}{SSH\PYGZus{}CLIENT}\PYG{o}{=}\PYG{l+m}{192}.168.56.1\PYG{+w}{ }\PYG{l+m}{41522}\PYG{+w}{ }\PYG{l+m}{22}\PYG{+w}{ }\PYG{n+nv}{SELINUX\PYGZus{}USE\PYGZus{}CURRENT\PYGZus{}RANGE}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}NUMERIC}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{SSH\PYGZus{}TTY}\PYG{o}{=}/dev/pts/1\PYG{+w}{ }\PYG{n+nv}{USER}\PYG{o}{=}andrei\PYG{+w}{ }\PYG{n+nv}{LS\PYGZus{}COLORS}\PYG{o}{=}\PYG{n+nv}{rs}\PYG{o}{=}\PYG{l+m}{0}:di\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{27}:ln\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{51}:mh\PYG{o}{=}\PYG{l+m}{44}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{15}:pi\PYG{o}{=}\PYG{l+m}{40}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{11}:so\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:do\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{5}:bd\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{232}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{11}:cd\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{232}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{3}:or\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{232}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:mi\PYG{o}{=}\PYG{l+m}{05}\PYG{p}{;}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{232}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{15}:su\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{196}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{15}:sg\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{11}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{16}:ca\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{196}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{226}:tw\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{10}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{16}:ow\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{10}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{21}:st\PYG{o}{=}\PYG{l+m}{48}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{21}\PYG{p}{;}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{15}:ex\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{34}:*.tar\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tgz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.arc\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.arj\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.taz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lha\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lz4\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lzh\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lzma\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tlz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.txz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tzo\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.t7z\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.zip\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.z\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.Z\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.dz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.gz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lrz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.lzo\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.xz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.bz2\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.bz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tbz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tbz2\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.tz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.deb\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.rpm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.jar\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.war\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.ear\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.sar\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.rar\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.alz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.ace\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.zoo\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.cpio\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.7z\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.rz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.cab\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{9}:*.jpg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.jpeg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.gif\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.bmp\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.pbm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.pgm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.ppm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.tga\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.xbm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.xpm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.tif\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.tiff\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.png\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.svg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.svgz\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mng\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.pcx\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mov\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mpg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mpeg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.m2v\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mkv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.webm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.ogm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mp4\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.m4v\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.mp4v\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.vob\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.qt\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.nuv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.wmv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.asf\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.rm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.rmvb\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.flc\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.avi\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.fli\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.flv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.gl\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.dl\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.xcf\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.xwd\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.yuv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.cgm\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.emf\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.axv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.anx\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.ogv\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.ogx\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{13}:*.aac\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.au\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.flac\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.mid\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.midi\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.mka\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.mp3\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.mpc\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.ogg\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.ra\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.wav\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.axa\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.oga\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.spx\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:*.xspf\PYG{o}{=}\PYG{l+m}{38}\PYG{p}{;}\PYG{l+m}{5}\PYG{p}{;}\PYG{l+m}{45}:\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}TELEPHONE}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{MAIL}\PYG{o}{=}/var/spool/mail/andrei\PYG{+w}{ }\PYG{n+nv}{PATH}\PYG{o}{=}/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/andrei/.local/bin:/home/andrei/bin\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}IDENTIFICATION}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{PWD}\PYG{o}{=}/home/andreiLANG\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}MEASUREMENT}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{SELINUX\PYGZus{}LEVEL\PYGZus{}REQUESTED}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nv}{HISTCONTROL}\PYG{o}{=}\PYG{n+nv}{ignoredupsSHLVL}\PYG{o}{=}\PYG{l+m}{1}\PYG{+w}{ }\PYG{n+nv}{HOME}\PYG{o}{=}/home/andreiLOGNAME\PYG{o}{=}andrei\PYG{+w}{ }\PYG{n+nv}{XDG\PYGZus{}DATA\PYGZus{}DIRS}\PYG{o}{=}/home/andrei/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share\PYG{+w}{ }\PYG{n+nv}{SSH\PYGZus{}CONNECTION}\PYG{o}{=}\PYG{l+m}{192}.168.56.1\PYG{+w}{ }\PYG{l+m}{41522}\PYG{+w}{ }\PYG{l+m}{192}.168.56.116\PYG{+w}{ }\PYG{l+m}{22}\PYG{+w}{ }\PYG{n+nv}{LESSOPEN}\PYG{o}{=}\PYG{o}{||}/usr/bin/lesspipe.sh\PYG{+w}{ }\PYGZpc{}s\PYG{+w}{ }\PYG{n+nv}{XDG\PYGZus{}RUNTIME\PYGZus{}DIR}\PYG{o}{=}/run/user/1000\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}TIME}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{LC\PYGZus{}NAME}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8\PYG{+w}{ }\PYG{n+nv}{\PYGZus{}}\PYG{o}{=}/usr/bin/env
\end{sphinxVerbatim}


\subsection{Знакомство с virtualenv}
\label{\detokenize{educational_materials/path_venv/content:virtualenv}}
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{virtualenv}} — это инструмент, используемый для создания изолированного рабочего пространства для приложения Python. Он дает некоторые преимущества: например, возможность локальной установки модулей, экспорта рабочей среды и выполнения программы Python внутри этого окружения.
Виртуальное окружение (virtual environment) — это каталог, в который устанавливаются некоторые исполняемые файлы и скрипты. Среди файлов есть python для выполнения скриптов и pip для установки других модулей в окружении. По сути, виртуальное окружение имитирует полную системную установку Python и всех необходимых модулей, не вмешиваясь в работу системы, на которой будет запускаться приложение.

\sphinxAtStartPar
В 2017 году был опубликован Pipenv, который управляет всеми вышеперечисленными инструментами: виртуальными окружениями интерпретаторов Python, зависимостями пакетов, их активацией и блокировкой версий в Pipfile.

\sphinxAtStartPar
\sphinxstylestrong{Установка}

\sphinxAtStartPar
Python 3.3+ поставляется с модулем venv.
Для более старых версий Python можно использовать сторонний инструмент virtualenv.
Пакеты
Установите один из следующих пакетов:
\sphinxcode{\sphinxupquote{Python 3.3+: python}}
\sphinxcode{\sphinxupquote{Python 3: python\sphinxhyphen{}virtualenv}}
Для Pipenv:
\sphinxcode{\sphinxupquote{Python 3: python\sphinxhyphen{}pipenv}}
Все три инструмента похожи.

\sphinxAtStartPar
\sphinxstylestrong{Создание}

\sphinxAtStartPar
Используйте venv или virtualenv для создания виртуального окружения в каталоге вашего проекта. Не забудьте исключить каталог venv из вашей системы контроля версий, для его восстановления достаточно копии \sphinxcode{\sphinxupquote{pip freeze}}.

\sphinxAtStartPar
Он входит в состав python (3.3+):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }venv\PYG{+w}{ }env\PYG{+w}{ }name
\end{sphinxVerbatim}

\sphinxAtStartPar
Доступен в пакете python\sphinxhyphen{}virtualenv.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }virtualenvenvname
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Активация}

\sphinxAtStartPar
Для активации виртуального окружения используйте один из имеющихся скриптов для вашей командной оболочки. Пример для bash:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }env\PYGZus{}name/bin/activate
\PYG{o}{(}envname\PYG{o}{)}\PYG{+w}{ }\PYGZdl{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь команды python и pip будут запускаться и управлять пакетами только внутри виртуального окружения, не затрагивая систему.
Для выхода из виртуального окружения выполните функцию, которую создал скрипт активации: \sphinxcode{\sphinxupquote{(envname) \$ deactivate}}.

\sphinxAtStartPar
\sphinxstylestrong{Версии Python}

\sphinxAtStartPar
По умолчанию виртуальные окружения создаются с использованием стандартного системного Python. Файл bin/python — это просто символическая ссылка на системный python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }envname/bin/python
lrwxrwxrwx\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }foo\PYG{+w}{ }foo\PYG{+w}{ }\PYG{l+m}{15}\PYG{+w}{ }янв\PYG{+w}{ }\PYG{l+m}{29}\PYG{+w}{ }\PYG{l+m}{18}:48\PYG{+w}{ }envname/bin/python\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }/usr/bin/python
\end{sphinxVerbatim}

\sphinxAtStartPar
Если вы хотите использовать другую версию Python внутри виртуального окружения, можно использовать опцию \sphinxcode{\sphinxupquote{\sphinxhyphen{}p/\sphinxhyphen{}\sphinxhyphen{}python}} у virtualenv:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }virtualenv\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYG{l+m}{3}.8\PYG{+w}{ }envname
\PYGZdl{}\PYG{+w}{ }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }envname/bin/python
lrwxrwxrwx\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }foo\PYG{+w}{ }foo\PYG{+w}{ }\PYG{l+m}{18}\PYG{+w}{ }янв\PYG{+w}{ }\PYG{l+m}{29}\PYG{+w}{ }\PYG{l+m}{18}:48\PYG{+w}{ }envname/bin/python\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }/usr/bin/python3.8
\end{sphinxVerbatim}

\sphinxAtStartPar
Также можно использовать pypy3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }virtualenv\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }pypy3\PYG{+w}{ }env\PYG{+w}{ }name
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Использование}

\sphinxAtStartPar
Все команды можно выполнять в папке проекта, и pipenv распознает текущую ситуацию, найдет виртуальное окружение в текущем каталоге и будет использовать его.
В этом разделе будут показаны установка, настройка, а также проведен полный обзор всех возможностей использования утилит venv и virtualenv для Python. Но начнем мы с рассмотрения общих вопросов.

\sphinxAtStartPar
В процессе разработки приложений на языке программирования Python может возникнуть ряд проблем, которые связаны с применением различных версий библиотек. Например, для работы двух различных приложений может потребоваться одна и та же библиотека, но разных версий. Или же нужно обеспечить корректную работу приложения вне зависимости от обновления версии библиотеки, которую оно использует.

\sphinxAtStartPar
Чтобы решать подобные проблемы, разработчики придумали интересный способ: запускать каждое приложение со своим набором версий библиотек в изолированных средах. Таким образом, виртуальная среда (\sphinxstyleemphasis{virtual environment}) в языке Python позволяет управлять проектами изолированно друг от друга, то есть:
\begin{itemize}
\item {} 
\sphinxAtStartPar
у каждого проекта могут быть свои зависимости;

\item {} 
\sphinxAtStartPar
зависимости одного проекта не влияют на зависимости другого проекта.

\end{itemize}

\sphinxAtStartPar
Создавать виртуальное окружение в Python можно при помощи различных утилит. Поговорим про venv и virtualenv.
\begin{quote}

\sphinxAtStartPar
Важно: перед началом работы у вас должен быть установлен Python 3 и pip. Если вы используете Windows, все следующие команды, кроме тех, где будет альтернативный вариант, выполняются таким же образом, но необходимо заменять pip3 на pip, а python3 на Python.
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Работа с venv}

\sphinxAtStartPar
Чтобы создать виртуальную среду, мы используем модуль venv. Это удобный инструмент для управления зависимостями и изоляции проектов, который выстроен в Python, начиная с версии Python 3.3+. Поэтому модуль venv нельзя использовать для изоляции программ Python 2.x.

\sphinxAtStartPar
\sphinxstylestrong{Создание проекта}

\sphinxAtStartPar
Приступим к созданию проекта. Первым делом следует создать папку проекта и перейти в нее, в Linux это можно сделать при помощи следующих команд:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }mkdir\PYG{+w}{ }my\PYGZus{}python\PYGZus{}project
\PYG{n+nb}{cd}\PYG{+w}{ }my\PYGZus{}python\PYGZus{}project
\end{sphinxVerbatim}

\sphinxAtStartPar
Замените my\_python\_project на желаемое название проекта.


\subsubsection{Создание виртуальной среды}
\label{\detokenize{educational_materials/path_venv/content:id2}}
\sphinxAtStartPar
Теперь создадим в этой папке виртуальную среду:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}python3}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }venv\PYG{+w}{ }env
\end{sphinxVerbatim}

\sphinxAtStartPar
Замените \sphinxcode{\sphinxupquote{project\_name\_myproject}} на желаемое название виртуальной среды. Если у вас возникает следующая ошибка:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The\PYG{+w}{ }virtual\PYG{+w}{ }environment\PYG{+w}{ }was\PYG{+w}{ }not\PYG{+w}{ }created\PYG{+w}{ }successfully\PYG{+w}{ }because\PYG{+w}{ }ensurepip\PYG{+w}{ }is\PYG{+w}{ }not
available.\PYG{+w}{ }On\PYG{+w}{ }Debian/Ubuntu\PYG{+w}{ }systems,\PYG{+w}{ }you\PYG{+w}{ }need\PYG{+w}{ }to\PYG{+w}{ }install\PYG{+w}{ }the\PYG{+w}{ }python3\PYGZhy{}venv
package\PYG{+w}{ }using\PYG{+w}{ }the\PYG{+w}{ }following\PYG{+w}{ }command.
\end{sphinxVerbatim}

\sphinxAtStartPar
Это говорит, что в вашей системе отсутствует пакет python3\sphinxhyphen{}venv, и вам следует его установить. Команда представлена ниже:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
apt\PYGZhy{}get\PYG{+w}{ }install\PYG{+w}{ }python3\PYGZhy{}venv
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
You\PYG{+w}{ }may\PYG{+w}{ }need\PYG{+w}{ }to\PYG{+w}{ }use\PYG{+w}{ }sudo\PYG{+w}{ }with\PYG{+w}{ }that\PYG{+w}{ }command.\PYG{+w}{ }After\PYG{+w}{ }installing\PYG{+w}{ }the\PYG{+w}{ }python3\PYGZhy{}venv
package,\PYG{+w}{ }recreate\PYG{+w}{ }your\PYG{+w}{ }virtual\PYG{+w}{ }environment.
Failing\PYG{+w}{ }command:\PYG{+w}{ }\PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}/home/osboxes/my\PYGZus{}python\PYGZus{}project/project\PYGZus{}name\PYGZus{}myproject/bin/python3\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}Im\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ensurepip\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}upgrade\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Вам необходимо установить venv. Например, в Ubuntu для этого требуется выполнить следующую команду:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }sudo\PYG{+w}{ }apt\PYGZhy{}get\PYG{+w}{ }install\PYG{+w}{ }python3\PYGZhy{}venv\PYGZhy{}y
\end{sphinxVerbatim}

\sphinxAtStartPar
После повторите команду создания виртуальной среды Python, показанную в начале этого раздела.

\sphinxAtStartPar
\sphinxstylestrong{Активация виртуальной среды}

\sphinxAtStartPar
Осталось активировать виртуальную среду при помощи команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }sourceproject\PYGZus{}name\PYGZus{}myproject/bin/activate
\end{sphinxVerbatim}

\sphinxAtStartPar
Замените project\_name\_myproject на название виртуальной среды, созданной на прошлом шаге.
Если вы используете Windows, и у вас правильно установлен Python и pip, то вы можете активировать виртуальную среду следующей командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }project\PYGZus{}name\PYGZus{}myproject/Scripts/activate
\end{sphinxVerbatim}

\sphinxAtStartPar
Замените project\_name\_myproject на название виртуальной среды, созданной на прошлом шаге.

\sphinxAtStartPar
Проверка установленных пакетов
Теперь проверим установленные пакеты pip внутри виртуальной среды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip3list
\end{sphinxVerbatim}

\sphinxAtStartPar
Вывод должен быть примерно такой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Package\PYG{+w}{ }Version
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
pip\PYG{+w}{ }\PYG{l+m}{20}.3.4
pkg\PYGZhy{}resources\PYG{+w}{ }\PYG{l+m}{0}.0.0
setuptools\PYG{+w}{ }\PYG{l+m}{44}.1.1
\end{sphinxVerbatim}

\sphinxAtStartPar
Как мы видим, внутри виртуальной среды у нас нет никаких сторонних установленных библиотек c pip. Можно установить какой\sphinxhyphen{}либо пакет, например, модуль \sphinxcode{\sphinxupquote{requests}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip3\PYG{+w}{ }install\PYG{+w}{ }requests
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь снова проверим список установленных пакетов pip внутри виртуальной среды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }list
\end{sphinxVerbatim}

\sphinxAtStartPar
В выводе должен появиться наш только что установленный пакет:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Package\PYG{+w}{ }Version
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
certifi\PYG{+w}{ }\PYG{l+m}{2021}.5.30
chardet\PYG{+w}{ }\PYG{l+m}{4}.0.0
idna\PYG{+w}{ }\PYG{l+m}{2}.10
pip\PYG{+w}{ }\PYG{l+m}{20}.3.4
pkg\PYGZhy{}resources\PYG{+w}{ }\PYG{l+m}{0}.0.0
requests\PYG{+w}{ }\PYG{l+m}{2}.25.1
setuptools\PYG{+w}{ }\PYG{l+m}{44}.1.1
urllib3\PYG{+w}{ }\PYG{l+m}{1}.26.5
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Выход из виртуальной среды}

\sphinxAtStartPar
Для выхода из виртуальной среды необходимо выполнить команду:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{deactivate}}}.
Если после выхода снова проверить список установленных пакетов, то мы получим совсем другой вывод:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Package\PYG{+w}{ }Version
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
apturl\PYG{+w}{ }\PYG{l+m}{0}.5.2
bcrypt\PYG{+w}{ }\PYG{l+m}{3}.1.7
blinker\PYG{+w}{ }\PYG{l+m}{1}.4
Brlapi\PYG{+w}{ }\PYG{l+m}{0}.8.2
certifi\PYG{+w}{ }\PYG{l+m}{2020}.6.20
chardet\PYG{+w}{ }\PYG{l+m}{4}.0.0
chrome\PYGZhy{}gnome\PYGZhy{}shell\PYG{+w}{ }\PYG{l+m}{0}.0.0
click\PYG{+w}{ }\PYG{l+m}{7}.1.2
colorama\PYG{+w}{ }\PYG{l+m}{0}.4.4
command\PYGZhy{}not\PYGZhy{}found\PYG{+w}{ }\PYG{l+m}{0}.3
cryptography\PYG{+w}{ }\PYG{l+m}{3}.3.2
\end{sphinxVerbatim}


\subsubsection{Перенос установленных пакетов}
\label{\detokenize{educational_materials/path_venv/content:id3}}
\sphinxAtStartPar
Для переноса установленных пакетов в другую среду на Linux можно использовать простую команду:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python3\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }freeze\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }requirements.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
Она создаст файл requirements.txt, в котором будет находиться список всех установленных пакетов.
Импорт пакетов в другую среду. Теперь можно перейти в другую виртуальную среду и импортировать пакеты следующей командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip3install\PYGZhy{}r\PYG{+w}{ }requirements.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Работа с virtualenv}

\sphinxAtStartPar
Утилита virtualenv — это наиболее популярный инструмент, который используется для создания изолированных сред в Python. Он создает папку, содержащую все необходимые исполняемые файлы для использования пакетов, которые потребуются проекту Python. В отличие от модуля venv, эту утилиту можно использовать как в Python 3, так и в версии 2.7.


\subsubsection{Установка virtualenv и создание виртуальной среды}
\label{\detokenize{educational_materials/path_venv/content:id4}}
\sphinxAtStartPar
Чтобы установить утилиту virtualenv, используйте pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }virtualenv
\end{sphinxVerbatim}


\subsubsection{Создание виртуальной среды virtualenv происходит так}
\label{\detokenize{educational_materials/path_venv/content:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }project\PYGZus{}folder
\PYGZdl{}\PYG{+w}{ }virtualenv\PYG{+w}{ }myproject
\end{sphinxVerbatim}

\sphinxAtStartPar
virtualenv myproject создаст папку в текущей директории. В ней будут находиться исполняемые файлы Python и копия библиотеки \sphinxstylestrong{pip}, которую можно использовать для установки других пакетов. Имя виртуальной среды (в данном случае \sphinxstylestrong{myproject}) может быть любым. Если имя отсутствует, файлы будут помещены в текущий каталог. Таким образом, создается копия Python в любом каталоге, в котором вы запускали команду, помещая ее в папку с именем myproject.
Вы также можете использовать интерпретатор Python по выбору. Пример использования Python 2.7:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }virtualenv\PYGZhy{}p\PYG{+w}{ }/usr/bin/python2.7\PYG{+w}{ }myproject
\end{sphinxVerbatim}

\sphinxAtStartPar
Для версии Python 3.7:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }virtualenv\PYGZhy{}p\PYG{+w}{ }/usr/bin/python3.7\PYG{+w}{ }myproject
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверить версию Python и pip можно с помощью следующих команд:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python\PYGZhy{}\PYGZhy{}version
\PYGZdl{}\PYG{+w}{ }pip\PYGZhy{}\PYGZhy{}version
\end{sphinxVerbatim}

\sphinxAtStartPar
Для выхода из виртуальной среды необходимо выполнить команду:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }deactivate
\end{sphinxVerbatim}


\subsubsection{Копирование виртуальной среды}
\label{\detokenize{educational_materials/path_venv/content:id6}}
\sphinxAtStartPar
Чтобы копировать виртуальные среды, введите:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }cpvirtualenv\PYG{+w}{ }new\PYGZhy{}project\PYG{+w}{ }new\PYGZhy{}project\PYGZhy{}copy
Copying\PYG{+w}{ }new\PYGZhy{}project\PYG{+w}{ }as\PYG{+w}{ }new\PYGZhy{}project\PYGZhy{}copy...
\PYGZdl{}\PYG{+w}{ }workon
new\PYGZhy{}project
new\PYGZhy{}project\PYGZhy{}copy
\end{sphinxVerbatim}


\subsubsection{Удаление виртуальной среды}
\label{\detokenize{educational_materials/path_venv/content:id7}}
\sphinxAtStartPar
Удалять виртуальные среды можно при помощи команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }rmvirtualenvnew\PYGZhy{}project\PYGZhy{}copy
\end{sphinxVerbatim}

\sphinxAtStartPar
Важно — не забудьте перед удалением выйти из виртуальной среды при помощи команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }deactivate
\PYGZdl{}\PYG{+w}{ }rmvirtualenv\PYG{+w}{ }new\PYGZhy{}project\PYGZhy{}copy
Removing\PYG{+w}{ }new\PYGZhy{}project\PYGZhy{}copy...
\PYGZdl{}\PYG{+w}{ }workon
new\PYGZhy{}project
\end{sphinxVerbatim}


\subsection{Справочный материал}
\label{\detokenize{educational_materials/path_venv/content:id8}}
\sphinxAtStartPar
\sphinxstylestrong{Синтаксис}

\sphinxAtStartPar
Интерфейс использования:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }\PYGZlt{}command\PYGZgt{}\PYG{+w}{ }\PYG{o}{[}options\PYG{o}{]}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
install
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Установка пакетов
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
download
&
\sphinxAtStartPar
Скачивание пакетов.
\\
\sphinxhline
\sphinxAtStartPar
uninstall
&
\sphinxAtStartPar
Удаление пакетов.
\\
\sphinxhline
\sphinxAtStartPar
freeze
&
\sphinxAtStartPar
Вывод установленных пакетов в формате файла зависимостей.
\\
\sphinxhline
\sphinxAtStartPar
list
&
\sphinxAtStartPar
Вывод списка установленных пакетов.
\\
\sphinxhline
\sphinxAtStartPar
show
&
\sphinxAtStartPar
Вывод информации об установленных пакетах.
\\
\sphinxhline
\sphinxAtStartPar
check
&
\sphinxAtStartPar
Проверка совместимости установленных пакетов с их зависимостями.
\\
\sphinxhline
\sphinxAtStartPar
config
&
\sphinxAtStartPar
Управление локальной и глобальной конфигурацией.
\\
\sphinxhline
\sphinxAtStartPar
search
&
\sphinxAtStartPar
Поиск пакетов в PyPI.
\\
\sphinxhline
\sphinxAtStartPar
wheel
&
\sphinxAtStartPar
Сборка wheel из зависимостей.
\\
\sphinxhline
\sphinxAtStartPar
hash
&
\sphinxAtStartPar
Вычисление хешей из  hashes of package archives.
\\
\sphinxhline
\sphinxAtStartPar
completion
&
\sphinxAtStartPar
Вспомогательная команда для автодополнения командной строки.
\\
\sphinxhline
\sphinxAtStartPar
debug
&
\sphinxAtStartPar
Вывод информации применимой для отладки.
\\
\sphinxhline
\sphinxAtStartPar
help
&
\sphinxAtStartPar
Вывод справки по командам.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Общие опции:
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}h, \textendash{}help
&
\sphinxAtStartPar
Вывод справки.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}isolated
&
\sphinxAtStartPar
Запуск pip в изолированном режиме, с игнорированием переменных окружения и пользовательской конфигурации.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}v, \textendash{}verbose
&
\sphinxAtStartPar
Расширенный вывод. Опция аддитивная и может использоваться до 3 раз.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}V, \textendash{}version
&
\sphinxAtStartPar
Вывод версии.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}q, \textendash{}quiet
&
\sphinxAtStartPar
Сокращенный вывод. Опция аддитивная и может использоваться до 3 раз (соответствует уровням логирования WARNING, ERROR и CRITICAL).
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}log 
&
\sphinxAtStartPar
Путь инкрементального вывода логов.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}proxy 
&
\sphinxAtStartPar
Настройки прокси в форме {[}user:passwd@{]}proxy.server:port.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}retries 
&
\sphinxAtStartPar
Максимальное количество попыток, которое должно предпринять каждое соединение (по умолчанию 5 раз).
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}timeout 
&
\sphinxAtStartPar
Установить время ожидания сокета (по умолчанию 15 секунд).
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}exists\sphinxhyphen{}action 
&
\sphinxAtStartPar
Действие по умолчанию, когда путь уже существует: (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}trusted\sphinxhyphen{}host 
&
\sphinxAtStartPar
Пометить хост как доверенный, в случае если HTTPS хоста инвалидный.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}cert 
&
\sphinxAtStartPar
Путь к альтернативному комплекту CA.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}client\sphinxhyphen{}cert 
&
\sphinxAtStartPar
Путь к сертификату клиента SSL, отдельный файл, содержащий закрытый ключ и сертификат в формате PEM.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}cache\sphinxhyphen{}dir 
&
\sphinxAtStartPar
Настройка директории кэширования данных.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}no\sphinxhyphen{}cache\sphinxhyphen{}dir
&
\sphinxAtStartPar
Отключение кеша.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}disable\sphinxhyphen{}pip\sphinxhyphen{}version\sphinxhyphen{}check
&
\sphinxAtStartPar
Отключение периодической проверки PyPI на доступность новой версии pip.
\\
\sphinxhline
\sphinxAtStartPar
\textendash{}no\sphinxhyphen{}color
&
\sphinxAtStartPar
Подавление цветного вывода.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Ссылки на дополнительные ресурсы:}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
https://docs.python.org/3/library/venv.html

\item {} 
\sphinxAtStartPar
https://www.codecamp.ru/blog/python\sphinxhyphen{}virtual\sphinxhyphen{}environments/

\end{itemize}

\sphinxstepscope


\section{Задачи для практики}
\label{\detokenize{educational_materials/path_venv/exercises:id1}}\label{\detokenize{educational_materials/path_venv/exercises::doc}}

\subsection{Задача: настроить виртуальную среду с помощью venv для управления зависимостями проекта}
\label{\detokenize{educational_materials/path_venv/exercises:venv}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Откройте терминал или командную строку и перейдите в каталог проекта;

\item {} 
\sphinxAtStartPar
Создайте новую виртуальную среду с помощью следующей команды: \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m venv myenv}};

\item {} 
\sphinxAtStartPar
Активируйте виртуальную среду с помощью следующей команды: (Windows) \sphinxcode{\sphinxupquote{myenv\textbackslash{}Scripts\textbackslash{}activate.bat}} или (Linux/MacOS) \sphinxcode{\sphinxupquote{myenv/bin/активировать}};

\item {} 
\sphinxAtStartPar
Установите зависимости проекта с помощью pip: \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}r requirements.txt}};

\item {} 
\sphinxAtStartPar
Убедитесь, что виртуальная среда работает правильно, запустив проект или его тесты в активированной среде;

\item {} 
\sphinxAtStartPar
По окончании работы над проектом деактивируйте виртуальную среду с помощью команды \sphinxcode{\sphinxupquote{deactivate}}.

\end{itemize}


\subsection{Задача: настроить виртуальную среду с помощью venv и отправить код в репозиторий Git.}
\label{\detokenize{educational_materials/path_venv/exercises:venv-git}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Создайте новый репозиторий Git для вашего проекта;

\item {} 
\sphinxAtStartPar
Клонируйте репозиторий на свой локальный компьютер с помощью команды \sphinxcode{\sphinxupquote{git clone}};

\item {} 
\sphinxAtStartPar
Перейдите в корневой каталог вашего проекта в терминале или командной строке;

\item {} 
\sphinxAtStartPar
Создайте новую виртуальную среду с помощью следующей команды: \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m venv venv}};

\item {} 
\sphinxAtStartPar
Активируйте виртуальную среду с помощью следующей команды: (Windows) \sphinxcode{\sphinxupquote{venv\textbackslash{}Scripts\textbackslash{}activate.bat}} или (Linux/MacOS) \sphinxcode{\sphinxupquote{source venv/bin/activate}};

\item {} 
\sphinxAtStartPar
Установите зависимости проекта с помощью pip: \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}r requirements.txt}};

\item {} 
\sphinxAtStartPar
Напишите свой код и зафиксируйте изменения, используя \sphinxcode{\sphinxupquote{git add .}} и \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}m "Commit message"}};

\item {} 
\sphinxAtStartPar
Отправьте изменения в репозиторий Git с помощью \sphinxcode{\sphinxupquote{git push}};

\item {} 
\sphinxAtStartPar
По окончании работы над проектом деактивируйте виртуальную среду с помощью команды \sphinxcode{\sphinxupquote{deactivate}};

\item {} 
\sphinxAtStartPar
Чтобы использовать проект на другом компьютере, клонируйте репозиторий и повторите шаги 4\textendash{}6, чтобы настроить виртуальную среду и установить зависимости.

\end{itemize}

\sphinxAtStartPar
Используя вместе venv и Git, вы можете изолировать зависимости вашего проекта и легко отслеживать изменения кода с течением времени.

\sphinxstepscope


\section{Вопросы:}
\label{\detokenize{educational_materials/path_venv/quiz:id1}}\label{\detokenize{educational_materials/path_venv/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое виртуальное окружение (virtual environment) для Python?

\item {} 
\sphinxAtStartPar
Какова цель использования виртуальных окружений?

\item {} 
\sphinxAtStartPar
Как создать новое виртуальное окружение с помощью venv?

\item {} 
\sphinxAtStartPar
Как активировать виртуальное окружение на различных операционных системах?

\item {} 
\sphinxAtStartPar
Как деактивировать виртуальное окружение?

\item {} 
\sphinxAtStartPar
Как проверить, что виртуальное окружение активировано?

\item {} 
\sphinxAtStartPar
Какой файл используется для хранения списка зависимостей проекта?

\item {} 
\sphinxAtStartPar
Как создать файл зависимостей (например, requirements.txt) для Python\sphinxhyphen{}проекта?

\item {} 
\sphinxAtStartPar
Как установить зависимости проекта из файла requirements.txt?

\item {} 
\sphinxAtStartPar
Как добавить новую зависимость в виртуальное окружение?

\item {} 
\sphinxAtStartPar
Как удалить зависимость из виртуального окружения?

\item {} 
\sphinxAtStartPar
Какие другие способы можно использовать для управления зависимостями в Python\sphinxhyphen{}проекте?

\item {} 
\sphinxAtStartPar
Что такое глобальные и локальные зависимости?

\item {} 
\sphinxAtStartPar
Какие файлы и директории следует исключить из системы контроля версий (например, Git) при работе с виртуальными окружениями?

\item {} 
\sphinxAtStartPar
Каковы основные преимущества использования виртуальных окружений в сравнении с установкой зависимостей глобально?

\item {} 
\sphinxAtStartPar
Что произойдет, если в разных проектах используются разные версии одной и той же библиотеки?

\item {} 
\sphinxAtStartPar
Как перенести виртуальное окружение на другую систему?

\item {} 
\sphinxAtStartPar
Как удалить виртуальное окружение?

\item {} 
\sphinxAtStartPar
Как использовать виртуальное окружение в IDE (например, Visual Studio Code)?

\item {} 
\sphinxAtStartPar
Какие еще инструменты или методы вы используете для управления рабочим окружением в Python\sphinxhyphen{}проектах?

\end{enumerate}

\sphinxAtStartPar
Эти вопросы помогут оценить знания основ настройки и работы с виртуальными окружениями (venv) в Python, что является важным навыком для эффективной разработки проектов.


\chapter{Инструменты для создания документации}
\label{\detokenize{index:id13}}
\sphinxstepscope


\section{Документирование}
\label{\detokenize{educational_materials/docs/content:id1}}\label{\detokenize{educational_materials/docs/content::doc}}

\subsection{Мотивация}
\label{\detokenize{educational_materials/docs/content:id2}}
\sphinxAtStartPar
Наверное, многие из вас слышали про TDD, когда тесты пишутся до написания кода, и затем пишется сам код, который пройдет все тесты. Такой подход позволяет взглянуть на код с другой стороны и, при правильном отношении, лучше структурировать его. Другой способ лучше писать код — это так называемое «Readme\sphinxhyphen{}driven\sphinxhyphen{}development», т.е. такой способ разработки, при котором мы пишем сначала документацию к коду, включая readme и документацию функций (docstring в python). Простой пример: \sphinxstylestrong{если у вас есть трудности с тем, чтобы описать работу функции, скорее всего, ее нужно разбить на несколько функций и задокументировать каждую по отдельности}. Наличие документации, особенно если она хорошо составлена, поможет не только другим разработчикам, но и вам самим, чтобы восстановить контекст и понять, что же вы имели в виду, когда писали этот код год назад.


\subsection{Markdown}
\label{\detokenize{educational_materials/docs/content:markdown}}
\sphinxAtStartPar
Когда мы писали свою простую библиотеку, мы делали файл README.md, содержимое которого собиралось в красивый \sphinxhref{https://github.com/standlab/mtracker/blob/main/README.md}{документ} самим GitHub. В этом случае мы использовали язык разметки \sphinxcode{\sphinxupquote{Markdown}}, который является одним из общепринятых способов оформления документации. Рассмотрим элементы разметки. В данном документе мы использовали \sphinxhref{https://dillinger.io/}{онлайн\sphinxhyphen{}редактор}, но подойдет и любой другой.


\subsubsection{Заголовки}
\label{\detokenize{educational_materials/docs/content:id3}}
\sphinxAtStartPar
Чтобы сделать текст заголовком, используйте один или несколько знаков решетки. Чем их больше, тем меньше заголовок:

\sphinxAtStartPar
\sphinxincludegraphics{{titles}.png}

\sphinxAtStartPar
\sphinxhref{https://www.markdownguide.org/basic-syntax/\#alternate-syntax}{Можно} обозначать заголовки через подчеркивания. \sphinxstylestrong{Хорошим тоном} считается отделение заголовка от текста выше и ниже, а также отделение знака решетки от текста заголовка:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{какой}\PYG{o}{\PYGZhy{}}\PYG{n}{то} \PYG{n}{текст} \PYG{n}{до}\PYG{o}{.}

\PYG{c+c1}{\PYGZsh{} Заголовок}

\PYG{n}{Начало} \PYG{n}{раздела}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\end{sphinxVerbatim}


\subsubsection{Абзацы}
\label{\detokenize{educational_materials/docs/content:id4}}
\sphinxAtStartPar
Чтобы в тексте начать новый абзац, разделите текст пустой строкой:

\sphinxAtStartPar
\sphinxincludegraphics{{paragraph}.png}

\sphinxAtStartPar
\sphinxstylestrong{Хорошим тоном} считается писать текст без отступов.

\sphinxAtStartPar
Так делаем:

\sphinxAtStartPar
\sphinxincludegraphics{{paragraph_good}.png}

\sphinxAtStartPar
А так нет:

\sphinxAtStartPar
\sphinxincludegraphics{{paragraph_bad}.png}

\sphinxAtStartPar
Хотя результат будет один и тот же, мы всегда думаем не только о тех, кто читает собранный документ, но и о тех, кто читает исходник. Различные отступы сильно затрудняют чтение.


\subsubsection{Форматирование текста}
\label{\detokenize{educational_materials/docs/content:id5}}
\sphinxAtStartPar
Текст можно делать жирным или курсивом:

\sphinxAtStartPar
\sphinxincludegraphics{{bold_italic}.png}

\sphinxAtStartPar
Вместо звездочек можно использовать подчеркивания, но звездочки являются более универсальным способом выделения текста.

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Задание: как сделать шрифт жирным курсивом.}}


\subsubsection{Списки}
\label{\detokenize{educational_materials/docs/content:id6}}
\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{Markdown}} можно делать нумерованный список или просто перечисление пунктов.

\sphinxAtStartPar
\sphinxincludegraphics{{numbered_list}.png}

\sphinxAtStartPar
Мы можем использовать разные символы для ненумерованных списков (\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{+}}), \sphinxstylestrong{хорошей практикой} является использование одного из них:

\sphinxAtStartPar
\sphinxincludegraphics{{list_good}.png}

\sphinxAtStartPar
Не смешивайте несколько разных символов:

\sphinxAtStartPar
\sphinxincludegraphics{{list_bad}.png}


\subsubsection{Ссылки}
\label{\detokenize{educational_materials/docs/content:id7}}
\sphinxAtStartPar
Для того чтобы вставить ссылку, пишем ее название в \sphinxcode{\sphinxupquote{{[}{]}}} и после саму ссылку в \sphinxcode{\sphinxupquote{()}}, название будет отображено в собранном документе:

\sphinxAtStartPar
\sphinxincludegraphics{{hlink}.png}

\sphinxAtStartPar
Можно не вставлять ссылки в самом тексте, а вести их список отдельно и использовать id ссылки там, где нужно.

\sphinxAtStartPar
\sphinxincludegraphics{{hlink_via_id}.png}


\subsubsection{Вставка изображений}
\label{\detokenize{educational_materials/docs/content:id8}}
\sphinxAtStartPar
Вставка изображений напоминает использование ссылок. Мы пишем текст, который будет показан вместо изображения, если оно не будет подгружено, в \sphinxcode{\sphinxupquote{{[}{]}}}, и указываем путь или ссылку на изображение. Вначале мы ставим восклицательный знак, а в круглых скобках можем указать всплывающую подсказку:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
![opensource\PYGZus{}icon](/graphics/opensource.png \PYGZdq{}This opensource icon\PYGZdq{})
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{opensource}.png}

\sphinxAtStartPar
Если ошибиться в пути, будет показан текст из \sphinxcode{\sphinxupquote{{[}{]}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
![opensource\PYGZus{}icon](https://not\PYGZus{}existing\PYGZus{}site/graphics/not\PYGZus{}exist.png)
\end{sphinxVerbatim}

\sphinxAtStartPar


\sphinxAtStartPar
\sphinxstylestrong{Задание: проверьте, можно ли вести список картинок отдельно, например, в конце документа, и вставлять их в нужное место, используя id.}


\subsubsection{Код}
\label{\detokenize{educational_materials/docs/content:id9}}
\sphinxAtStartPar
В случае необходимости процитировать в документации исходный код программы или его части используются специализированные форматированные блоки, в которые помещаются фрагменты исходного кода программы. Это похоже на HTML\sphinxhyphen{}теги. Для создания блока кода в языке Markdown необходимо обрамить его символами \textasciigrave{}\textasciigrave{}\textasciigrave{} код программы \textasciigrave{}\textasciigrave{}\textasciigrave{}. Многие программы поддерживают форматирование текста Markdown в соответствии со стилем содержимого. Если мы оформим код программы, то в режиме просмотра его синтаксис будет подсвечиваться (как в среде разработке). Для лучшего распознавания стиля языка программирования следует указывать название языка или скрипта для применения подсветки его синтаксиса. Например, для представления фрагмента программы на языке Python лучше оформить его следующим образом:

\sphinxAtStartPar
\textasciigrave{}\textasciigrave{}\textasciigrave{}python\\
import os

\sphinxAtStartPar
def foo():\\
    path = os.getcwd()\\
    print(f» Путь к текущей директории = \{\}\textbackslash{}n\textbackslash{}nСписок файлов:\textbackslash{}n»)\\
    rez = sorted(os.listdir(path)\\
    for n, item in enumerate(rez):\\
        print(n+1, item)\\
\textasciigrave{}\textasciigrave{}\textasciigrave{}

\sphinxAtStartPar
После того как вы откроете этот документ, например, в браузере, вы увидите что код преобразился, его стиль изменился и стал больше похож на программный код.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}  

\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}  
    \PYG{n}{path} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}  
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ Путь к текущей директории = }\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Список файлов:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  
    \PYG{n}{rez} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}    
    \PYG{k}{for} \PYG{n}{n}\PYG{p}{,} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{:}  
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{item}\PYG{p}{)}  
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{code}.png}


\subsubsection{Цитирование}
\label{\detokenize{educational_materials/docs/content:id10}}
\sphinxAtStartPar
В текст можно вставлять цитаты:

\sphinxAtStartPar
\sphinxincludegraphics{{cite}.png}


\subsection{reStructuredText}
\label{\detokenize{educational_materials/docs/content:restructuredtext}}
\sphinxAtStartPar
Сейчас будет неожиданно. Но дальше нам будет нужен другой язык разметки — \sphinxcode{\sphinxupquote{reStructedText}}. Для тех, кто потратил время на материал выше, будет \sphinxhref{https://docs.open-mpi.org/en/v5.0.x/developers/rst-for-markdown-expats.html}{несложно} освоить и \sphinxcode{\sphinxupquote{reStructedText}}. Причины, по которым мы описали \sphinxcode{\sphinxupquote{Markdown}} и затем предложили переключиться на \sphinxcode{\sphinxupquote{reStructedText}}, две:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Курс написан с использованием \sphinxcode{\sphinxupquote{Markdown}}.

\item {} 
\sphinxAtStartPar
Инструмент (Sphinx), который соберет документацию для нашего пакета и сделает из нее красивые \sphinxcode{\sphinxupquote{html}}\sphinxhyphen{}страницы или \sphinxcode{\sphinxupquote{pdf}}, работает нативно с файлами \sphinxcode{\sphinxupquote{reStructuredText}}. Для работы с \sphinxcode{\sphinxupquote{Markdown}} требуется подключать дополнительный плагин.

\end{enumerate}

\sphinxAtStartPar
Вы можете изучить отличия чуть позже, сейчас мы возьмем open source \sphinxhref{https://github.com/miyakogi/m2r\#sphinx-integration}{конвертер} \sphinxcode{\sphinxupquote{md}} в \sphinxcode{\sphinxupquote{rst}} и используем его. Для README это вполне рабочий вариант. Серьезную документацию лучше сразу писать в формате \sphinxcode{\sphinxupquote{rst}}.


\subsection{Sphinx}
\label{\detokenize{educational_materials/docs/content:sphinx}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sphinx}} — это достаточно мощный инструмент, который может собрать не только документацию к проекту и сделать из нее веб\sphinxhyphen{}страницы, которые мы можем потом разместить на \sphinxhref{https://readthedocs.org/}{readthedocs}, но и текст для мануалов \sphinxcode{\sphinxupquote{man}}, которые являются стандартными для \sphinxcode{\sphinxupquote{bash}}.

\sphinxAtStartPar
\sphinxstylestrong{Обращайте внимание на то, в каких каталогах мы выполняем те или иные операции в \sphinxcode{\sphinxupquote{bash}} во вставках кода ниже}

\sphinxAtStartPar
Создадим пустой каталог и перейдем в него, создадим каталог для документации в этой папке и заберем себе \sphinxcode{\sphinxupquote{README.md}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }mkdir\PYG{+w}{ }test\PYGZus{}the\PYGZus{}docs
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }test\PYGZus{}the\PYGZus{}docs
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }mkdir\PYG{+w}{ }docs
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }wget\PYG{+w}{ }https://raw.githubusercontent.com/standlab/mtracker/main/README.md
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }ls
docs\PYG{+w}{  }README.md\PYG{+w}{ }
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь установим \sphinxcode{\sphinxupquote{sphinx}} и конвертер \sphinxcode{\sphinxupquote{rst \sphinxhyphen{}\textgreater{} md}}, конвертируем README.md:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }sphinx
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }m2r
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }m2r\PYG{+w}{ }README.md
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }ls\PYG{+w}{ }
docs\PYG{+w}{  }README.md\PYG{+w}{  }README.rst
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Примечание: если бы у нас сразу был файл в формате \sphinxcode{\sphinxupquote{rst}}, команды с \sphinxcode{\sphinxupquote{m2r}} можно было бы пропустить.}

\sphinxAtStartPar
Теперь мы готовы инициализировать каталог с документацией.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }docs
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs/docs\PYGZdl{}\PYG{+w}{ }sphinx\PYGZhy{}quickstart
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs/docs\PYGZdl{}\PYG{+w}{ }ls
build\PYG{+w}{  }make.bat\PYG{+w}{  }Makefile\PYG{+w}{  }\PYG{n+nb}{source}
\end{sphinxVerbatim}

\sphinxAtStartPar
На этом этапе вам будут заданы вопросы про название проекта, автора, версию и язык документации. На вопрос, разделять ли исходники и собранную документацию, отвечаем «да»:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYG{+w}{ }Separate\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }and\PYG{+w}{ }build\PYG{+w}{ }directories\PYG{+w}{ }\PYG{o}{(}y/n\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}n\PYG{o}{]}:\PYG{+w}{ }y
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь зайдем в файл \sphinxcode{\sphinxupquote{nano ./source/index.rst}} и добавим в конец строки:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Readme\PYG{+w}{ }\PYG{n+nv}{File}
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}

..\PYG{+w}{ }include::\PYG{+w}{ }../../README.rst
\end{sphinxVerbatim}

\sphinxAtStartPar
Это нужно для того, чтобы содержимое README было доступно в документации. \sphinxstyleemphasis{Мы пишем \sphinxcode{\sphinxupquote{../../}}, так как \sphinxcode{\sphinxupquote{README.rst}} находится на два уровня выше, чем содержимое каталога \sphinxcode{\sphinxupquote{source}}}. Теперь мы готовы собрать документацию:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs/docs\PYGZdl{}\PYG{+w}{ }sphinx\PYGZhy{}build\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }html\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }build
Running\PYG{+w}{ }Sphinx\PYG{+w}{ }v5.3.0
loading\PYG{+w}{ }translations\PYG{+w}{ }\PYG{o}{[}ru\PYG{o}{]}...\PYG{+w}{ }готово
loading\PYG{+w}{ }pickled\PYG{+w}{ }environment...\PYG{+w}{ }готово
building\PYG{+w}{ }\PYG{o}{[}mo\PYG{o}{]}:\PYG{+w}{ }targets\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }po\PYG{+w}{ }files\PYG{+w}{ }that\PYG{+w}{ }are\PYG{+w}{ }out\PYG{+w}{ }of\PYG{+w}{ }date
building\PYG{+w}{ }\PYG{o}{[}html\PYG{o}{]}:\PYG{+w}{ }targets\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }files\PYG{+w}{ }that\PYG{+w}{ }are\PYG{+w}{ }out\PYG{+w}{ }of\PYG{+w}{ }date
updating\PYG{+w}{ }environment:\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }added,\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }changed,\PYG{+w}{ }\PYG{l+m}{0}\PYG{+w}{ }removed
reading\PYG{+w}{ }sources...\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]}\PYG{+w}{ }index\PYG{+w}{                                                  }
looking\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }now\PYGZhy{}outdated\PYG{+w}{ }files...\PYG{+w}{ }none\PYG{+w}{ }found
pickling\PYG{+w}{ }environment...\PYG{+w}{ }готово
checking\PYG{+w}{ }consistency...\PYG{+w}{ }готово
preparing\PYG{+w}{ }documents...\PYG{+w}{ }готово
writing\PYG{+w}{ }output...\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]}\PYG{+w}{ }index\PYG{+w}{                                                   }
generating\PYG{+w}{ }indices...\PYG{+w}{ }genindex\PYG{+w}{ }готово
writing\PYG{+w}{ }additional\PYG{+w}{ }pages...\PYG{+w}{ }search\PYG{+w}{ }готово
copying\PYG{+w}{ }static\PYG{+w}{ }files...\PYG{+w}{ }готово
copying\PYG{+w}{ }extra\PYG{+w}{ }files...\PYG{+w}{ }готово
dumping\PYG{+w}{ }search\PYG{+w}{ }index\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }Russian\PYG{+w}{ }\PYG{o}{(}code:\PYG{+w}{ }ru\PYG{o}{)}...\PYG{+w}{ }готово
dumping\PYG{+w}{ }object\PYG{+w}{ }inventory...\PYG{+w}{ }готово
сборка\PYG{+w}{ }завершена\PYG{+w}{ }успешно.


\PYG{o}{(}mtracker\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp/test\PYGZus{}the\PYGZus{}docs/docs\PYGZdl{}\PYG{+w}{ }browse\PYG{+w}{ }./build/index.html
\end{sphinxVerbatim}

\sphinxAtStartPar
После этого должна открыться страница, на которой, кроме всего прочего, мы можем увидеть README.


\subsection{Markdown и Sphinx}
\label{\detokenize{educational_materials/docs/content:markdown-sphinx}}
\sphinxAtStartPar
Ниже приведены шаги (в ОС Linux), чтобы настроить окружение для сборки документации Markdown с помощью Sphinx. Мы использовали этот подход при сборке данного документа. Создайте виртуальное окружение (опционально):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }sphinx\PYGZus{}md\PYG{+w}{ }\PYG{n+nv}{python}\PYG{o}{=}\PYG{l+m}{3}.10
conda\PYG{+w}{ }activate\PYG{+w}{ }sphinx\PYGZus{}md
\end{sphinxVerbatim}

\sphinxAtStartPar
Установите Sphinx и поддержку Markdown:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }sphinx
pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}upgrade\PYG{+w}{ }myst\PYGZhy{}parser
\end{sphinxVerbatim}

\sphinxAtStartPar
Укажите, какие файлы должны войти в документацию:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{.. toolchain documentation master file, created by}
\PYG{c}{   sphinx\PYGZhy{}quickstart on Wed Mar  1 10:24:16 2023.}
\PYG{c}{   You can adapt this file completely to your liking, but it should at least}
\PYG{c}{   contain the root `toctree` directive.}

\PYG{g+gh}{Welcome to toolchain\PYGZsq{}s documentation!}
\PYG{g+gh}{=====================================}

\PYG{p}{..} \PYG{o+ow}{toctree}\PYG{p}{::}
  \PYG{n+nc}{:maxdepth:} 2
  \PYG{n+nc}{:caption:} Contents:

  00\PYGZus{}terms/main.md
  01\PYGZus{}open\PYGZus{}source/main.md
  
\PYG{g+gh}{Indices and tables}
\PYG{g+gh}{==================}

\PYG{l+m}{*} \PYG{n+na}{:ref:}\PYG{n+nv}{`genindex`}
\PYG{l+m}{*} \PYG{n+na}{:ref:}\PYG{n+nv}{`modindex`}
\PYG{l+m}{*} \PYG{n+na}{:ref:}\PYG{n+nv}{`search`}
\end{sphinxVerbatim}

\sphinxAtStartPar
Соберите html (находясь в корневой директории проекта):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
make\PYG{+w}{ }html
\end{sphinxVerbatim}

\sphinxAtStartPar
В корневой директории появится папка build, где будет находиться собранная документация.

\sphinxAtStartPar
Для сборки pdf установите latexmk и поддержку кириллицы:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }apt\PYG{+w}{ }install\PYG{+w}{ }latexmk
sudo\PYG{+w}{ }apt\PYG{+w}{ }install\PYG{+w}{ }texlive\PYGZhy{}lang\PYGZhy{}cyrillic
make\PYG{+w}{ }latexpdf
\end{sphinxVerbatim}


\subsection{Документация из кода}
\label{\detokenize{educational_materials/docs/content:id11}}
\sphinxAtStartPar
Здесь речь пойдет о том, как писать комментарии к коду так, чтобы из них можно было собрать документацию. В Python мы можем снабдить функции и классы многострочным комментарием, который будет распознаваться системами сборки документации как docstring, и на их основе будет формироваться документация к вашему проекту. В документацию попадут не все комментарии их кода, а только тe, которые оформлены как docstring. Правильно оформленный docstring может помочь другим разработчикам, а спустя время даже вам, разобраться в работе функции.

\sphinxAtStartPar
Для того чтобы создать комментарий, нужно заключить текст в тройные кавычки. Существует несколько форматов оформления docstring, ниже приведено форматирование в \sphinxstylestrong{стиле Google}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}function}\PYG{p}{(}\PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Brief description of the function.}

\PYG{l+s+sd}{    More detailed explanation of the function\PYGZsq{}s purpose,}
\PYG{l+s+sd}{    arguments, and expected behavior.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        arg1 (type): Description of the first parameter.}
\PYG{l+s+sd}{        arg2 (type): Description of the second parameter.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        return\PYGZus{}type: Description of the value returned by the function.}

\PYG{l+s+sd}{    Raises:}
\PYG{l+s+sd}{        ExceptionType: Description of the exception raised, if any.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Function implementation here}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что есть несколько разделов внутри docstring.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Краткое описание (в одну строку).
* Более подробное описание.
* Входные аргументы с указанием типов.
* Тип и описание выходного значения.
* Какие ошибки могут быть выброшены из функции?
\end{sphinxVerbatim}

\sphinxAtStartPar
Также можно оформить docstring в других форматах, например, в \sphinxstylestrong{стиле Sphinx}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}function}\PYG{p}{(}\PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Brief description of the function.}

\PYG{l+s+sd}{    :param arg1: Description of the first argument.}
\PYG{l+s+sd}{    :type arg1: type}
\PYG{l+s+sd}{    :param arg2: Description of the second argument.}
\PYG{l+s+sd}{    :type arg2: type}
\PYG{l+s+sd}{    :return: Description of the value returned by the function.}
\PYG{l+s+sd}{    :rtype: return\PYGZus{}type}
\PYG{l+s+sd}{    :raises ExceptionType: Description of the exception raised, if any.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Function implementation here}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\sphinxAtStartPar
Или в \sphinxstylestrong{стиле NumpyDoc}, который был вдохновлен документацией к библиотеке \sphinxcode{\sphinxupquote{numpy}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}function}\PYG{p}{(}\PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Brief description of the function.}

\PYG{l+s+sd}{    Parameters}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    arg1 : type}
\PYG{l+s+sd}{        Description of the first argument.}
\PYG{l+s+sd}{    arg2 : type}
\PYG{l+s+sd}{        Description of the second argument.}

\PYG{l+s+sd}{    Returns}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    return\PYGZus{}type}
\PYG{l+s+sd}{        Description of the value returned by the function.}

\PYG{l+s+sd}{    Raises}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    ExceptionType}
\PYG{l+s+sd}{        Description of the exception raised, if any.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Function implementation here}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}


\subsection{Оформление документации}
\label{\detokenize{educational_materials/docs/content:id12}}
\sphinxAtStartPar
Теперь попробуем попрактиковаться с документацией. Мы хотим создать следующую структуру проекта, назначение файлов станет понятно ниже. Часть файлов будет сгенерирована автоматически, другие мы будем править, оставшиеся нам нужно будет создать самим.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
project/
├── docs/
│   ├── Makefile
│   ├── conf.py
│   ├── index.rst
│   ├── usage.rst
│   └── api.rst
└── src/
    └── utils\PYGZus{}mix.py

\end{sphinxVerbatim}

\sphinxAtStartPar
Создадим новый проект, который назовем \sphinxcode{\sphinxupquote{utils\_mix}}. Создадим в нем две папки: \sphinxcode{\sphinxupquote{src}} для кода и \sphinxcode{\sphinxupquote{docs}} для документации.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir\PYG{+w}{ }src
mkdir\PYG{+w}{ }docs
\end{sphinxVerbatim}

\sphinxAtStartPar
Перейдем в папку \sphinxcode{\sphinxupquote{docs}} и выполним там инициализацию с помощью \sphinxcode{\sphinxupquote{sphinx}}, который мы ранее установили с помощью \sphinxcode{\sphinxupquote{pip install sphinx}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }docs
sphinx\PYGZhy{}quickstart
\end{sphinxVerbatim}

\sphinxAtStartPar
После этого утилита запросит нужную информацию.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{    }Please\PYG{+w}{ }enter\PYG{+w}{ }values\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }the\PYG{+w}{ }following\PYG{+w}{ }settings\PYG{+w}{ }\PYG{o}{(}just\PYG{+w}{ }press\PYG{+w}{ }Enter\PYG{+w}{ }to
\PYG{+w}{    }accept\PYG{+w}{ }a\PYG{+w}{ }default\PYG{+w}{ }value,\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }one\PYG{+w}{ }is\PYG{+w}{ }given\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }brackets\PYG{o}{)}.
\PYG{+w}{    }
\PYG{+w}{    }Selected\PYG{+w}{ }root\PYG{+w}{ }path:\PYG{+w}{ }.
\PYG{+w}{    }
\PYG{+w}{    }You\PYG{+w}{ }have\PYG{+w}{ }two\PYG{+w}{ }options\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }placing\PYG{+w}{ }the\PYG{+w}{ }build\PYG{+w}{ }directory\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }Sphinx\PYG{+w}{ }output.
\PYG{+w}{    }Either,\PYG{+w}{ }you\PYG{+w}{ }use\PYG{+w}{ }a\PYG{+w}{ }directory\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZus{}build\PYGZdq{}}\PYG{+w}{ }within\PYG{+w}{ }the\PYG{+w}{ }root\PYG{+w}{ }path,\PYG{+w}{ }or\PYG{+w}{ }you\PYG{+w}{ }separate
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}source\PYGZdq{}}\PYG{+w}{ }and\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}build\PYGZdq{}}\PYG{+w}{ }directories\PYG{+w}{ }within\PYG{+w}{ }the\PYG{+w}{ }root\PYG{+w}{ }path.
\PYG{+w}{    }\PYGZgt{}\PYG{+w}{ }Separate\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }and\PYG{+w}{ }build\PYG{+w}{ }directories\PYG{+w}{ }\PYG{o}{(}y/n\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}n\PYG{o}{]}:\PYG{+w}{ }n
\PYG{+w}{    }
\PYG{+w}{    }The\PYG{+w}{ }project\PYG{+w}{ }name\PYG{+w}{ }will\PYG{+w}{ }occur\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }several\PYG{+w}{ }places\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }the\PYG{+w}{ }built\PYG{+w}{ }documentation.
\PYG{+w}{    }\PYGZgt{}\PYG{+w}{ }Project\PYG{+w}{ }name:\PYG{+w}{ }utils\PYGZus{}mix
\PYG{+w}{    }\PYGZgt{}\PYG{+w}{ }Author\PYG{+w}{ }name\PYG{o}{(}s\PYG{o}{)}:\PYG{+w}{ }ArtemVesnin
\PYG{+w}{    }\PYGZgt{}\PYG{+w}{ }Релиз\PYG{+w}{ }проекта\PYG{+w}{ }\PYG{o}{[}\PYG{o}{]}:\PYG{+w}{ }\PYG{l+m}{1}.0.
\PYG{+w}{    }\PYGZgt{}\PYG{+w}{ }Язык\PYG{+w}{ }проекта\PYG{+w}{ }\PYG{o}{[}en\PYG{o}{]}:\PYG{+w}{ }en
\end{sphinxVerbatim}

\sphinxAtStartPar
И создаст несколько файлов, включая \sphinxcode{\sphinxupquote{Makefile}} для автоматический сборки.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls
\PYG{+w}{    }\PYGZus{}build\PYG{+w}{  }conf.py\PYG{+w}{  }index.rst\PYG{+w}{  }make.bat\PYG{+w}{  }Makefile\PYG{+w}{  }\PYGZus{}static\PYG{+w}{  }\PYGZus{}templates
\end{sphinxVerbatim}

\sphinxAtStartPar
В текущем состоянии документация будет собираться и доступна, если открыть в браузере \sphinxcode{\sphinxupquote{\_build/html/index.html}}, но мы пока мы не увидим документации по коду.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
make\PYG{+w}{ }html

\PYG{+w}{    }Running\PYG{+w}{ }Sphinx\PYG{+w}{ }v7.0.1
\PYG{+w}{    }making\PYG{+w}{ }output\PYG{+w}{ }directory...\PYG{+w}{ }готово
\PYG{+w}{    }....
\PYG{+w}{    }....
\PYG{+w}{    }dumping\PYG{+w}{ }object\PYG{+w}{ }inventory...\PYG{+w}{ }готово
\PYG{+w}{    }сборка\PYG{+w}{ }завершена\PYG{+w}{ }успешно.
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь перейдем в папку \sphinxcode{\sphinxupquote{src}} и создадим там модуль \sphinxcode{\sphinxupquote{utils\_mix.py}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }../src
touch\PYG{+w}{ }utils\PYGZus{}mix.py
\end{sphinxVerbatim}

\sphinxAtStartPar
И добавим в этот модуль код с написанными docstring.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Add two numbers together.}

\PYG{l+s+sd}{    This function takes two numeric arguments, `num1` and `num2`,}
\PYG{l+s+sd}{    and returns their sum.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        num1 (int or float): The first number to be added.}
\PYG{l+s+sd}{        num2 (int or float): The second number to be added.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        float: The sum of `num1` and `num2`.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{num1} \PYG{o}{+} \PYG{n}{num2}

\PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Multiply two numbers.}

\PYG{l+s+sd}{    This function takes two numeric arguments, `num1` and `num2`,}
\PYG{l+s+sd}{    and returns their product.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        num1 (int or float): The first number to be multiplied.}
\PYG{l+s+sd}{        num2 (int or float): The second number to be multiplied.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        float: The product of `num1` and `num2`.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{num1} \PYG{o}{*} \PYG{n}{num2}

\PYG{k}{def} \PYG{n+nf}{greet}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Greet a person.}

\PYG{l+s+sd}{    This function takes a string argument `name` and returns a greeting message.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        name (str): The name of the person to greet.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        str: A greeting message with the person\PYGZsq{}s name.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{! How are you today?}\PYG{l+s+s2}{\PYGZdq{}}

\end{sphinxVerbatim}

\sphinxAtStartPar
Мы можем структурировать нашу документацию, в нашем случае мы хотим, чтобы docstring попали в раздел API. Создадим файл api.rst и добавим в него следующее содержание.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gh}{API Reference}
\PYG{g+gh}{=============}

\PYG{p}{..} \PYG{o+ow}{automodule}\PYG{p}{::} utils\PYGZus{}mix
   \PYG{n+nc}{:members:}
   \PYG{n+nc}{:undoc\PYGZhy{}members:}
   \PYG{n+nc}{:show\PYGZhy{}inheritance:}
\end{sphinxVerbatim}

\sphinxAtStartPar
Таким образом мы говорим, что нужно сгенерировать документацию из модуля \sphinxcode{\sphinxupquote{utils\_mix}} (файл \sphinxcode{\sphinxupquote{utils\_mix.py}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* `:members:` чтобы включить функции и классы из модуля
* `:undoc\PYGZhy{}members:` для того чтобы включить даже то у чего нет docstring (опционально)
* `:show\PYGZhy{}inheritance:` для того чтобы показывать информацию о наследовании классов друг другом.
\end{sphinxVerbatim}

\sphinxAtStartPar
И изменим \sphinxcode{\sphinxupquote{index.rst}}, чтобы \sphinxcode{\sphinxupquote{api.rst}} стал включен в общую структуру. Добавим строку api в раздел \sphinxcode{\sphinxupquote{.. toctree::}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{toctree}\PYG{p}{::}
   \PYG{n+nc}{:maxdepth:} 2
   \PYG{n+nc}{:caption:} Contents:

   api
\end{sphinxVerbatim}

\sphinxAtStartPar
Последнее изменение, которое нам нужно сделать, это добавить в \sphinxcode{\sphinxupquote{conf.py}} несколько строчек кода так, чтобы система сборки находила модули автоматически:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../src}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
И включить поддержку сборки документации из docstring:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extensions} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sphinx.ext.autodoc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Запускаем сборку еще раз и получаем

\sphinxAtStartPar
\sphinxincludegraphics{{api_reference_html}.png}

\sphinxAtStartPar
Мы также можем включать документы, которые написаны нами (а не сгенерированы автоматически), например, примеры по использованию кода. Создадим файл \sphinxcode{\sphinxupquote{usage.rst}} и добавим в него следующее содержимое.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gh}{Usage Guide}
\PYG{g+gh}{===========}

\PYG{g+gh}{Introduction}
\PYG{g+gh}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

Welcome to the usage guide for \PYG{n+nv}{`utils\PYGZus{}mix`}. This guide provides examples and explanations on how to use the functions defined in the \PYG{n+nv}{`utils\PYGZus{}mix`} Python module.

\PYG{g+gh}{Importing the Module}
\PYG{g+gh}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

To start using \PYG{n+nv}{`utils\PYGZus{}mix`}, you need to import it into your Python script or interactive session:

\PYG{p}{..} \PYG{o+ow}{code\PYGZhy{}block}\PYG{p}{::} \PYG{k}{python}

   \PYG{k+kn}{import} \PYG{n+nn}{utils\PYGZus{}mix}

\PYG{g+gh}{Add and Multiply Numbers}
\PYG{g+gh}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

The \PYG{n+nv}{`utils\PYGZus{}mix`} provides two simple functions for basic arithmetic operations:

\PYG{l+m}{\PYGZhy{}} \PYG{n+na}{:func:}\PYG{n+nv}{`utils\PYGZus{}mix.add\PYGZus{}numbers`}: Add two numbers together.
\PYG{l+m}{\PYGZhy{}} \PYG{n+na}{:func:}\PYG{n+nv}{`utils.multiply\PYGZus{}numbers`}: Multiply two numbers.

Example usages:

\PYG{p}{..} \PYG{o+ow}{code\PYGZhy{}block}\PYG{p}{::} \PYG{k}{python}

   \PYG{c+c1}{\PYGZsh{} Import the module}
   \PYG{k+kn}{from} \PYG{n+nn}{utils\PYGZus{}mix} \PYG{k+kn}{import} \PYG{n}{add\PYGZus{}numbers}\PYG{p}{,} \PYG{n}{multiply\PYGZus{}numbers}

   \PYG{c+c1}{\PYGZsh{} Add two numbers}
   \PYG{n}{result1} \PYG{o}{=} \PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result of addition:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Output: 3}

   \PYG{c+c1}{\PYGZsh{} Multiply two numbers}
   \PYG{n}{result2} \PYG{o}{=} \PYG{n}{multiply\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result of multiplication:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Output: 30}

\PYG{g+gh}{Greet a Person}
\PYG{g+gh}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

The \PYG{n+nv}{`utils\PYGZus{}mix`} also provides a simple function to greet a person:

\PYG{l+m}{\PYGZhy{}} \PYG{n+na}{:func:}\PYG{n+nv}{`utils\PYGZus{}mix.greet`}: Greet a person with a custom message.

Example usage:

\PYG{p}{..} \PYG{o+ow}{code\PYGZhy{}block}\PYG{p}{::} \PYG{k}{python}

   \PYG{c+c1}{\PYGZsh{} Import the module}
   \PYG{k+kn}{from} \PYG{n+nn}{utils\PYGZus{}mix} \PYG{k+kn}{import} \PYG{n}{greet}

   \PYG{c+c1}{\PYGZsh{} Greet a person}
   \PYG{n}{greeting} \PYG{o}{=} \PYG{n}{greet}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{greeting}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Output: Hello, Alice! How are you today?}
\end{sphinxVerbatim}

\sphinxAtStartPar
Включим его в документацию так же, как мы делали с \sphinxcode{\sphinxupquote{api.rst}}, сделаем сборку \sphinxcode{\sphinxupquote{make html}} и увидим обновленную документацию:

\sphinxAtStartPar
\sphinxincludegraphics{{docs_html}.png}

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/docs/exercises:id1}}\label{\detokenize{educational_materials/docs/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/docs/exercises:id2}}
\sphinxAtStartPar
Есть два модуля. Функции одного рассчитывают хэши и делают поиск дубликатов по ним. Функции второго заключаются в поиске дубликатов файлов. Напишите документацию к ним и сделайте автоматическую сборку при помощи Sphinx.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}content of duplicate\PYGZus{}finder.py}
\PYG{k+kn}{import} \PYG{n+nn}{hashlib}

\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}hash}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{hashlib}\PYG{o}{.}\PYG{n}{sha256}\PYG{p}{(}\PYG{n}{text}\PYG{o}{.}\PYG{n}{encode}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hexdigest}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}duplicates}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{duplicates} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{line\PYGZus{}hash} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}hash}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{line\PYGZus{}hash} \PYG{o+ow}{in} \PYG{n}{duplicates}\PYG{p}{:}
            \PYG{n}{duplicates}\PYG{p}{[}\PYG{n}{line\PYGZus{}hash}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{duplicates}\PYG{p}{[}\PYG{n}{line\PYGZus{}hash}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{duplicates}
\end{sphinxVerbatim}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}content of file\PYGZus{}processor.py}

\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{duplicate\PYGZus{}hash} \PYG{k+kn}{import} \PYG{n}{find\PYGZus{}duplicates}

\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}files}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{duplicates\PYGZus{}found} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{filename} \PYG{o+ow}{in} \PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{file\PYGZus{}path} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
                \PYG{n}{lines} \PYG{o}{=} \PYG{n}{file}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{file\PYGZus{}duplicates} \PYG{o}{=} \PYG{n}{find\PYGZus{}duplicates}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{line\PYGZus{}hash}\PYG{p}{,} \PYG{n}{line\PYGZus{}numbers} \PYG{o+ow}{in} \PYG{n}{file\PYGZus{}duplicates}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{if} \PYG{n}{line\PYGZus{}hash} \PYG{o+ow}{in} \PYG{n}{duplicates\PYGZus{}found}\PYG{p}{:}
                        \PYG{n}{duplicates\PYGZus{}found}\PYG{p}{[}\PYG{n}{line\PYGZus{}hash}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{line\PYGZus{}numbers}\PYG{p}{)}\PYG{p}{)}
                    \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{duplicates\PYGZus{}found}\PYG{p}{[}\PYG{n}{line\PYGZus{}hash}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{line\PYGZus{}numbers}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{duplicates\PYGZus{}found}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Example usage}
    \PYG{n}{directory\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example\PYGZus{}files}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} Replace with your target directory path}
    \PYG{n}{duplicates} \PYG{o}{=} \PYG{n}{process\PYGZus{}files}\PYG{p}{(}\PYG{n}{directory\PYGZus{}path}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{line\PYGZus{}hash}\PYG{p}{,} \PYG{n}{occurrences} \PYG{o+ow}{in} \PYG{n}{duplicates}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hash: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{line\PYGZus{}hash}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{line\PYGZus{}numbers} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ \PYGZhy{} File: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{filename}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, Line Numbers: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{line\PYGZus{}numbers}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
Так как написание документации — творческий процесс и, в отличие от кода, нельзя сказать, что документация работает правильно, в качестве критериев для оценивания этого задания можно взять два:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* после прочтения документации становится понятно, как использовать функцию;
* после прочтения документации складывается представление о внутренней реализации функции.
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/docs/exercises:id3}}
\sphinxAtStartPar
Напишите генератор для тестовых данных для функции поиска дубликатов, используя документацию к функциям. Предположим, что ее написали заранее.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}unique\PYGZus{}words}\PYG{p}{(}\PYG{n}{num\PYGZus{}words}\PYG{p}{,} \PYG{n}{max\PYGZus{}len}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Generate a list of unique words.}

\PYG{l+s+sd}{    This function generates a list of unique words with the specified }
\PYG{l+s+sd}{    number of words (num\PYGZus{}words) and maximum word length (max\PYGZus{}len). }
\PYG{l+s+sd}{    It uses a set to ensure uniqueness.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        num\PYGZus{}words (int): The number of unique words to generate.}
\PYG{l+s+sd}{        max\PYGZus{}len (int): The maximum length of each word.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        list: A list of unique words.}

\PYG{l+s+sd}{    Example:}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} unique\PYGZus{}words = generate\PYGZus{}unique\PYGZus{}words(num\PYGZus{}words=20, max\PYGZus{}len=8)}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(unique\PYGZus{}words)}
\PYG{l+s+sd}{        [\PYGZsq{}ghijklmn\PYGZsq{}, \PYGZsq{}opqrst\PYGZsq{}, \PYGZsq{}abcd\PYGZsq{}, \PYGZsq{}uvwx\PYGZsq{}, \PYGZsq{}ef\PYGZsq{}, \PYGZsq{}yz\PYGZsq{}, \PYGZsq{}ij\PYGZsq{}, \PYGZsq{}klm\PYGZsq{}, \PYGZsq{}gh\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}nopq\PYGZsq{}, \PYGZsq{}rs\PYGZsq{}, \PYGZsq{}tuvw\PYGZsq{},\PYGZsq{}jkl\PYGZsq{}, \PYGZsq{}defg\PYGZsq{}, \PYGZsq{}cde\PYGZsq{}, \PYGZsq{}ijk\PYGZsq{}, \PYGZsq{}lmn\PYGZsq{}, \PYGZsq{}mn\PYGZsq{}, \PYGZsq{}hi\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}pqrs\PYGZsq{}]}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{pass}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}unique\PYGZus{}lines}\PYG{p}{(}\PYG{n}{words}\PYG{p}{,} \PYG{n}{num\PYGZus{}lines}\PYG{p}{,} \PYG{n}{max\PYGZus{}words}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Generate a list of unique lines.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        words (list): A list of unique words.}
\PYG{l+s+sd}{        num\PYGZus{}lines (int): The number of unique lines to generate.}
\PYG{l+s+sd}{        max\PYGZus{}words (int): The maximum number of words in each line.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        list: A list of unique lines.}

\PYG{l+s+sd}{    Example:}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} unique\PYGZus{}words = [\PYGZsq{}ghijklmn\PYGZsq{}, \PYGZsq{}opqrst\PYGZsq{}, \PYGZsq{}abcd\PYGZsq{}, \PYGZsq{}uvwx\PYGZsq{}, \PYGZsq{}ef\PYGZsq{}, \PYGZsq{}yz\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}ij\PYGZsq{}, \PYGZsq{}klm\PYGZsq{}, \PYGZsq{}gh\PYGZsq{}, \PYGZsq{}nopq\PYGZsq{}, \PYGZsq{}rs\PYGZsq{}, \PYGZsq{}tuvw\PYGZsq{}, \PYGZsq{}jkl\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}defg\PYGZsq{}, \PYGZsq{}cde\PYGZsq{}, \PYGZsq{}ijk\PYGZsq{}, \PYGZsq{}lmn\PYGZsq{}, \PYGZsq{}mn\PYGZsq{}, \PYGZsq{}hi\PYGZsq{}, \PYGZsq{}pqrs\PYGZsq{}]}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} unique\PYGZus{}lines = generate\PYGZus{}unique\PYGZus{}lines(words=unique\PYGZus{}words, num\PYGZus{}lines=10, max\PYGZus{}words=6)}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(unique\PYGZus{}lines)}
\PYG{l+s+sd}{        [\PYGZsq{}pqrs ij ghi pqrs pqrs klm nopq\PYGZsq{}, \PYGZsq{}opqrst pqrs pqrs ij pqrs\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}klmnopqrs pqrs jkl ij ghi rs pqrs\PYGZsq{}, \PYGZsq{}jkl ij jkl defg pqrs ijk lmn\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}defg cde ghi opqrst pqrs klm pqrs\PYGZsq{}, \PYGZsq{}cde ghi klm ij\PYGZsq{}, \PYGZsq{}jkl jkl ijk klm\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}lmn pqrs opqrst\PYGZsq{}, \PYGZsq{}ijklmn ghi\PYGZsq{}, \PYGZsq{}rs\PYGZsq{}]}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{pass}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}duplicates}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{,} \PYG{n}{num\PYGZus{}dup}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{   }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Generate duplicates and their positions. }

\PYG{l+s+sd}{    Duplicates are placed in the end of input list. Duplicate positions}
\PYG{l+s+sd}{    should include atleast 2 values for every duplicate: original line }
\PYG{l+s+sd}{    position and position of duplicates originated from this line).}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{        lines (list): A list of unique lines.}
\PYG{l+s+sd}{        num\PYGZus{}dup (int): The number of duplicates to generate.}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        list: A list of unique lines extended with duplicates.}
\PYG{l+s+sd}{        dict: A dictionary containing positions of duplicates in the extended list.}

\PYG{l+s+sd}{    Example:}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} unique\PYGZus{}lines = [\PYGZsq{}pqrs ij ghi pqrs pqrs klm nopq\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}opqrst pqrs pqrs ij pqrs\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}klmnopqrs pqrs jkl ij ghi rs pqrs\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}jkl ij jkl defg pqrs ijk lmn\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}defg cde ghi opqrst pqrs klm pqrs\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}cde ghi klm ij\PYGZsq{}, \PYGZsq{}jkl jkl ijk klm\PYGZsq{}, }
\PYG{l+s+sd}{                            \PYGZsq{}lmn pqrs opqrst\PYGZsq{}, \PYGZsq{}ijklmn ghi\PYGZsq{}, \PYGZsq{}rs\PYGZsq{}]}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} num\PYGZus{}duplicates = 3}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} extended\PYGZus{}lines, duplicates\PYGZus{}positions = \PYGZbs{}}
\PYG{l+s+sd}{                generate\PYGZus{}duplicates(lines=unique\PYGZus{}lines, num\PYGZus{}dup=num\PYGZus{}duplicates)}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(\PYGZdq{}Extended Lines:\PYGZdq{})}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(extended\PYGZus{}lines)}
\PYG{l+s+sd}{        [\PYGZsq{}pqrs ij ghi pqrs pqrs klm nopq\PYGZsq{}, \PYGZsq{}opqrst pqrs pqrs ij pqrs\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}klmnopqrs pqrs jkl ij ghi rs pqrs\PYGZsq{}, \PYGZsq{}jkl ij jkl defg pqrs ijk lmn\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}defg cde ghi opqrst pqrs klm pqrs\PYGZsq{}, \PYGZsq{}cde ghi klm ij\PYGZsq{}, \PYGZsq{}jkl jkl ijk klm\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}lmn pqrs opqrst\PYGZsq{}, \PYGZsq{}ijklmn ghi\PYGZsq{}, \PYGZsq{}rs\PYGZsq{}, \PYGZsq{}klmnopqrs pqrs jkl ij ghi rs pqrs\PYGZsq{}, }
\PYG{l+s+sd}{         \PYGZsq{}cde ghi klm ij\PYGZsq{}, \PYGZsq{}ijklmn ghi\PYGZsq{}]}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(\PYGZdq{}\PYGZbs{}nPositions of Duplicates:\PYGZdq{})}
\PYG{l+s+sd}{        \PYGZgt{}\PYGZgt{}\PYGZgt{} print(duplicates\PYGZus{}positions)}
\PYG{l+s+sd}{        \PYGZob{}\PYGZsq{}klmnopqrs pqrs jkl ij ghi rs pqrs\PYGZsq{}: [2, 10], }
\PYG{l+s+sd}{         \PYGZsq{}cde ghi klm ij\PYGZsq{}: [5, 11], }
\PYG{l+s+sd}{         \PYGZsq{}ijklmn ghi\PYGZsq{}: [9, 12]\PYGZcb{}}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{pass}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}unique\PYGZus{}words}\PYG{p}{(}\PYG{n}{num\PYGZus{}words}\PYG{p}{,} \PYG{n}{max\PYGZus{}len}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{words} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}words}\PYG{p}{:}
        \PYG{n}{word\PYGZus{}len} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{max\PYGZus{}len}\PYG{p}{)}
        \PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcdefghijklmnopqrstuvwxyz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{word\PYGZus{}len}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{words}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}unique\PYGZus{}lines}\PYG{p}{(}\PYG{n}{words}\PYG{p}{,} \PYG{n}{num\PYGZus{}lines}\PYG{p}{,} \PYG{n}{max\PYGZus{}words}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lines} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}lines}\PYG{p}{:}
        \PYG{n}{line\PYGZus{}words\PYGZus{}count} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{max\PYGZus{}words}\PYG{p}{)}
        \PYG{n}{line\PYGZus{}words} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{words}\PYG{p}{,} \PYG{n}{line\PYGZus{}words\PYGZus{}count}\PYG{p}{)}
        \PYG{n}{line} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{line\PYGZus{}words}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{line} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{lines}\PYG{p}{:}
            \PYG{n}{lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{lines}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}duplicates}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{,} \PYG{n}{num\PYGZus{}dup}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{duplicates} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{,} \PYG{n}{num\PYGZus{}dup}\PYG{p}{)}
    \PYG{n}{duplicates\PYGZus{}positions} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{duplicates}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{duplicates\PYGZus{}positions}\PYG{p}{:}
                \PYG{n}{duplicates\PYGZus{}positions}\PYG{p}{[}\PYG{n}{line}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{duplicates\PYGZus{}positions}\PYG{p}{[}\PYG{n}{line}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Extend the lines with duplicates}
    \PYG{n}{extended\PYGZus{}lines} \PYG{o}{=} \PYG{n}{lines} \PYG{o}{+} \PYG{n}{duplicates}

    \PYG{c+c1}{\PYGZsh{} Add duplicate positions for each duplicated line}
    \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{duplicates\PYGZus{}positions}\PYG{p}{:}
        \PYG{n}{occurrences} \PYG{o}{=} \PYG{n}{duplicates\PYGZus{}positions}\PYG{p}{[}\PYG{n}{line}\PYG{p}{]}
        \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{:}
            \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{extended\PYGZus{}lines}\PYG{p}{,} \PYG{n}{duplicates\PYGZus{}positions}

\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/docs/exercises:id4}}
\sphinxAtStartPar
Работайте в командах. Опишите и реализуйте функции для тестирования функций поиска дубликатов с помощью генератора. Сначала сделайте описание того, что вы хотите получить и какие условия (случаи) нужно реализовать, чтобы считать, что функции работают правильно. Поменяйтесь описанием с другой командой.

\sphinxAtStartPar
Реализуйте описанное другой командой в коде. Передайте свою реализацию команде, которая делала описание, и обсудите с ней, правильно ли реализовано задуманное (ошибки в реализации могут быть как по причине неполной документации, так и по причине неправильного прочтения документации).

\sphinxAtStartPar
Возьмите реализацию у команды, которой передавали свое описание, и также обсудите правильность реализации, но уже с позиции тех, кто предоставлял документацию.

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/docs/quiz:id1}}\label{\detokenize{educational_materials/docs/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какова основная цель строки документации (docstring) в Python?
а) Написать подробные пояснения к каждой строке кода.
б) Предоставить обзор всей кодовой базы.
в) Служить руководством пользователя для конечных пользователей программного обеспечения.
г) Документировать назначение, использование и параметры функций, классов или модулей.

\item {} 
\sphinxAtStartPar
Какой из следующих форматов разметки обычно используется для строк документации (docstring) в Python?
а) Markdown
б) HTML
в) ReStructuredText
г) Latex

\item {} 
\sphinxAtStartPar
Как обычно называется файл документации, содержащий обзор проекта и инструкции по его использованию?
а) PROJECT.md
б) DOCS.txt
в) README.md
г) ОБЗОР.первый

\item {} 
\sphinxAtStartPar
Какая команда используется в Sphinx для создания HTML\sphinxhyphen{}документации из исходных файлов с текстом документацией в форматах Markdown или ReStructuredText?
а) \sphinxcode{\sphinxupquote{make html}}
б) \sphinxcode{\sphinxupquote{sphinx\sphinxhyphen{}build html}}
в) \sphinxcode{\sphinxupquote{build html}}
г) \sphinxcode{\sphinxupquote{generate html}}

\item {} 
\sphinxAtStartPar
Как получить доступ к строкам документации (docstring) в Python?
а) Путем запуска скрипта Python с определенным аргументом командной строки.
б) Вызовом функции \sphinxcode{\sphinxupquote{docstrings()}} для модуля или класса.
в) Используя атрибут \sphinxcode{\sphinxupquote{\_\_doc\_\_}} функции, класса или модуля.
г) Импортируя модуль \sphinxcode{\sphinxupquote{docstrings}}.

\item {} 
\sphinxAtStartPar
Что должно быть включено в строку документации (docstring) для функции?
а) Детали реализации функции.
б) Описание назначения, параметров, сценариев использования функции.
в) Личное мнение и комментарии о полезности функции.
d) Информация о лицензировании и сведения об авторских правах.

\item {} 
\sphinxAtStartPar
В какой раздел файла README вы обычно включаете инструкции по установке данного пакета/библиотеки?
а) Overview
б) Usage
в) Installation
г) Contributing

\item {} 
\sphinxAtStartPar
Какова основная цель файла README в проекте Python?
а) Предоставить обзор интерпретатора Python.
б) Предоставить список зависимостей, необходимых для запуска проекта.
в) Документировать назначение и использование функций в проекте.
г) Предоставить введение и основную информацию о проекте.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\end{enumerate}


\chapter{Основы тестирования}
\label{\detokenize{index:id14}}
\sphinxstepscope


\section{Тестирование}
\label{\detokenize{educational_materials/testing/content:id1}}\label{\detokenize{educational_materials/testing/content::doc}}
\sphinxAtStartPar
Тестирование — это способ убедиться, что код делает то, что мы ожидаем от него. Существует ручное и автоматическое тестирование. При ручном тестировании человек выполняет шаги из инструкции и фиксирует поведение приложения или кода. При автоматическом тесты выполняются специальным инструментом, и собирается статистика пройденных или проваленных тестов.
Зачем нужно ручное тестирование, когда автоматические тесты выглядят гораздо удобней — один раз написал и пользуйся? Ручные тесты с привлечением человека незаменимы, когда речь идет об апробации интерфейса. И в любых других задачах, когда сложно сформулировать критерии правильной работы. Здесь речь шла о готовом приложении, когда речь идет о коде, автоматическое тестирование незаменимо. Без автоматического тестирования невозможно было обеспечить \sphinxhref{https://www.atlassian.com/continuous-delivery/continuous-integration/how-to-get-to-continuous-integration}{CI} /\sphinxhref{https://aws.amazon.com/ru/devops/continuous-delivery/}{CD} (continuous integration/continuous delivery). CI/CD позволяют иметь оттестированную версию приложения в любой момент времени.


\subsection{Мотивация}
\label{\detokenize{educational_materials/testing/content:id2}}
\sphinxAtStartPar
Существует несколько аргументов, что тесты — это не пустая трата времени:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Первая очевидная функция — это уменьшение вероятности возникновения ошибок в коде. Много мелких ошибок могут привести к серьезной проблеме, и тесты призваны предотвратить появление таких ошибок в коде. Существуют системы, которые будут автоматически проводить тестирование при загрузке кода в репозиторий, и это просто не даст разработчику залить не полностью рабочий код, но это возможно только при наличии автоматизированных тестов.

\item {} 
\sphinxAtStartPar
Этот пункт скорее психологический — у разработчика появляется инструмент, который подскажет ему, если он ошибся. Разработчик тратит меньше внимания на возможность возникновения ошибок, ведь у него есть система тестов, и соответственно больше внимания уделяет написанию кода, более смело экспериментирует, ведь тесты подскажут ему, если он сломал другой участок программы. Таким образом, тесты способствуют более быстрой работе и появлению более интересных решений.

\item {} 
\sphinxAtStartPar
Тесты можно рассматривать как своего рода документацию: то, как мы можем использовать функционал нашего приложения.

\end{enumerate}


\subsection{Виды тестов}
\label{\detokenize{educational_materials/testing/content:id3}}
\sphinxAtStartPar
Выделяют несколько видов тестирования.


\subsubsection{Модульное тестирование}
\label{\detokenize{educational_materials/testing/content:id4}}
\sphinxAtStartPar
Модульное или unit\sphinxhyphen{}тестирование. Как видно из названия, мы тестируем отдельные модули, или «единицы» (участки) кода. Модульные тесты наиболее близки к контексту конкретных функций или других логически обособленных участков кода. Отсюда вытекает одно из основных свойств модульных тестов — изолированность: если мы тестируем функцию \sphinxcode{\sphinxupquote{foo}}, то там не должно быть участков, связанных с функцией \sphinxcode{\sphinxupquote{bar}}. Модульные тесты позволяют проверить отдельные части кода, прежде чем тестировать их совместно.

\sphinxAtStartPar
\sphinxincludegraphics{{testing_types}.png}

\sphinxAtStartPar
Модульное тестирование:
\begin{itemize}
\item {} 
\sphinxAtStartPar
может помочь при разработке: понимая, что каждый участок кода нужно будет протестировать отдельно, разработчик с большей вероятностью не будет создавать большие функции со смешанной логикой, а разобьет ту же функциональность на несколько маленьких функций, каждую из которых будет понятно, как протестировать. Это, в конечном счете, положительно влияет на то, как выглядит API библиотеки.

\item {} 
\sphinxAtStartPar
заставляет задуматься о входных данных, которые подаются на вход коду, и лучше погрузиться в контекст решаемой задачи.

\item {} 
\sphinxAtStartPar
позволяет протестировать часть кода, если в данный момент на другой частью работает другой человек, и она не проходит все тесты.

\item {} 
\sphinxAtStartPar
покрытие тестами всех возможных вариантов зависит от разработчика.

\item {} 
\sphinxAtStartPar
позволяет реализовывать подход «пиши код и тестируй одновременно». Так как модульные тесты атомарны по природе, мы можем выделять новые ситуации непосредственно во время написания кода и облачать их в тест.

\item {} 
\sphinxAtStartPar
позволяет другим разработчикам убедиться, что у них все настроено правильно и можно продолжать разработку. Если тесты не проходят, значит, нужно остановиться и донастроить рабочее окружение.

\end{itemize}

\sphinxAtStartPar
Преимущества наличия модульных тестов в коде могут быть неочевидны сначала, но проблемы, которые копятся из\sphinxhyphen{}за отсутствия или недостаточного количества тестов, постепенно будут копиться, и со временем мы перестанем писать новую функциональность, а будем только разбирать баги.

\sphinxAtStartPar
\sphinxincludegraphics{{no_test_cycle}.png}


\paragraph{Пример}
\label{\detokenize{educational_materials/testing/content:id5}}
\sphinxAtStartPar
Рассмотрим функции, которые генерируют последовательность N первых чисел целиком и отдельно четные и нечетные.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}content of series.py in my\PYGZus{}math package}
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{series} \PYG{o}{=} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{even\PYGZus{}series} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{series}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{even\PYGZus{}series}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{series} \PYG{o}{=} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{odd\PYGZus{}series} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{series}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{odd\PYGZus{}series}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что функции \sphinxcode{\sphinxupquote{get\_even\_series()}} и \sphinxcode{\sphinxupquote{get\_odd\_series()}} используют другую функцию \sphinxcode{\sphinxupquote{get\_series()}}. Это нормально и хорошо, когда есть возможность переиспользовать код в другом месте. Мы выделяем его в отдельный блок. Но все три функции должны быть протестированы без учета внутреннего устройства функции.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}content of test\PYGZus{}series.py}
\PYG{k+kn}{import} \PYG{n+nn}{pytest}

\PYG{k+kn}{from} \PYG{n+nn}{my\PYGZus{}math}\PYG{n+nn}{.}\PYG{n+nn}{series} \PYG{k+kn}{import} \PYG{p}{(}\PYG{n}{get\PYGZus{}series}\PYG{p}{,}
                            \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{,}
                            \PYG{n}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{TestSeries}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}series}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}odd\PYGZus{}series}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} test include the same code as in the function implementation}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}even\PYGZus{}series\PYGZus{}bad}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{5}
        \PYG{n}{even\PYGZus{}series} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{n}{even\PYGZus{}series}
    
    \PYG{c+c1}{\PYGZsh{} test include several functions that can be tested separetely}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}all\PYGZus{}series\PYGZus{}bad}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{5}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}
        
    \PYG{c+c1}{\PYGZsh{} might be a good test}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}series\PYGZus{}full}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{series} \PYG{o}{=} \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
        \PYG{n}{series}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{n}{series}
\end{sphinxVerbatim}

\sphinxAtStartPar
Давайте разберемся, что мы здесь видим. Тесты \sphinxcode{\sphinxupquote{test\_series}}, \sphinxcode{\sphinxupquote{test\_even\_series}}, \sphinxcode{\sphinxupquote{test\_odd\_series}} тестируют отдельно функциональность трех разных функций, поэтому это нормальные юнит\sphinxhyphen{}тесты. Мы можем написать генератор данных вместо использования фиксированных списков \sphinxcode{\sphinxupquote{{[}0, 1, 2, 3, 4{]}}} и таким образом увеличить покрытие тестами. Мы вернемся к этому чуть позже, сейчас посмотрим на другие тесты. Тест \sphinxcode{\sphinxupquote{test\_even\_series\_bad}} не является хорошим тестом, так как мы используем ту же логику, что и при реализации функции, и если этот код будет немного сложнее, чем генерация списка чисел, то мы можем унести ошибку в тест, и он будет пройден, хотя функция работает не так, как закладывалось. Например, если нужно было генерировать числа, начиная с нуля, а мы генерируем с 1 \sphinxcode{\sphinxupquote{range(n) \sphinxhyphen{}\textgreater{} range(1, n)}}. Тогда \sphinxcode{\sphinxupquote{test\_series\_should\_fail\_but\_passed()}} ниже не вызовет ошибок, так как мы просто скопировали код из функции. Тест \sphinxcode{\sphinxupquote{test\_series}} не пройдет, так как здесь данные сгенерированы независимо, и так мы поймем, что сделали ошибку:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}content of series.py in my\PYGZus{}math package}
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}                        \PYG{c+c1}{\PYGZsh{} we made mistake }

\PYG{c+c1}{\PYGZsh{}content of test\PYGZus{}series.py}
\PYG{k+kn}{import} \PYG{n+nn}{pytest}

\PYG{k+kn}{from} \PYG{n+nn}{my\PYGZus{}math}\PYG{n+nn}{.}\PYG{n+nn}{series} \PYG{k+kn}{import} \PYG{p}{(}\PYG{n}{get\PYGZus{}series}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{TestSeries}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}series}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}series\PYGZus{}should\PYGZus{}fail\PYGZus{}but\PYGZus{}passed}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} and propagate it here}
\end{sphinxVerbatim}

\sphinxAtStartPar
Посмотрим на тест \sphinxcode{\sphinxupquote{test\_series\_full}}. Он включает в себя вызов нескольких функций, это может быть хорошей идеей, так как мы проверяем полноту данных. Такой тест не должен подменять собой другие тесты, где мы тестируем отдельные функции, но может дополнять их. Тест не настолько объемный, чтобы считаться \sphinxstylestrong{интеграционным тестом}, хотя он и объединяет несколько отдельных участков кода и говорит, как они должны работать совместно.


\paragraph{Параметризация тестов}
\label{\detokenize{educational_materials/testing/content:id6}}
\sphinxAtStartPar
В тестах выше мы использовали заранее определенные списки, которые были захардкожены прямо в тесте. Мы можем расширить функциональность тестов, используя \sphinxhref{https://docs.pytest.org/en/7.1.x/example/parametrize.html}{параметризацию} тестов. Добавим в \sphinxcode{\sphinxupquote{test\_series.py}} тесты, которые принимают параметр:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pytest}

\PYG{k+kn}{from} \PYG{n+nn}{my\PYGZus{}math}\PYG{n+nn}{.}\PYG{n+nn}{series} \PYG{k+kn}{import} \PYG{p}{(}\PYG{n}{get\PYGZus{}series}\PYG{p}{,}
                            \PYG{n}{get\PYGZus{}even\PYGZus{}series}\PYG{p}{,}
                            \PYG{n}{get\PYGZus{}odd\PYGZus{}series}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{TestSeries}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}series\PYGZus{}parametrized}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{max\PYGZus{}number}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{series} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}number}\PYG{p}{:} 
            \PYG{n}{series}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
            \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{k}{assert} \PYG{n}{get\PYGZus{}series}\PYG{p}{(}\PYG{n}{max\PYGZus{}number}\PYG{p}{)} \PYG{o}{==} \PYG{n}{series}
\end{sphinxVerbatim}

\sphinxAtStartPar
И если мы попытаемся выполнить тесты, получим ошибку:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{      }def\PYG{+w}{ }test\PYGZus{}series\PYGZus{}parametrized\PYG{o}{(}self,\PYG{+w}{ }max\PYGZus{}number\PYG{o}{)}:
E\PYG{+w}{       }fixture\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}max\PYGZus{}number\PYGZsq{}}\PYG{+w}{ }not\PYG{+w}{ }found
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим новый термин \sphinxcode{\sphinxupquote{fixture}}. В самом деле, непонятно, откуда pytest должен узнать, что подставить вместо \sphinxcode{\sphinxupquote{max\_number}} при автоматическом тестировании. Если добавить max\_number значение по умолчанию, то ошибки не будет, но это не то, что мы хотим сделать. Значения \sphinxcode{\sphinxupquote{max\_number}} должны быть каким\sphinxhyphen{}то образом определены, и в pytest для этого используются \sphinxcode{\sphinxupquote{fixture}}, которые хранят данные, используемые в тестах. Мы определяем \sphinxcode{\sphinxupquote{fixture}} в файле \sphinxcode{\sphinxupquote{conftest.py}}, и они будут доступны всем тестами. Эти данные определяются в отдельном файле, так как вызов функции отличается от вызовов тестов, и определение входных данных для тестов можно отнести к конфигурированию тестов \sphinxcode{\sphinxupquote{conftest \sphinxhyphen{}\textgreater{} configure test}}. Добавим в \sphinxcode{\sphinxupquote{conftest}} следующие строки:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pytest} 

\PYG{n+nd}{@pytest}\PYG{o}{.}\PYG{n}{fixture}
\PYG{k}{def} \PYG{n+nf}{max\PYGZus{}number}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь проходят все тесты. Посмотрим, как можно сделать вызов теста с разными параметрами. Заменим с:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{pytest\PYGZus{}generate\PYGZus{}tests}\PYG{p}{(}\PYG{n}{metafunc}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}number}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{in} \PYG{n}{metafunc}\PYG{o}{.}\PYG{n}{fixturenames}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} end can be retrived from command line parameters}
        \PYG{n}{end} \PYG{o}{=} \PYG{l+m+mi}{10}    
        \PYG{n}{metafunc}\PYG{o}{.}\PYG{n}{parametrize}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{end}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Имя параметра, который мы хотим менять, — \sphinxcode{\sphinxupquote{max\_number}}, а \sphinxcode{\sphinxupquote{range(end)}} задает диапазон значений. Здесь на первый взгляд происходит небольшая магия, но это то, как работает pytest с параметризованными тестами, и такие конструкции мы просто берем из документации. Функция \sphinxcode{\sphinxupquote{pytest\_generate\_tests}} вызовется для каждого теста, далее мы посмотрим, что среди параметров\sphinxhyphen{}fixture есть тот, который нам нужен, и с помощью  \sphinxcode{\sphinxupquote{metafunc.parametrize()}} сделаем из одного теста несколько, подставляя вместо одного значения диапазон значений \sphinxcode{\sphinxupquote{range(end)}}. Значение \sphinxcode{\sphinxupquote{end}} на текущий момент задано жестко, но может управляться при \sphinxhref{https://docs.pytest.org/en/7.1.x/example/simple.html\#dynamically-adding-command-line-options}{запуске тестов}.

\sphinxAtStartPar
\sphinxstylestrong{Модульное тестирование позволяет понять, как части кода работают сами по себе}


\subsection{Интеграционное тестирование}
\label{\detokenize{educational_materials/testing/content:id7}}
\sphinxAtStartPar
Чтобы сделать интеграционное тестирование, нужно написать такие тесты, когда различные блоки, модули или компоненты программного приложения тестируются вместе. Интеграционное тестирование нужно для того, чтобы проверить ситуации, которые могут ускользнуть при юнит\sphinxhyphen{}тестировании. Основное отличие интеграционного теста от юнит\sphinxhyphen{}теста в том, что инициализируются все компоненты системы. Для юнит\sphinxhyphen{}теста мы можем определить тестовые данные непосредственно в тесте или через \sphinxcode{\sphinxupquote{fixture}}. Для интеграционного теста мы положим такие же данные в базу данных и затем возьмем оттуда. Для интеграционного тестирования могут применяться как те же инструменты, что и для модульного тестирования, например, pytest, так и специальные инструменты, которые протестируют приложение с внешней стороны. Например, подадут тестовый запрос так, как бы это делал пользователь, что можно сделать с помощью \sphinxhref{https://www.techtarget.com/searchsoftwarequality/tip/Cypress-vs-Selenium-Compare-test-automation-frameworks}{Selenium}. Подробнее про тестирование можно прочитать \sphinxhref{https://www.techtarget.com/searchsoftwarequality/definition/integration-testing}{здесь} или \sphinxhref{https://docs.pylonsproject.org/projects/pyramid/en/latest/narr/testing.html}{здесь}.

\sphinxAtStartPar
\sphinxstylestrong{Интеграционное тестирование позволяет понять, как части кода и целые модули работают в контексте всей системы}


\subsection{Больше тестов}
\label{\detokenize{educational_materials/testing/content:id8}}
\sphinxAtStartPar
Существует также системное тестирование, на этапе которого проверяется не только правильная функциональность частей системы, но и такие аспекты, как:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.guru99.com/load-testing-tutorial.html}{работа под нагрузкой}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.guru99.com/usability-testing-tutorial.html}{удобство использования}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.guru99.com/regression-testing.html}{обеспечение совместимости} с предыдущими версиями кода. Это не совсем то же самое, что прохождение юнит\sphinxhyphen{}тестов, здесь мы тестируем, что новая версия программы работает с данными так же, как старые. Даже с учетом того, что юнит\sphinxhyphen{}тесты не принято менять в процессе добавления новой функциональности.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.guru99.com/recovery-testing.html}{восстановление} работы системы при авариях.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.winwire.com/blog/data-migration-testing/}{миграционное} тестирование, при котором мы тестируем «переезд» на другие инструменты.

\end{itemize}

\sphinxAtStartPar
В этой главе мы не будем подробно останавливаться на этих тестах, так как это делается не только силами разработчиков, для целей данного курса мы подробно остановились на модульном тестировании.


\subsection{Разработка через тестирование}
\label{\detokenize{educational_materials/testing/content:id9}}
\sphinxAtStartPar
TDD — test\sphinxhyphen{}driven development, разработка через тестирование. Выше мы сначала писали функциональность и затем придумывали тесты. В подходе TDD мы сначала пишем тесты и затем делаем так, чтобы разработанная нами функциональность проходила все тесты. Для разработки через тестирование требуется создать автоматизированные модульные тесты, как мы делали выше с помощью \sphinxcode{\sphinxupquote{pytest}}, которые определяют требования к коду непосредственно перед написанием самого кода. Тест содержит проверки условий, которые могут либо выполняться, либо нет. Такие условия начинаются с ключевого слова \sphinxcode{\sphinxupquote{assert}} в примерах выше. Когда они выполняются, говорят, что тест пройден. Прохождение теста подтверждает поведение, которые программист предполагает правильным.

\sphinxAtStartPar
Цикл разработки через тестирование (на основе книги Кента Бека «Разработка через тестирование: на примере»):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Добавление теста}. Добавление каждой новой функциональности начинается с написания теста. Только что написанный тест не будет проходить проверку, потому что код, который он тестирует, еще не написан (да, именно так). Если этот тест прошел проверку до написания кода, то данная функциональность уже реализована, либо же тест работает неправильно. Для написания теста разработчик должен четко понимать требования к новой функциональности — это и отличает TDD\sphinxhyphen{}подход от остальных, разработчик фокусируется на требованиях до написания кода.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Запускаем все тесты, убеждаемся, что они не прошли}. На этом этапе мы проверяем сами тесты. Если написанный тест проходит всегда — значит, он бесполезен. Это увеличивает уверенность, хотя не гарантирует, что тест действительно тестирует то, что нам нужно.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Пишем код}. На этом этапе пишем код так, чтобы он проходил тесты. Этот код не обязан быть идеальным. Код может быть некрасивым, это мы поправим на следующих этапах.  Главное, чтобы код был предназначен для прохождения этого теста. Не следует добавлять лишнюю функциональность, для которой не написан тест.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Запускаем тесты, убеждаемся, что они проходят}. Если тесты прошли — программист может быть уверен, что код удовлетворяет всем требованиям, определенным на этапе добавления теста, но не более. Если нет — переписываем код и повторно прогоняем тесты до тех пор, пока тесты не будут выполнены.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Рефакторинг}. Теперь настало время привести код в порядок. Это процесс изменения внутренней структуры программы, не затрагивающий ее внешнее поведение и имеющий целью облегчить понимание ее работы, устранить дублирование кода, облегчить внесение изменений, в общем, улучшить поддерживаемость кода.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Повторить цикл}. Повторяем описанный цикл и реализуем все новую и новую функциональность. Если вы используете сторонние библиотеки, не следует делать небольшие изменения, которые тестируют только функциональность библиотеки, а не ваш код, который использует ее. Исключением может быть случай, когда у вас есть подозрения, что сторонняя библиотека содержит ошибки.

\end{itemize}

\sphinxAtStartPar
Разработка через тестирование позволяет сделать код чище и яснее, потому что мы пишем только те фрагменты, которые необходимы для прохождения тестирования. Также разработка тестов до написания программы позволяет писать код, который более пригоден для тестирования, что не скажешь о создании тестов после написания кода, когда бывает тяжело отделить одну функциональность от другой. TDD способствует тому, что тестами будет покрыта вся функциональность.


\subsubsection{Пример}
\label{\detokenize{educational_materials/testing/content:id10}}
\sphinxAtStartPar
Для демонстрации разработки тестирования мы будем писать класс «дробь» (\sphinxcode{\sphinxupquote{Fraction}}). Назовем наш пакет fraction. В каталоге \sphinxcode{\sphinxupquote{fraction}} создаем модуль \sphinxcode{\sphinxupquote{fraction.py}}. В этом файле мы будем реализовывать функциональность нашего класса. Далее в корневой директории проекта создаем каталог \sphinxcode{\sphinxupquote{tests}} и в нем файл \sphinxcode{\sphinxupquote{test\_fraction.py}}. Не забудьте добавить \sphinxcode{\sphinxupquote{\_\_init\_\_.py}} в каталоги \sphinxcode{\sphinxupquote{tests}} и \sphinxcode{\sphinxupquote{fraction}}, чтобы они воспринимались как пакеты.  Пропишем в начале файла \sphinxcode{\sphinxupquote{import pytest}}. Мы будем использовать библиотеку \sphinxcode{\sphinxupquote{pytest}} для написания и выполнения тестов. Если на вашем рабочем окружении не установлен \sphinxcode{\sphinxupquote{pytest}}, установите его:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }pytest.\PYG{+w}{ }
\end{sphinxVerbatim}

\sphinxAtStartPar
Структура файлов должна выглядеть так:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
my\PYGZus{}project
├── fraction
│   ├── \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
│   └── fraction.py
└── tests
    ├── \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
    └── test\PYGZus{}fraction.py
\end{sphinxVerbatim}

\sphinxAtStartPar
В файле \sphinxcode{\sphinxupquote{test\_fraction.py}} мы будем писать тесты. Создадим класс \sphinxcode{\sphinxupquote{TestFraction}}, в котором будем все писать. Для начала напишем код, который будет проверять корректность создания дроби. Для этого надо подумать, что наш класс будет принимать на вход. Пусть это будет числитель, \sphinxcode{\sphinxupquote{numerator}}, и знаменатель, \sphinxcode{\sphinxupquote{denominator}}. Все функции, которые что\sphinxhyphen{}либо тестируют в pytest, должны начинаться со слова \sphinxstyleemphasis{test}. Создадим функцию \sphinxcode{\sphinxupquote{test\_fraction\_creation()}}, которая будет тестировать создание экземпляров Fraction. Давайте возьмем такие пары числитель\sphinxhyphen{}знаменатель: (5, 2), (6, 8), (\sphinxhyphen{}5, 2), (2, \sphinxhyphen{}5), (0, 1), (1, 0), (1, 1). Во время подготовки данных помним про опасность дробей, которые в знаменателе содержат ноль. В результате у нас должен получиться такой код:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pytest}
\PYG{k+kn}{from} \PYG{n+nn}{fraction}\PYG{n+nn}{.}\PYG{n+nn}{fraction} \PYG{k+kn}{import} \PYG{n}{Fraction}

\PYG{k}{class} \PYG{n+nc}{TestFraction}\PYG{p}{:}
   \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}fraction\PYGZus{}creation}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
       \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь можем запустить тесты:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd}\PYG{+w}{ }my\PYGZus{}project
pytest
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы запустили тесты! В отчете нам пишут, что:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ImportError:\PYG{+w}{ }cannot\PYG{+w}{ }import\PYG{+w}{ }name\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Fraction\PYGZsq{}}\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}fraction\PYGZsq{}}.
\end{sphinxVerbatim}

\sphinxAtStartPar
Наша программа не может найти класс Fraction. Для этого в файле fraction/\sphinxstylestrong{init}.py пропишем следующее:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{.}\PYG{n+nn}{fraction} \PYG{k+kn}{import} \PYG{n}{Fraction}
\end{sphinxVerbatim}

\sphinxAtStartPar
А в fraction/fraction.py создадим заготовку кода:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Fraction}\PYG{p}{:}
   \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{)}\PYG{p}{:}
       \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{numerator} \PYG{o}{=} \PYG{n}{numerator}
       \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{denominator} \PYG{o}{=} \PYG{n}{denominator}

\end{sphinxVerbatim}

\sphinxAtStartPar
Запускаем тесты — теперь у нас все работает:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }session\PYG{+w}{ }\PYG{n+nv}{starts}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
platform\PYG{+w}{ }linux\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }Python\PYG{+w}{ }\PYG{l+m}{3}.7.4,\PYG{+w}{ }pytest\PYGZhy{}5.2.1,\PYG{+w}{ }py\PYGZhy{}1.8.0,\PYG{+w}{ }pluggy\PYGZhy{}0.13.0
rootdir:\PYG{+w}{ }/home/artem/swdev/gitrepo/edu/toolchain/23\PYGZus{}testing/code/fraction
plugins:\PYG{+w}{ }doctestplus\PYGZhy{}0.4.0,\PYG{+w}{ }arraydiff\PYGZhy{}0.3,\PYG{+w}{ }remotedata\PYGZhy{}0.3.2,\PYG{+w}{ }openfiles\PYGZhy{}0.4.0
collected\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }item\PYG{+w}{                                                                 }

tests/test\PYGZus{}fraction.py\PYG{+w}{ }.\PYG{+w}{                                                   }\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]}

\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }passed\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{0}.02s\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Задачи:}
\label{\detokenize{educational_materials/testing/exercises:id1}}\label{\detokenize{educational_materials/testing/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/testing/exercises:id2}}
\sphinxAtStartPar
Напишите класс \sphinxcode{\sphinxupquote{Fraction}}, который будет принимать числитель и знаменатель для создания экземпляра класса. Класс должен иметь методы для приведения дроби к простому виду \sphinxcode{\sphinxupquote{4/6 \sphinxhyphen{}\textgreater{} 2/3}}, а также метод для определения дроби, наиболее близкой к иррационального числу (напомним, что иррациональное число нельзя представить в виде дроби). При поиске ближайшей к иррациональном числу дроби ограничьте знаменатель, чтобы он не превышал 100. Напишите тесты к этим функциям.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Fraction}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{numerator} \PYG{o}{=} \PYG{n}{numerator}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{denominator} \PYG{o}{=} \PYG{n}{denominator}

    \PYG{k}{def} \PYG{n+nf}{simplify}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{gcd} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}compute\PYGZus{}gcd}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{numerator}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{denominator}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{numerator} \PYG{o}{/}\PYG{o}{/}\PYG{o}{=} \PYG{n}{gcd}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{denominator} \PYG{o}{/}\PYG{o}{/}\PYG{o}{=} \PYG{n}{gcd}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}compute\PYGZus{}gcd}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{n}{b}\PYG{p}{:}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b}
        \PYG{k}{return} \PYG{n}{a}

    \PYG{k}{def} \PYG{n+nf}{closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{irrational}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{closest\PYGZus{}difference} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{inf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{closest\PYGZus{}numerator} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{l+m+mi}{0}

        \PYG{k}{for} \PYG{n}{denominator} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{101}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{numerator} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{denominator} \PYG{o}{*} \PYG{n}{irrational}\PYG{p}{)}
            \PYG{n}{difference} \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{irrational} \PYG{o}{\PYGZhy{}} \PYG{n}{numerator} \PYG{o}{/} \PYG{n}{denominator}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{difference} \PYG{o}{\PYGZlt{}} \PYG{n}{closest\PYGZus{}difference}\PYG{p}{:}
                \PYG{n}{closest\PYGZus{}difference} \PYG{o}{=} \PYG{n}{difference}
                \PYG{n}{closest\PYGZus{}numerator} \PYG{o}{=} \PYG{n}{numerator}
                \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{n}{denominator}

        \PYG{k}{return} \PYG{n}{closest\PYGZus{}numerator}\PYG{p}{,} \PYG{n}{closest\PYGZus{}denominator}
\end{sphinxVerbatim}

\sphinxAtStartPar
Тесты

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} test\PYGZus{}fraction.py}

\PYG{k+kn}{from} \PYG{n+nn}{fraction} \PYG{k+kn}{import} \PYG{n}{Fraction}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}simplify}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fraction} \PYG{o}{=} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
    \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{numerator} \PYG{o}{==} \PYG{l+m+mi}{2}
    \PYG{k}{assert} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{denominator} \PYG{o}{==} \PYG{l+m+mi}{3}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}compute\PYGZus{}gcd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fraction} \PYG{o}{=} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}
    \PYG{n}{gcd} \PYG{o}{=} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{\PYGZus{}compute\PYGZus{}gcd}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{gcd} \PYG{o}{==} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fraction} \PYG{o}{=} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Test with an irrational number of 0.3}
    \PYG{n}{irrational\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mf}{0.3}
    \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{n}{irrational\PYGZus{}number}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{numerator} \PYG{o}{==} \PYG{l+m+mi}{3}
    \PYG{k}{assert} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{==} \PYG{l+m+mi}{10}

    \PYG{c+c1}{\PYGZsh{} Test with an irrational number of 0.8}
    \PYG{n}{irrational\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mf}{0.8}
    \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{n}{irrational\PYGZus{}number}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{numerator} \PYG{o}{==} \PYG{l+m+mi}{4}
    \PYG{k}{assert} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{==} \PYG{l+m+mi}{5}

    \PYG{c+c1}{\PYGZsh{} Test with an irrational number of 0.5}
    \PYG{n}{irrational\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mf}{0.5}
    \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{n}{irrational\PYGZus{}number}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{numerator} \PYG{o}{==} \PYG{l+m+mi}{1}
    \PYG{k}{assert} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{==} \PYG{l+m+mi}{2}

    \PYG{c+c1}{\PYGZsh{} Test with an irrational number of 0.123456789}
    \PYG{n}{irrational\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mf}{0.123456789}
    \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{=} \PYG{n}{fraction}\PYG{o}{.}\PYG{n}{closest\PYGZus{}ratio\PYGZus{}to\PYGZus{}irrational}\PYG{p}{(}\PYG{n}{irrational\PYGZus{}number}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{numerator} \PYG{o}{==} \PYG{l+m+mi}{10}
    \PYG{k}{assert} \PYG{n}{closest\PYGZus{}denominator} \PYG{o}{==} \PYG{l+m+mi}{81}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/testing/exercises:id3}}
\sphinxAtStartPar
Напишите тесты для функций из модуля \sphinxcode{\sphinxupquote{string\_functions.py}}, которые проводят операции со строками.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse\PYGZus{}string}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{text}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}palindrome}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{text} \PYG{o}{==} \PYG{n}{text}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{count\PYGZus{}vowels}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{vowels} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aeiouAEIOU}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{text} \PYG{k}{if} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{vowels}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{remove\PYGZus{}whitespace}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{text}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{remove\PYGZus{}extra\PYGZus{}spaces}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words} \PYG{o}{=} \PYG{n}{text}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words} \PYG{o}{=} \PYG{n}{text}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{lines} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{current\PYGZus{}words} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{current\PYGZus{}line}\PYG{p}{:}
            \PYG{n}{current\PYGZus{}words}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{current\PYGZus{}words}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{line\PYGZus{}width}\PYG{p}{:}
            \PYG{n}{current\PYGZus{}words}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{current\PYGZus{}words}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{current\PYGZus{}words} \PYG{o}{=} \PYG{p}{[}\PYG{n}{word}\PYG{p}{]}

    \PYG{k}{if} \PYG{n}{current\PYGZus{}words}\PYG{p}{:}
        \PYG{n}{lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{current\PYGZus{}words}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{lines}

\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{string\PYGZus{}functions} \PYG{k+kn}{import} \PYG{p}{(}
    \PYG{n}{reverse\PYGZus{}string}\PYG{p}{,}
    \PYG{n}{is\PYGZus{}palindrome}\PYG{p}{,}
    \PYG{n}{count\PYGZus{}vowels}\PYG{p}{,}
    \PYG{n}{remove\PYGZus{}whitespace}\PYG{p}{,}
    \PYG{n}{remove\PYGZus{}extra\PYGZus{}spaces}
\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}capitalize\PYGZus{}string}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{capitalize\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello world}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}reverse\PYGZus{}string}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{reverse\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{olleh}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}is\PYGZus{}palindrome}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{is\PYGZus{}palindrome}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{radar}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{o+ow}{not} \PYG{n}{is\PYGZus{}palindrome}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}count\PYGZus{}vowels}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{count\PYGZus{}vowels}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}
    \PYG{k}{assert} \PYG{n}{count\PYGZus{}vowels}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Python is awesome}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{6}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}remove\PYGZus{}whitespace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{remove\PYGZus{}whitespace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  remove  whitespace  }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{removewhitespace}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}swap\PYGZus{}case}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{swap\PYGZus{}case}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, World!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hELLO, wORLD!}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}remove\PYGZus{}extra\PYGZus{}spaces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{remove\PYGZus{}extra\PYGZus{}spaces}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   This    is   a   test  sentence.  }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is a test sentence.}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Test with a short input text and line width}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World!}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{line\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{8}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{World!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Test with a long input text and line width}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nonummy.}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{line\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{20}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lorem ipsum dolor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sit amet,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{consectetur}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adipiscing elit. Sed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nonummy.}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} Test with a word exceeding the line width}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Supercalifragilisticexpialidocious}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{line\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Supercalifragilisticexpialidocious}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Test with an empty input text}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{line\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{15}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Test with a very small line width}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is a test}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{line\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{text\PYGZus{}to\PYGZus{}lines}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/testing/exercises:id4}}
\sphinxAtStartPar
Реализуйте функцию \sphinxcode{\sphinxupquote{parse\_csv}} (парсер данных в формате csv). csv (comma\sphinxhyphen{}separated\sphinxhyphen{}value) — табличный формат, когда значения каждой колонки разделяются запятой. Для реализации можно пользоваться библиотекой \sphinxcode{\sphinxupquote{csv}} или написать все вручную. Основная цель этого задания — реализовать все случаи, которые покрыты тестами.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}empty\PYGZus{}string}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}single\PYGZus{}row}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{John,30,New York}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}multiple\PYGZus{}rows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{John,30,New York}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Alice,25,Chicago}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{25}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chicago}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}missing\PYGZus{}columns}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{John,30}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}trailing\PYGZus{}comma}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{John,30,New York,}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}extra\PYGZus{}whitespace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  Name  , Age , City  }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{   John,  30  ,  New York}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}empty\PYGZus{}fields}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{John,,New York}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{,25,}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Alice,30,}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{25}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}parse\PYGZus{}csv\PYGZus{}with\PYGZus{}quotes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Name,Age,City}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,30,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{New York}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Alice}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,25,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Chicago}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}
    \PYG{n}{expected} \PYG{o}{=} \PYG{p}{[}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{30}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New York}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alice}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Age}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{25}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{City}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chicago}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{expected}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{csv}

\PYG{k}{def} \PYG{n+nf}{parse\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}string}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{lines} \PYG{o}{=} \PYG{n}{csv\PYGZus{}string}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{lines}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{data}

    \PYG{n}{reader} \PYG{o}{=} \PYG{n}{csv}\PYG{o}{.}\PYG{n}{reader}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}
    \PYG{n}{header} \PYG{o}{=} \PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{reader}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{reader}\PYG{p}{:}
        \PYG{n}{row\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{k}{for} \PYG{n}{col\PYGZus{}name}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{header}\PYG{p}{,} \PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{row\PYGZus{}dict}\PYG{p}{[}\PYG{n}{col\PYGZus{}name}\PYG{p}{]} \PYG{o}{=} \PYG{n}{value}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{row\PYGZus{}dict}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{data}
\end{sphinxVerbatim}


\subsection{Задача 4}
\label{\detokenize{educational_materials/testing/exercises:id5}}
\sphinxAtStartPar
Используйте класс калькулятор.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\sphinxAtStartPar
/home/artem/swdev/gitrepo/edu/toolchain

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Calculator}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

    \PYG{k}{def} \PYG{n+nf}{subtract}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}

    \PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}

    \PYG{k}{def} \PYG{n+nf}{divide}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cannot divide by zero.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}
\end{sphinxVerbatim}

\sphinxAtStartPar
Напишите тесты, которые используют \sphinxcode{\sphinxupquote{@pytest.fixture}} вместо того, чтобы создавать экземпляр класса внутри каждого теста.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} test\PYGZus{}calculator.py}

\PYG{k+kn}{import} \PYG{n+nn}{pytest}
\PYG{k+kn}{from} \PYG{n+nn}{calculator} \PYG{k+kn}{import} \PYG{n}{Calculator}

\PYG{c+c1}{\PYGZsh{} Define the fixture to set up an instance of the Calculator class for testing}
\PYG{n+nd}{@pytest}\PYG{o}{.}\PYG{n}{fixture}
\PYG{k}{def} \PYG{n+nf}{calculator\PYGZus{}instance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{Calculator}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}add}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{7}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}subtract}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{6}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}divide}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}divide\PYGZus{}by\PYGZus{}zero}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{with} \PYG{n}{pytest}\PYG{o}{.}\PYG{n}{raises}\PYG{p}{(}\PYG{n+ne}{ValueError}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}divide\PYGZus{}float}\PYG{p}{(}\PYG{n}{calculator\PYGZus{}instance}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculator\PYGZus{}instance}\PYG{o}{.}\PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)}
    \PYG{k}{assert} \PYG{n}{result} \PYG{o}{==} \PYG{n}{pytest}\PYG{o}{.}\PYG{n}{approx}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{pytest}\PYG{o}{.}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/testing/quiz:id1}}\label{\detokenize{educational_materials/testing/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какой тип тестирования направлен на проверку правильности отдельных функций или методов?
а) Модульное тестирование
б) Интеграционное тестирование
в) Системное тестирование
г) Регрессионное тестирование

\item {} 
\sphinxAtStartPar
Какая библиотека тестирования Python предоставляет удобный способ для написания тестовых случаев, fixture и других необходимых для тестирования вещей?
а) unittest
б) pytest
в) nose2
г) doctest

\item {} 
\sphinxAtStartPar
Какова цель контрольного примера (теста) в тестировании программного обеспечения?
а) Выявить и исправить синтаксические ошибки в коде
б) Проверить функциональность всего приложения
в) Задокументировать требования к программному обеспечению
г) Определить конкретные входные данные, действия и ожидаемые результаты для тестирования конкретной случая или функции

\item {} 
\sphinxAtStartPar
Какова роль \sphinxcode{\sphinxupquote{assertion}} в тестировании кода (python)?
а) Для обработки исключений и ошибок в коде
б) Для генерации случайных тестовых данных
в) Чтобы проверить, соответствует ли фактический результат ожидаемому результату
г) Чтобы измерить покрытие кода

\item {} 
\sphinxAtStartPar
Что измеряет покрытие кода при тестировании программного обеспечения?
а) Время, необходимое для выполнения тестового примера
б) Процент кода, проверенного коллегами
в) Количество выполненных тестовых случаев
г) Процент кода, который был протестирован тестовыми примерами

\item {} 
\sphinxAtStartPar
Каков основной принцип разработки через тестирование (TDD)?
а) Написание тестов после написания кода, чтобы проверить его правильность
б) Написание тестов перед написанием кода, чтобы определить желаемое поведение
в) Написание тестов только для критических частей кода
г) Написание тестов в конце цикла разработки (после реализации всех модулей)

\item {} 
\sphinxAtStartPar
Каковы преимущества автоматизации тестирования в тестировании программного обеспечения?
а) Сокращение количества тестовых случаев, необходимых для полного покрытия кода
б) Полное устранение необходимости в ручном тестировании
в) Обеспечение того, чтобы все дефекты были идентифицированы и исправлены
г) Повышение скорости и эффективности процессов тестирования

\item {} 
\sphinxAtStartPar
В чем заключается тестировании методом черного ящика для разработки тестов?
а) Тестовые случаи выводятся из внутренней структуры кода
б) Тестовые случаи основаны на знании реализации кода
в) Тестовые примеры получены из спецификаций и требований к продукту без знания реализации кода
г) Тестовые случаи предназначены для проверки производительности и масштабируемости приложения

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
в)

\end{enumerate}


\chapter{Логгирование работы приложения}
\label{\detokenize{index:id15}}
\sphinxstepscope


\section{Логирование. Что это и в чем его польза?}
\label{\detokenize{educational_materials/logging/content:id1}}\label{\detokenize{educational_materials/logging/content::doc}}
\sphinxAtStartPar
Что значит логирование? Логирование (или журнал событий) является важным инструментом при разработке программного обеспечения. Логирование нужно нам для того, чтобы записать шаги и результат выполнения различных участков приложения для дальнейшего использования с целью анализа или поиска ошибок.


\subsection{Мотивация}
\label{\detokenize{educational_materials/logging/content:id2}}
\sphinxAtStartPar
При использовании логирования мы можем не гадать, что именно произошло в нашем приложении, а опереться на конкретную информацию. При этом нужно помнить, что переизбыток информации так же вреден, как и ее недостаток: в куче разнородных сообщений, часть из которых являются бесполезными, а часть избыточными, ошибку найти еще можно, а вот причины, которые к ней привели, уже гораздо сложнее. Речь идет о записи специального текстового файла (лога) с особым образом структурированной информацией о работе программы. Каждое сообщение может сопровождаться метками, самая простая из которых — метка времени, для удобного поиска и группировки.


\subsection{Зачем нужно логирование?}
\label{\detokenize{educational_materials/logging/content:id3}}
\sphinxAtStartPar
Инструменты для логирования можно рассматривать как отдельную систему при разработке ПО, при этом она не менее важна, чем, например, система контроля версий. При этом системами контроля версий принято пользоваться почти всегда, а системе логирования не уделяется достаточного внимания, так как ее поддержка в коде приложения (все это дополнительные строчки кода) не несет дополнительного функционала, если все идет по плану. Однако логи очень полезны. Если все пошло не так, как должно, и если их нет, единственный способ найти ошибку — работать с пользователем и воспроизводить проблему.

\sphinxAtStartPar
Существует несколько сценариев, в которых ведение логов необходимо:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Отладка}
Логи помогают разработчикам понимать и диагностировать проблемы в их ПО, предоставляя подробную информацию о том, что происходит внутри приложения. Особенно это полезно, когда приложение работает с данными от пользователей, когда невозможно предусмотреть все возможные ситуации заранее. Эта информация может быть использована для выявления и исправления ошибок. Всем знакомо подобное окно, когда происходит ошибка, которую не предусмотрел разработчик. В таком окне обычно есть кнопка «Сообщить о проблеме», если ее нажать, разработчику уйдет сообщение об ошибке и часть логов.

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{error_report}.png}

\sphinxAtStartPar
\sphinxstyleemphasis{Примечание об ошибках, появление которых предусмотрено, можно сообщить текстом и предложить варианты исправления. Это можно тоже отправить в логи}

\sphinxAtStartPar
Посмотреть когда\sphinxhyphen{}либо отправленные системой сообщения об ошибках на Ubuntu можно, выполнив команду в терминале:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
xdg\PYGZhy{}open\PYG{+w}{ }https://errors.ubuntu.com/user/\PYG{l+s+sb}{`}sudo\PYG{+w}{ }cat\PYG{+w}{ }/var/lib/whoopsie/whoopsie\PYGZhy{}id\PYG{l+s+sb}{`}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Мониторинг}
Этот сценарий предполагает использование логов для выявления процессов, которые не связаны с ошибками, но могут означать другую проблему. Например, если нагрузка на сервер (число одновременных подключений) выросла в 10 раз за короткий промежуток времени. Возможно, происходит какая\sphinxhyphen{}то атака. Так логи могут использоваться для мониторинга работоспособности, а также для выявления потенциальных проблем. Логи также можно использовать для отслеживания состояния важных процессов, например, миграции базы данных или обновления системы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Proof of operation}
В некоторых случаях ведение журнала логов просто необходимо для демонстрации работоспособности приложения и требуется в соответствии с нормативными актами или отраслевыми стандартами. Логи могут служить доказательством соответствия требованиям и использоваться для демонстрации того, что ПО работает согласно установленным политикам и процедурам.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Аудит}
Логи могут использоваться в целях аудита, чтобы помочь убедиться, что система используется правильно, а также для обнаружения и предотвращения несанкционированного доступа или неправильного использования. В данном случае мы можем хранить время входа в систему, локацию, откуда произведен вход, и, например, выяснить, не пользуется ли часть сотрудников ключами других.

\end{enumerate}


\subsection{Уровни логирования}
\label{\detokenize{educational_materials/logging/content:id4}}
\sphinxAtStartPar
Заниматься логированием необходимо с самого начала разработки, чтобы во время последующей эксплуатации мы могли собирать наиболее полную информацию о работе ПО. Даже при хорошо продуманном логировании в файлах\sphinxhyphen{}логах копится очень много информации. Чтобы систематизировать важную информацию и упростить ее последующее использование, существуют уровни логирования. Уровни логирования предусмотрены не только в качестве меток для поиска и выборки событий, но и используются самой библиотекой логирования для того, чтобы можно было оставить вывод только логов определенного уровня. Всего выделяют 5 основных:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Trace}
Уровень \sphinxstyleemphasis{Trace} используется для регистрации самых мелких событий, которые позволят отследить каждый шаг алгоритма или другую подобную информацию. Как правило, это не требуется, поскольку алгоритмы обычно хорошо известны и покрываются тестами. Но если вам нужен очень подробный отчет по каждой строке кода, то вам сюда. Не забудьте запастись достаточным дисковым пространством для файлов\sphinxhyphen{}логов.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Debug}
Уровень \sphinxstyleemphasis{Debug} используется для регистрации подробной информации, которая в основном предназначена для разработчиков. Сообщения на этом уровне менее подробны, чем на \sphinxstyleemphasis{Trace}, но не настолько, чтобы быть полезны кому\sphinxhyphen{}то кроме разработчиков. Отладочные сообщения обычно используются на этапе разработки и тестирования, чтобы помочь понять, что происходит внутри системы. При сборке проекта для пользователей этот уровень отключают, и события уровня \sphinxstyleemphasis{Debug} не собираются на машинах пользователей.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Info}
Уровень \sphinxstyleemphasis{Info} используется для регистрации информации о нормальных, ожидаемых событиях. Информационные сообщения могут дать представление о поведении системы и использоваться в целях мониторинга. Например, так можно собирать количество подключений от пользователя за определенный промежуток времени, например, 1 час.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Warning}
Уровень \sphinxstyleemphasis{Warning} используется для регистрации необычных или неожиданных событий, но необязательно ошибок. Предупреждения могут указывать на потенциальные проблемы, которые необходимо устранить и которые уже могут привести к более серьезным последствиям. Например, падение скорости передачи данных ниже уровня, когда это начинает влиять на работу приложения.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Error}
Уровень \sphinxstyleemphasis{Error} используется для регистрации событий, которые представляют собой сбой или непредвиденную ситуацию. Сообщения об ошибках могут указывать на проблему, которую необходимо устранить, например, падение канала связи так, что данные пользователя вообще не будут передаваться.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Fatal}
Уровень \sphinxstyleemphasis{Fatal} используется для регистрации наиболее серьезных событий, таких как полный сбой системы или критическая проблема безопасности. Критические сообщения указывают на то, что требуется немедленное внимание для предотвращения или устранения серьезной проблемы. К таким событиям можно отнести получение файла с данными, у которого не сходится контрольная сумма, это может привести не только к неудобству пользователей, но и к потерям со стороны компании\sphinxhyphen{}разработчика.

\end{itemize}

\sphinxAtStartPar
Благодаря разным уровням ведения журнала программное обеспечение для ведения журнала предоставляет способ фильтровать регистрируемые события, что облегчает фокусировку на наиболее важных событиях.


\subsection{Основы грамотного логирования}
\label{\detokenize{educational_materials/logging/content:id5}}
\sphinxAtStartPar
Чтобы получить файлы логирования, которые будут удобными в последующей работе, следует грамотно подойти к процессу их создания:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Логировать все важные события, будь то запуск приложения, остановка или возобновление транзакций, успешная регистрация, открытие на чтение файла, ошибки.

\item {} 
\sphinxAtStartPar
Исключить из описания события часто повторяющиеся слова, что существенно упростит поиск нужной информации в будущем.

\item {} 
\sphinxAtStartPar
Добавлять к логам теги: переходя по ним, вы сможете находить данные, даже если они находятся в разных категориях. Теги могут относиться как бизнес\sphinxhyphen{}логике (ПРОДАЖА, РЕГИСТРАЦИЯ), так и внутренним процессам в коде (ПОДКЛЮЧЕНИЕ\_К\_БД, ЧТЕНИЕ\_ФАЙЛА), и любые другие осмысленные варианты.

\item {} 
\sphinxAtStartPar
Использовать только нужную информацию: лишние сведения будут только засорять логи и делать работу с ними медленнее даже при автоматической обработке событий.

\item {} 
\sphinxAtStartPar
Использовать типы и уровни логирования осознанно. Это упрощает использование журнала логов для последующей аналитики и визуализации.

\end{itemize}

\sphinxAtStartPar
Следуя этим основам грамотного ведения журнала программного обеспечения, можно гарантировать, что данные журнала собираются так, чтобы облегчать отладку и мониторинг вашего ПО.


\subsection{Библиотеки логирования для языка программирования Python}
\label{\detokenize{educational_materials/logging/content:python}}
\sphinxAtStartPar
Существует несколько популярных библиотек ведения журнала для Python:


\subsubsection{\sphinxstylestrong{logging}}
\label{\detokenize{educational_materials/logging/content:logging}}
\sphinxAtStartPar
Встроенный модуль ведения журнала в стандартной библиотеке Python — это гибкая и мощная библиотека ведения логов, которая предоставляет множество функциональных возможностей «из коробки».

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{from} \PYG{n+nn}{logging}\PYG{n+nn}{.}\PYG{n+nn}{handlers} \PYG{k+kn}{import} \PYG{n}{TimedRotatingFileHandler}

\PYG{n}{FORMATTER\PYGZus{}STRING} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}(asctime)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(name)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(levelname)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{FORMATTER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{Formatter}\PYG{p}{(}\PYG{n}{FORMATTER\PYGZus{}STRING}\PYG{p}{)}
\PYG{n}{LOG\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/tmp/my\PYGZus{}app.log}\PYG{l+s+s2}{\PYGZdq{}} \PYG{c+c1}{\PYGZsh{} use fancy libs to make proper temp file}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}logger}\PYG{p}{(}\PYG{n}{logger\PYGZus{}name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{logger} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n}{logger\PYGZus{}name}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{setLevel}\PYG{p}{(}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{)}
    
    \PYG{n}{console\PYGZus{}handler} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{StreamHandler}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{)}
    \PYG{n}{console\PYGZus{}handler}\PYG{o}{.}\PYG{n}{setFormatter}\PYG{p}{(}\PYG{n}{FORMATTER}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{addHandler}\PYG{p}{(}\PYG{n}{console\PYGZus{}handler}\PYG{p}{)}

    \PYG{n}{file\PYGZus{}handler} \PYG{o}{=} \PYG{n}{TimedRotatingFileHandler}\PYG{p}{(}\PYG{n}{LOG\PYGZus{}FILE}\PYG{p}{,} \PYG{n}{when}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{midnight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}file\PYGZus{}handler.setFormatter(FORMATTER)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{addHandler}\PYG{p}{(}\PYG{n}{file\PYGZus{}handler}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{logger}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{logger} \PYG{o}{=} \PYG{n}{get\PYGZus{}logger}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}app\PYGZus{}logger}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Start logging}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some debug message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{k}{try}\PYG{p}{:} 
            \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Keep logging}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{KeyboardInterrupt}\PYG{p}{:}
            \PYG{n}{logger}\PYG{o}{.}\PYG{n}{fatal}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User get bored}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{break}
\end{sphinxVerbatim}

\sphinxAtStartPar
Давайте поймем, что здесь происходит. Мы создаем логгер и выводим логи на уровне INFO в файл и в терминал. В файле логи записываются без форматирования. Выводим сообщение о критической ошибке, когда пользователь нажмет Ctrl\sphinxhyphen{}C и прервет выполнение программы. Обратите внимание, что сообщения уровня DEBUG не выводятся, так как мы установили уровень для вывода не ниже INFO \sphinxcode{\sphinxupquote{logger.setLevel(logging.INFO)}}. Ниже описаны объекты, которые мы используем в коде:
\begin{itemize}
\item {} 
\sphinxAtStartPar
FORMATTER — определяет, как будет выглядеть строка события в логах. В него мы передаем шаблон, который хотим реализовать.

\item {} 
\sphinxAtStartPar
LOG\_FILE — определяет, в какой файл мы будем писать логи. По умолчанию мы выводим в стандартный вывод stderr, и если хотим видеть логи на экране и сохранять в файл, должны явно это указать.

\item {} 
\sphinxAtStartPar
get\_logger() — создает объект класса Logger, который мы будем использовать для логирования.

\item {} 
\sphinxAtStartPar
console\_handler — обработчик вывода в терминал, по умолчанию используется stderr, поэтому явно говорим, что хотим видеть сообщения в stdout.

\item {} 
\sphinxAtStartPar
file\_handler — обработчик вывода логов в файл, обратите внимания, что мы закомментировали форматирование, поэтому сообщения будут записаны в стандартной форме.

\item {} 
\sphinxAtStartPar
logger.info() — используем для вывода логов на уровне INFO. Другие уровни имеют соответствующие функции для вывода.

\end{itemize}

\sphinxAtStartPar
Запустим приложение и увидим вывод:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }python\PYG{+w}{ }./logging\PYGZus{}sample.py
\PYG{+w}{    }\PYG{l+m}{2023}\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:05:40,074\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }INFO\PYG{+w}{ }—\PYG{+w}{ }Start\PYG{+w}{ }logging
\PYG{+w}{    }\PYG{l+m}{2023}\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:05:41,075\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }INFO\PYG{+w}{ }—\PYG{+w}{ }Keep\PYG{+w}{ }logging
\PYG{+w}{    }\PYG{l+m}{2023}\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:05:42,076\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }INFO\PYG{+w}{ }—\PYG{+w}{ }Keep\PYG{+w}{ }logging
\PYG{+w}{    }\PYGZca{}C2023\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:05:42,392\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }CRITICAL\PYG{+w}{ }—\PYG{+w}{ }User\PYG{+w}{ }get\PYG{+w}{ }bored
\end{sphinxVerbatim}

\sphinxAtStartPar
В файле мы видим те же самые сообщения, но не снабженные никакой дополнительной информацией:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }/tmp/my\PYGZus{}app.log
\PYG{+w}{    }Start\PYG{+w}{ }logging
\PYG{+w}{    }Keep\PYG{+w}{ }logging
\PYG{+w}{    }Keep\PYG{+w}{ }logging
\PYG{+w}{    }User\PYG{+w}{ }get\PYG{+w}{ }bored
\end{sphinxVerbatim}


\subsubsection{\sphinxstylestrong{structlog}}
\label{\detokenize{educational_materials/logging/content:structlog}}
\sphinxAtStartPar
Это библиотека расширяет встроенный модуль Python для ведения логов с дополнительными функциями, такими как возможность прикреплять дополнительные данные к сообщениям или манипулировать сообщениями до их отправки.

\sphinxAtStartPar
Рассмотрим слегка модифицированный пример с сайта \sphinxcode{\sphinxupquote{structlog}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{structlog}

\PYG{n}{FORMATTER\PYGZus{}STRING} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}(asctime)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(name)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(levelname)s}\PYG{l+s+s2}{ — }\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{FORMATTER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{Formatter}\PYG{p}{(}\PYG{n}{FORMATTER\PYGZus{}STRING}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}logger}\PYG{p}{(}\PYG{n}{logger\PYGZus{}name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{logger} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n}{logger\PYGZus{}name}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{setLevel}\PYG{p}{(}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{)}    
    \PYG{n}{console\PYGZus{}handler} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{StreamHandler}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{)}
    \PYG{n}{console\PYGZus{}handler}\PYG{o}{.}\PYG{n}{setFormatter}\PYG{p}{(}\PYG{n}{FORMATTER}\PYG{p}{)}
    \PYG{n}{logger}\PYG{o}{.}\PYG{n}{addHandler}\PYG{p}{(}\PYG{n}{console\PYGZus{}handler}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{logger}

\PYG{k}{def} \PYG{n+nf}{replace\PYGZus{}user}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{event\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{user} \PYG{o}{=} \PYG{n}{event\PYGZus{}dict}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{user}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{user}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} we can access data base here for user\PYGZus{}token}
        \PYG{c+c1}{\PYGZsh{} for now keep it fake}
        \PYG{n}{user\PYGZus{}token} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{some\PYGZus{}string\PYGZus{}that\PYGZus{}we\PYGZus{}can\PYGZus{}learn\PYGZus{}username\PYGZus{}from}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{event\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{user}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{user\PYGZus{}token}
    \PYG{k}{return} \PYG{n}{event\PYGZus{}dict}

\PYG{k}{def} \PYG{n+nf}{censor\PYGZus{}password}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{event\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pw} \PYG{o}{=} \PYG{n}{event\PYGZus{}dict}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{password}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{pw}\PYG{p}{:}
        \PYG{n}{event\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{password}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*CENSORED*}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{event\PYGZus{}dict}

\PYG{n}{log} \PYG{o}{=} \PYG{n}{structlog}\PYG{o}{.}\PYG{n}{wrap\PYGZus{}logger}\PYG{p}{(}
    \PYG{n}{get\PYGZus{}logger}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my\PYGZus{}app\PYGZus{}logger}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{processors}\PYG{o}{=}\PYG{p}{[}
        \PYG{n}{censor\PYGZus{}password}\PYG{p}{,}
        \PYG{n}{replace\PYGZus{}user}\PYG{p}{,}
        \PYG{n}{structlog}\PYG{o}{.}\PYG{n}{processors}\PYG{o}{.}\PYG{n}{JSONRenderer}\PYG{p}{(}\PYG{n}{indent}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{sort\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{]}\PYG{p}{,}
\PYG{p}{)}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{something}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{secret}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{something}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ivan}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Здесь мы используем \sphinxcode{\sphinxupquote{get\_logger()}} как раньше. Убрали вывод в файл, так как он не важен для демонстрации. Сделали обертку для логгера и определили, что должно происходить с данными, если они передаются для логирования. Мы видим, что здесь нам необязательно определять строку форматирования для всех данных, данные передаются по ключам, и это дает нам возможность получить читаемый вывод и сделать что\sphinxhyphen{}нибудь со значениями до вывода. В примере ниже мы хотим заменить имена на что\sphinxhyphen{}то, что позволит нам восстановить эти имена, например, если мы держим соответствие имен и некоторых токенов (если требования к личным данным не позволяют нам публиковать имена людей). Пароли мы хотим скрыть полностью. Для манипуляции с данными в логгер от \sphinxcode{\sphinxupquote{structlog}} мы можем определить несколько \sphinxstyleemphasis{обработчиков (processors)}, в которых описано то, что мы хотим сделать.
\begin{itemize}
\item {} 
\sphinxAtStartPar
censor\_password — функция\sphinxhyphen{}обработчик, которая скроет пароль, если он присутствует в данных, заменив на \sphinxcode{\sphinxupquote{*CENSORED*}}.

\item {} 
\sphinxAtStartPar
replace\_user — функция\sphinxhyphen{}обработчик, которая заменит имя пользователя.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{2023}\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:53:42,214\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }WARNING\PYG{+w}{ }—\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}event\PYGZdq{}}:\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}something\PYGZdq{}},
\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}password\PYGZdq{}}:\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}*CENSORED*\PYGZdq{}}
\PYG{o}{\PYGZcb{}}
\PYG{l+m}{2023}\PYGZhy{}02\PYGZhy{}14\PYG{+w}{ }\PYG{l+m}{10}:53:42,214\PYG{+w}{ }—\PYG{+w}{ }my\PYGZus{}app\PYGZus{}logger\PYG{+w}{ }—\PYG{+w}{ }WARNING\PYG{+w}{ }—\PYG{+w}{ }\PYG{o}{\PYGZob{}}
\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}event\PYGZdq{}}:\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}something\PYGZdq{}},
\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}user\PYGZdq{}}:\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}some\PYGZus{}string\PYGZus{}that\PYGZus{}we\PYGZus{}can\PYGZus{}learn\PYGZus{}username\PYGZus{}from\PYGZdq{}}
\PYG{o}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{\sphinxstylestrong{loguru}}
\label{\detokenize{educational_materials/logging/content:loguru}}
\sphinxAtStartPar
Эта библиотека сделает ваш журнал более простым в использовании. Loguru предоставляет простой и интуитивно понятный интерфейс для протоколирования сообщений и поддерживает расширенные функции, такие как фильтрация журналов, цветной вывод и обработка исключений.

\sphinxAtStartPar
Пример из \sphinxhref{https://medium.com/analytics-vidhya/a-quick-guide-to-using-loguru-4042dc5437a5}{статьи} позволяет понять возможность \sphinxcode{\sphinxupquote{loguru}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{loguru} \PYG{k+kn}{import} \PYG{n}{logger}

\PYG{n}{logger}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{logger}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stderr}\PYG{p}{,} \PYG{n}{backtrace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{diagnose}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{func}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{a} \PYG{o}{/} \PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{n}{func}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{nested}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{func}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{ZeroDivisionError}\PYG{p}{:}
        \PYG{n}{logger}\PYG{o}{.}\PYG{n}{exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Division by zero error!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{nested}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
При запуске мы получим такой вывод:

\sphinxAtStartPar
\sphinxincludegraphics{{loguru_output}.png}


\subsubsection{\sphinxstylestrong{logbook}}
\label{\detokenize{educational_materials/logging/content:logbook}}
\sphinxAtStartPar
Это библиотека ведения логов, которая разработана таким образом, чтобы быть быстрой и эффективной, и предоставляет такие функции, как ведение логов с учетом контекста, гибкое форматирование журнала и поддержка различных уровней ведения журнала.

\sphinxAtStartPar
Как видно, все библиотеки имеют почти одинаковый функционал. Лучшая библиотека ведения журнала для вашего проекта будет зависеть от ваших конкретных потребностей.


\subsection{Централизация логов}
\label{\detokenize{educational_materials/logging/content:id6}}
\sphinxAtStartPar
Централизация логов относится к практике сбора данных журнала из нескольких источников и хранения их в центральном хранилище. Это облегчает управление всей информацией и ее отслеживание, так что вы можете использовать ее для решения проблем и убедиться, что все работает правильно. Наличие всех логов в одном месте также повышает безопасность и помогает уберечь информацию от потери. И это также может ускорить и упростить поиск и устранение проблем, потому что вам не нужно просматривать информацию из множества разных мест.

\sphinxAtStartPar
Существуют различные способы централизации логов, но цель всегда состоит в том, чтобы иметь всю информацию в одном месте, к которому легко получить доступ и которым можно пользоваться.

\sphinxAtStartPar
Существует несколько способов централизации логов, включая использование централизованных систем ведения журнала, таких как Elastic Stack, Logstash или Graylog, или с помощью облачных служб ведения журнала, таких как Google Stackdriver. Наилучший подход к централизации данных журнала будет зависеть от конкретных потребностей.

\sphinxAtStartPar
Мы советуем обратить внимание на стек ELK для централизации логов.


\subsection{Вывод}
\label{\detokenize{educational_materials/logging/content:id7}}
\sphinxAtStartPar
Подведем итог: ведение логов является важнейшим компонентом разработки и эксплуатации программного обеспечения, которое дает ценную информацию. Логирование дает возможность быстро находить проблемы и их источники, устранять их, выявлять конфликты в конфигурационных файлах и следить за безопасностью.

\sphinxstepscope


\section{Задача}
\label{\detokenize{educational_materials/logging/exercises:id1}}\label{\detokenize{educational_materials/logging/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/logging/exercises:id2}}
\sphinxAtStartPar
Используйте код ниже и снабдите его логами уровней SUCCES, DEBUG, INFO. Используйте \sphinxcode{\sphinxupquote{loguru}}. Сделайте так, чтобы для вызова функций с разными аргументами сообщения отличались, т.е. были информативными с точки зрения того, что по ним можно восстановить детали работы приложения. Сообщения вида \sphinxcode{\sphinxupquote{Sum calculated}} не являются информативными, так как каждый вызов функции приведет к одному и тому же сообщению, по которым можно восстановить только время вызова, другая информация не сохраняется, что будет неудобно при анализе логов.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{num1} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{num2} \PYG{o}{=} \PYG{l+m+mi}{20}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}sum}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{loguru}

\PYG{c+c1}{\PYGZsh{} Configure loguru to write logs to a file named \PYGZsq{}app.log\PYGZsq{} with a maximum size of 1 MB per file}
\PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{app.log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sum calculated: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{result}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{num1} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{num2} \PYG{o}{=} \PYG{l+m+mi}{20}

    \PYG{c+c1}{\PYGZsh{} Log the beginning of the calculation}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Starting the calculation of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{num1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{num2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{result} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}sum}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Log the result}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{success}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculation successful! The sum of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{num1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ and }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{num2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ is: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{result}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/logging/exercises:id3}}
\sphinxAtStartPar
Используйте код ниже и снабдите его логами уровней DEBUG, INFO, WARNING и ERROR. Не всегда появление \sphinxcode{\sphinxupquote{exception}} в программе должно приводить к легированию уровня ERROR. Мы можем использовать другие уровни в зависимости от того, как обрабатываются исключения. Подумайте, какие еще проверки можно внести, например, мы не проверяем, что \sphinxcode{\sphinxupquote{data}} в \sphinxcode{\sphinxupquote{process\_data}} является строкой, хотя тело функции это подразумевает.

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{n}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{data}
    \PYG{k}{except} \PYG{n+ne}{FileNotFoundError}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}

\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{data}\PYG{p}{:}
        \PYG{k}{return}

    \PYG{c+c1}{\PYGZsh{} Perform some data processing here}
    \PYG{n}{processed\PYGZus{}data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{processed\PYGZus{}data}

\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
            \PYG{n}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{file\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data.txt}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{data}\PYG{p}{:}
        \PYG{n}{processed\PYGZus{}data} \PYG{o}{=} \PYG{n}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{processed\PYGZus{}data}\PYG{p}{:}
            \PYG{n}{save\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{processed\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{processed\PYGZus{}data}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{loguru}

\PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{app.log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{n}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Data loaded from }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{file\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{data}
    \PYG{k}{except} \PYG{n+ne}{FileNotFoundError}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File not found: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{file\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error loading data from }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{file\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{k+kc}{None}

\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{data}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{No data to process!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return}
    \PYG{n}{processed\PYGZus{}data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{data\PYGZus{}len} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{log\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{data\PYGZus{}len} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Data }\PYG{l+s+si}{\PYGZob{}data[:log\PYGZus{}size]\PYGZcb{}}\PYG{l+s+s2}{ ... }\PYG{l+s+si}{\PYGZob{}data[log\PYGZus{}size:]\PYGZcb{}}\PYG{l+s+s2}{ processed successfully}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{processed\PYGZus{}data}

\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
            \PYG{n}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
            \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Data saved to }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{file\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error saving data to }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{file\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Starting the program}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{file\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data.txt}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{data}\PYG{p}{:}
        \PYG{n}{processed\PYGZus{}data} \PYG{o}{=} \PYG{n}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{processed\PYGZus{}data}\PYG{p}{:}
            \PYG{n}{save\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{processed\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{processed\PYGZus{}data}\PYG{p}{)}

    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Program execution completed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Задача 3}
\label{\detokenize{educational_materials/logging/exercises:id4}}
\sphinxAtStartPar
Модифицируйте код ниже так, чтобы была информация о пользователе, который сделал запрос, а также \sphinxcode{\sphinxupquote{hash}} переданных данных. Напишите логирование для полученного кода.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{flask} \PYG{k+kn}{import} \PYG{n}{Flask}\PYG{p}{,} \PYG{n}{request}\PYG{p}{,} \PYG{n}{jsonify}

\PYG{n}{app} \PYG{o}{=} \PYG{n}{Flask}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}request}\PYG{p}{(}\PYG{n}{request\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Simulate some request processing}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{request\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{k}{return} \PYG{n}{result}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}

\PYG{n+nd}{@app}\PYG{o}{.}\PYG{n}{route}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/api/data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{methods}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{POST}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{handle\PYGZus{}request}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{request\PYGZus{}data} \PYG{o}{=} \PYG{n}{request}\PYG{o}{.}\PYG{n}{get\PYGZus{}json}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{request\PYGZus{}data} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{request\PYGZus{}data}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Invalid request data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{400}

        \PYG{n}{result} \PYG{o}{=} \PYG{n}{process\PYGZus{}request}\PYG{p}{(}\PYG{n}{request\PYGZus{}data}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{result} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{result}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{result}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{200}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error processing request}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{500}

    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Internal server error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{500}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{loguru}
\PYG{k+kn}{import} \PYG{n+nn}{hashlib}
\PYG{k+kn}{from} \PYG{n+nn}{flask} \PYG{k+kn}{import} \PYG{n}{Flask}\PYG{p}{,} \PYG{n}{request}\PYG{p}{,} \PYG{n}{jsonify}

\PYG{c+c1}{\PYGZsh{} Configure loguru to write logs to a file named \PYGZsq{}web\PYGZus{}app.log\PYGZsq{} with a maximum size of 1 MB per file}
\PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{web\PYGZus{}app.log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{app} \PYG{o}{=} \PYG{n}{Flask}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}data\PYGZus{}hash}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data\PYGZus{}str} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{o}{.}\PYG{n}{encode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{hashlib}\PYG{o}{.}\PYG{n}{sha256}\PYG{p}{(}\PYG{n}{data\PYGZus{}str}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hexdigest}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}request}\PYG{p}{(}\PYG{n}{request\PYGZus{}data}\PYG{p}{,} \PYG{n}{user\PYGZus{}id}\PYG{p}{,} \PYG{n}{data\PYGZus{}hash}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Simulate some request processing}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{request\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Data Hash: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{data\PYGZus{}hash}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Request processed successfully. Result: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{result}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{result}
    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Data Hash: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{data\PYGZus{}hash}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Error processing request: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{k+kc}{None}

\PYG{n+nd}{@app}\PYG{o}{.}\PYG{n}{route}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/api/data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{methods}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{POST}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{handle\PYGZus{}request}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{request\PYGZus{}data} \PYG{o}{=} \PYG{n}{request}\PYG{o}{.}\PYG{n}{get\PYGZus{}json}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{user\PYGZus{}id} \PYG{o}{=} \PYG{n}{request\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{user\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Received a request}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Request data: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{request\PYGZus{}data}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{request\PYGZus{}data} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{request\PYGZus{}data} \PYG{o+ow}{or} \PYG{o+ow}{not} \PYG{n}{user\PYGZus{}id}\PYG{p}{:}
            \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Data Hash: N/A | Invalid request data received}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Invalid request data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{400}

        \PYG{n}{data\PYGZus{}hash} \PYG{o}{=} \PYG{n}{compute\PYGZus{}data\PYGZus{}hash}\PYG{p}{(}\PYG{n}{request\PYGZus{}data}\PYG{p}{)}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{process\PYGZus{}request}\PYG{p}{(}\PYG{n}{request\PYGZus{}data}\PYG{p}{,} \PYG{n}{user\PYGZus{}id}\PYG{p}{,} \PYG{n}{data\PYGZus{}hash}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{result} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{success}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Data Hash: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{data\PYGZus{}hash}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Request processed successfully}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{result}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{result}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{200}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{user\PYGZus{}id}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Data Hash: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{data\PYGZus{}hash}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | Error occurred while processing the request}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error processing request}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{500}

    \PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
        \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{critical}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User ID: N/A | Data Hash: N/A | Unhandled exception: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{jsonify}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Internal server error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{500}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{loguru}\PYG{o}{.}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Starting the web application}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/logging/quiz:id1}}\label{\detokenize{educational_materials/logging/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое ведение журнала событий (логов) в контексте разработки программного обеспечения?
а) Процесс отслеживания действий пользователей на веб\sphinxhyphen{}сайте.
б) Метод измерения производительности кода.
в) Метод записи и хранения событий и сообщений во время выполнения программы.
г) Способ оптимизации использования памяти в приложениях.

\item {} 
\sphinxAtStartPar
Какая библиотека входит в стандартную поставку Python и используется для ведения журнала?
а) logbook
б) logging
в) loguru
г) structlog

\item {} 
\sphinxAtStartPar
Каково назначение уровней логирования?
а) Определять различные цвета для сообщений журнала.
б) Группировать сообщения журнала на основе их содержания.
в) Установить размер шрифта сообщений журнала.
г) Классифицировать сообщения журнала по их серьезности.

\item {} 
\sphinxAtStartPar
Какой уровень журнала используется для получения общей информации о потоке выполнения программы?
а) DEBUG
б) INFO
в) WARNING
г) ERROR

\item {} 
\sphinxAtStartPar
Как вы можете настроить логгер библиотеки \sphinxcode{\sphinxupquote{loguru}} для событий в файл с именем «app.log»?
а) \sphinxcode{\sphinxupquote{loguru.logger.write("app.log")}}
б) \sphinxcode{\sphinxupquote{loguru.logger.create("app.log")}}
в) \sphinxcode{\sphinxupquote{loguru.logger.add("app.log")}}
г) \sphinxcode{\sphinxupquote{loguru.logger.output("app.log")}}

\item {} 
\sphinxAtStartPar
Как в библиотеке \sphinxcode{\sphinxupquote{loguru}} можно установить ротацию (rotation) для лог\sphinxhyphen{}файлов?
а) \sphinxcode{\sphinxupquote{loguru.logger.rotation = "ежедневно"}}
б) \sphinxcode{\sphinxupquote{loguru.logger.rotate("ежедневно")}}
в) \sphinxcode{\sphinxupquote{loguru.logger.add\_rotation("ежедневно")}}
г) \sphinxcode{\sphinxupquote{loguru.logger.add("app.log", rotate="daily")}}

\item {} 
\sphinxAtStartPar
Какова цель форматирования журнала в системе регистрации?
а) Для сжатия файлов журналов для повышения эффективности хранения.
б) Чтобы обеспечить согласованную структуру для регистрации сообщений.
в) Для шифрования сообщений журнала из соображений безопасности.
г) Чтобы удалить ненужные записи журнала.

\item {} 
\sphinxAtStartPar
В контексте ведения журнала, в чем разница между уровнями журнала «INFO» и «DEBUG»?
а) «DEBUG» используется для получения подробной низкоуровневой информации, а «INFO» используется для получения общей информации о потоке выполнения программы.
б) «INFO» используется для получения подробной низкоуровневой информации, а «DEBUG» используется для получения общей информации о потоке выполнения программы.
в) И «INFO», и «DEBUG» используются для получения общей информации о потоке выполнения программы, но «DEBUG» менее серьезен, чем «INFO».
г) И «INFO», и «DEBUG» используются для получения подробной низкоуровневой информации, но «INFO» менее серьезен, чем «DEBUG».

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
а)

\end{enumerate}


\chapter{Сборка проекта в pip пакет}
\label{\detokenize{index:pip}}
\sphinxstepscope


\section{Менеджеры пакетов}
\label{\detokenize{educational_materials/packaging/content:id1}}\label{\detokenize{educational_materials/packaging/content::doc}}
\sphinxAtStartPar
Мы уже умеем размещать свой код на платформах типа GitHub, для того чтобы контролировать версию кода и иметь возможность взять код себе на машину локально, отправить свои правки, получать красивую визуализацию коммитов, а также получать обратную связь от других разработчиков в виде \sphinxcode{\sphinxupquote{issue}}, \sphinxcode{\sphinxupquote{fork}}, \sphinxcode{\sphinxupquote{merge request}} и так далее. Попробуем теперь воспользоваться кодом не как программисты\sphinxhyphen{}разработчики, а как программисты\sphinxhyphen{}пользователи. Да, каждый раз когда мы пишем:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{lib\PYGZus{}name}
\PYG{n}{lib\PYGZus{}name}\PYG{o}{.}\PYG{n}{do\PYGZus{}something}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы являемся пользователем функции \sphinxcode{\sphinxupquote{do\_something()}} из библиотеки \sphinxcode{\sphinxupquote{lib\_name}}. Как же нам получить do\_something() там, где мы пишем код, и воспользоваться ей? Рассмотрим сначала простые, но неправильные способы, и потом рассмотрим, как сделать это правильно.


\subsection{Ctrl\sphinxhyphen{}C/Ctrl\sphinxhyphen{}V}
\label{\detokenize{educational_materials/packaging/content:ctrl-c-ctrl-v}}
\sphinxAtStartPar
Первый наивный способ — это просто скопировать функцию себе и вызвать там, где нужно (не делайте так).

\sphinxAtStartPar
Почему это плохо:
\begin{itemize}
\item {} 
\sphinxAtStartPar
теряется поддержка. Если разработчики найдут проблему в коде и устранят его, мы не получим эти изменения, если не находимся в режиме мониторинга версий этого пакета;

\item {} 
\sphinxAtStartPar
тянем кучу другого кода. Скорее всего, у вас даже не получится так просто скопировать отдельную функцию, так как она использует другой код из этого пакета;

\item {} 
\sphinxAtStartPar
теряется контроль зависимостей. Если для работы функций необходима другая библиотека определенной версии, это никак не отображается в коде, \sphinxcode{\sphinxupquote{import matplotlib}} подключит ту библиотеку, которая установлена в окружении. Установка \sphinxcode{\sphinxupquote{pip install matplotlib}} также ничего не даст — будет установлена последняя версия библиотеки \sphinxcode{\sphinxupquote{matplotlib}}. Правильная версия библиотеки должна располагаться в правильно структурированном репозитории, и чтобы ее найти, нужно совершить дополнительное действие;

\item {} 
\sphinxAtStartPar
нет возможность запустить тесты. Как правило, в библиотеках содержатся тесты, которые можно запустить и проверить, все ли корректно работает именно на этой машине. Просто копируя функцию, мы не подтягиваем автоматически тесты.

\end{itemize}


\subsection{Клонируем и указываем путь через sys}
\label{\detokenize{educational_materials/packaging/content:sys}}
\sphinxAtStartPar
Мы можем сделать клон репозитория:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }clone\PYG{+w}{ }url
\end{sphinxVerbatim}

\sphinxAtStartPar
и установить все необходимые библиотеки, используемые в проекте, в том случае, если таковые имеются. Для этого в репозитории помимо кода можно найти файл \sphinxcode{\sphinxupquote{requirements.txt}}, который предназначен для перечисления названий пакетов (библиотек) с указанием их версий. Таким образом, вы сможете использовать точные версии всех библиотек, которыми пользовался разработчик. После того, как вы клонировали репозиторий, в котором присутствует файл \sphinxcode{\sphinxupquote{requirements.txt}}, вам следует установить перечисленные в нем библиотеки. Это можно выполнить, используя менеджер пакетов \sphinxcode{\sphinxupquote{pip}}, командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }requirements.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
Если нам повезет, там будут указаны версии библиотек, для которых разработчик тестировал работоспособность этого пакета. Также мы можем прогнать тесты и убедиться, что все работает как надо. После этого мы можем указать путь до библиотеки прямо в коде (актуально для Python 3.5+):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{importlib}\PYG{n+nn}{.}\PYG{n+nn}{util} \PYG{k+kn}{import} \PYG{p}{(}\PYG{n}{spec\PYGZus{}from\PYGZus{}file\PYGZus{}location}\PYG{p}{,} \PYG{n}{module\PYGZus{}from\PYGZus{}spec}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{n}{spec} \PYG{o}{=} \PYG{n}{spec\PYGZus{}from\PYGZus{}file\PYGZus{}location}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{module.name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/my\PYGZus{}package/my\PYGZus{}module.py}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{foo} \PYG{o}{=} \PYG{n}{module\PYGZus{}from\PYGZus{}spec}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{modules}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{module.name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{foo}
\PYG{n}{spec}\PYG{o}{.}\PYG{n}{loader}\PYG{o}{.}\PYG{n}{exec\PYGZus{}module}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{n}{foo}\PYG{o}{.}\PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
или так:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/my\PYGZus{}package}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{my\PYGZus{}module}
\PYG{n}{my\PYGZus{}module}\PYG{o}{.}\PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Уже лучше, но по\sphinxhyphen{}прежнему мы должны помнить, что нужно проверять новые версии, процесс установки полностью ручной, а то, что мы написали в коде, выглядит как костыль. Мы также можем добавить путь к пакету в \sphinxcode{\sphinxupquote{PYTHONPATH}}, используя \sphinxcode{\sphinxupquote{bash}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export}\PYG{+w}{ }\PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}/path/to/my\PYGZus{}package\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверить, что переменная установилась, можно, вызвав команду \sphinxcode{\sphinxupquote{echo \$PYTHONPATH}}. После этого можно запустить интерпретатор Python и проверить, что все работает, и что путь уже добавлен в \sphinxcode{\sphinxupquote{sys.path}}


\subsection{Ставим через pip, используя git репозиторий}
\label{\detokenize{educational_materials/packaging/content:pip-git}}
\sphinxAtStartPar
Мы добрались до более распространенных способов управления зависимостями. Здесь мы уже используем pip и публично доступный репозиторий на GitHub для установки. Примечание: мы его использовали в предыдущем пункте, но чтобы поставить зависимости устанавливаемой библиотеки, а не саму библиотеку.

\sphinxAtStartPar
Прежде чем мы перейдем к тому способу, которым мы привыкли пользоваться:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }lib\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Проговорим еще раз, что существует такой способ. Если вы пропустили предыдущий урок, вернитесь и посмотрите, что должно содержаться в проекте для того, чтобы другие разработчики могли им воспользоваться. Не для всех языков программирования есть аналог \sphinxcode{\sphinxupquote{pip}}, а понимание того, что в репозитории может содержаться вся необходимая информация для того, чтобы установить/собрать библиотеку, поможет легче найти решение проблемы установки для других языков.


\subsubsection{Немного про pip}
\label{\detokenize{educational_materials/packaging/content:pip}}
\sphinxAtStartPar
Для инфраструктуры \sphinxcode{\sphinxupquote{python}} менеджер пакетов \sphinxcode{\sphinxupquote{pip}} является стандартом де факто, хотя появился с текущим именем не так \sphinxhref{https://ianbicking.org/blog/2008/10/pyinstall-is-dead-long-live-pip.html}{давно}. Концепция менеджеров пакетов удобна для программиста, поэтому некоторые языки программирования и фреймворки реализуют ее для управления зависимостями:
\begin{itemize}
\item {} 
\sphinxAtStartPar
JavaScript: npm

\item {} 
\sphinxAtStartPar
Ruby: gem

\item {} 
\sphinxAtStartPar
.NET: NuGet

\end{itemize}

\sphinxAtStartPar
Для С++ существует проекты, которые направлены на решение этой проблемы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vector-of-bool/dds}{bpt}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.cpm.rocks/}{cpm}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://conan.io/}{conan}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/poacpm/poac}{poac}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://sourcey.com/pacm/}{pacm}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://spack.io}{spack}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://buckaroo.pm}{buckaroo}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ruslo/hunter}{hunter}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Microsoft/vcpkg}{vcpkg}

\end{itemize}

\sphinxAtStartPar
В Python также существуют альтернативы \sphinxcode{\sphinxupquote{pip}}, об одной из них мы поговорим ниже.

\sphinxAtStartPar
Что же делает менеджер пакетов? Первый очевидный ответ: он кладет (а перед этим еще и скачивает их сам из сети) файлы библиотеки в правильное место: там, где его сможет найти язык программирования, чтобы импортировать.

\sphinxAtStartPar
Второе свойство менеджера пакетов: он хранит историю версий библиотеки так, чтобы мы могли установить нужную нам. \sphinxstyleemphasis{Примечание: не путайте версию библиотеки и версию в плане ссылки на конкретный коммит в git; не каждый коммит ведет к обновлению версии библиотеки в менеджере проектов}. Кроме того, менеджер проектов знает, какие зависимости нужны именно этой версии библиотеки, таким образом, у нас есть дерево зависимостей.

\sphinxAtStartPar
Третье: менеджер проектов дает возможность прогнать тесты при установке так, чтобы мы были уверены, что сделали все возможное, чтобы получить работающую библиотеку. При этом никто не гарантирует, что тесты полностью покрывают все возможные ситуации, но часть из них — точно, и всегда неплохая идея проверить хотя бы их.


\subsection{Делаем сборку библиотеки для публикации. \sphinxstyleliteralintitle{\sphinxupquote{pip}}}
\label{\detokenize{educational_materials/packaging/content:id2}}
\sphinxAtStartPar
Когда нам нужна функциональность какой\sphinxhyphen{}либо библиотеки в Python, скорее всего, мы ставим ее через pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }lib\PYGZus{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Когда мы это делаем, \sphinxcode{\sphinxupquote{pip}} просматривает публичный репозиторий пакетов Python Package Index (PyPI). Мы также можем \sphinxhref{https://packaging.python.org/en/latest/guides/hosting-your-own-index/}{хостить} зеркало PyPI, если нам это для чего\sphinxhyphen{}то нужно. Если \sphinxcode{\sphinxupquote{lib\_name}} находится в PyPI, будет выполнена попытка установки. В PyPI расположен сам пакет, но в чем же отличие от установки через связку pip+git? Библиотека может распространяться в виде исходных текстовых файлов \sphinxstylestrong{Source Distribution (sdist)}  или собранных файлов \sphinxstylestrong{Built Distribution (bdist)}. Мы будем использовать \sphinxcode{\sphinxupquote{sdist}} и \sphinxcode{\sphinxupquote{bdist}} далее по тексту.

\sphinxAtStartPar
Процесс создания \sphinxcode{\sphinxupquote{sdist}} проще, чем \sphinxcode{\sphinxupquote{bdist}}, и на самом деле, мы уже это проделывали. Для этого вида нужно, чтобы весь исходный код, а также другие необходимые файлы были собраны в одном месте. Среди файлов должен быть \sphinxcode{\sphinxupquote{setup.py}}, в котором содержатся инструкции для \sphinxcode{\sphinxupquote{setuputils}}, как правильно собрать пакет. Мы можем создать дистрибутив \sphinxcode{\sphinxupquote{sdist}}, запустив:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }setup.py\PYG{+w}{ }sdist\PYG{+w}{ }
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Напоминание: ранее мы использовали \sphinxcode{\sphinxupquote{python setup.py install}} для установки}. По умолчанию дистрибутив будет сгенерирован в виде tar\sphinxhyphen{}архива (). Другие варианты сжатия можно указать при сборке.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }setup.py\PYG{+w}{ }sdist\PYG{+w}{ }\PYGZhy{}\PYGZhy{}formats\PYG{o}{=}zip,gztar,bztar,ztar,tar\PYG{+w}{ }
\end{sphinxVerbatim}

\sphinxAtStartPar
После установки \sphinxcode{\sphinxupquote{sdist}} файл setup.py запускается на хосте, обеспечивая правильную установку этого пакета. Таким образом, мы при \sphinxcode{\sphinxupquote{sdist}} получаем исходные тексты программ, которые собираются на нашей системе.

\sphinxAtStartPar
Второй тип, \sphinxcode{\sphinxupquote{bdist}}, немного сложнее для разработчика, так как он собирает пакет до того, как опубликовать его. Это убирает необходимость собирать пакет на стороне пользователя, так как он уже получит собранные библиотеки (\sphinxcode{\sphinxupquote{.pyc}}, \sphinxcode{\sphinxupquote{.so}}, \sphinxcode{\sphinxupquote{.dll}}) и может использовать их сразу. На данный момент существуют два основных формата распространения для \sphinxstylestrong{bdist} — \sphinxhref{https://packaging.python.org/en/latest/discussions/wheel-vs-egg/}{eggs и wheels}, более современным считается \sphinxstylestrong{wheels}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }setup.py\PYG{+w}{ }bdist\PYGZus{}wheel\PYG{+w}{ }
\end{sphinxVerbatim}


\subsubsection{Преимущества bdist (wheels):}
\label{\detokenize{educational_materials/packaging/content:bdist-wheels}}\begin{itemize}
\item {} 
\sphinxAtStartPar
меньший объем пакета и более быстрая установка пакетов Python или пакетов с расширениями на языке C;

\item {} 
\sphinxAtStartPar
при сборке из исходных файлов (\sphinxcode{\sphinxupquote{sdist}}) требуется выполнение произвольного кода для сборки (то, что записано в \sphinxcode{\sphinxupquote{setup.py}}), что может быть не всегда приемлемо с точки зрения безопасности;

\item {} 
\sphinxAtStartPar
по умолчанию \sphinxcode{\sphinxupquote{pip}} пытается поставить \sphinxcode{\sphinxupquote{bdist}}.

\end{itemize}

\sphinxAtStartPar
Помня о том, что \sphinxcode{\sphinxupquote{bdist}} является предпочтительным для распространения своего пакета, публикуйте также \sphinxstylestrong{sdist}, так как такое распространение позволяет собирать проект под системы, для которых не предоставлен \sphinxstylestrong{bdist}.


\subsubsection{Настраиваем окружение}
\label{\detokenize{educational_materials/packaging/content:id3}}
\sphinxAtStartPar
Возьмем проект \sphinxhref{https://github.com/standlab/mtracker}{mtracker} с предыдущего занятия. Переключимся на ветку \sphinxcode{\sphinxupquote{pypi\_ready}}, чтобы не ломать основной код (и, конечно, еще раз потренируемся с \sphinxcode{\sphinxupquote{git}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/standlab/mtracker.git

git\PYG{+w}{ }checkout\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }pypi\PYGZus{}ready
\end{sphinxVerbatim}

\sphinxAtStartPar
Добавим несколько нововведений. Ранее мы не использовали никаких дополнительных библиотек, \sphinxcode{\sphinxupquote{install\_requires={[}{]}}}. Сейчас мы хотим добавить библиотеку \sphinxcode{\sphinxupquote{matplotlib}} в зависимости к проекту. Мы будем использовать виртуальное окружение с помощью \sphinxcode{\sphinxupquote{pipenv}} (о виртуальных окружениях есть отдельный урок). \sphinxcode{\sphinxupquote{pipenv}} \sphinxhref{https://pythonhow.com/what/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrapper-pipenv/}{комбинирует} функциональность виртуального окружения, которое можно получить с помощью \sphinxcode{\sphinxupquote{venv}} или \sphinxcode{\sphinxupquote{virtualenv}} c менеджером пакетов \sphinxcode{\sphinxupquote{pip}}. \sphinxstyleemphasis{Настраивать виртуальное окружение всегда полезно, так как это изолирует все специфичные зависимости. У нас на практике был случай, когда установка библиотеки напрочь сломала среду разработки Spyder (стандартная среда поставки Anaconda)}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3\PYG{+w}{ }install\PYG{+w}{ }pipenv
\end{sphinxVerbatim}

\sphinxAtStartPar
Переходим в папку проекта \sphinxcode{\sphinxupquote{cd ./mtracker}}, если не сделали это ранее, и создаем окружение.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pipenv\PYG{+w}{ }install
\end{sphinxVerbatim}

\sphinxAtStartPar
или

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pipenv\PYG{+w}{ }install
\end{sphinxVerbatim}

\sphinxAtStartPar
После этого появятся два новых файла (проверьте через \sphinxcode{\sphinxupquote{git status}}): \sphinxcode{\sphinxupquote{Pipfile}} и \sphinxcode{\sphinxupquote{Pipfile.lock}}. Содержимое \sphinxcode{\sphinxupquote{Pipfile}} без дополнительных зависимостей выглядит так:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }Pipfile
\PYG{+w}{    }\PYG{o}{[}\PYG{o}{[}source\PYG{o}{]}\PYG{o}{]}
\PYG{+w}{    }\PYG{n+nv}{url}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}https://pypi.org/simple\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nv}{verify\PYGZus{}ssl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}
\PYG{+w}{    }\PYG{n+nv}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}pypi\PYGZdq{}}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}packages\PYG{o}{]}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}dev\PYGZhy{}packages\PYG{o}{]}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}requires\PYG{o}{]}
\PYG{+w}{    }\PYG{n+nv}{python\PYGZus{}version}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}3.10\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Пустой \sphinxcode{\sphinxupquote{Pipfile.lock}} содержит примерно ту же информацию. Теперь активируем виртуальное окружение и выполним установку \sphinxcode{\sphinxupquote{matplotlib}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pipenv\PYG{+w}{ }shell
pipenv\PYG{+w}{ }install\PYG{+w}{ }matplotlib
\end{sphinxVerbatim}

\sphinxAtStartPar
И еще раз взглянем на \sphinxcode{\sphinxupquote{Pipfile}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }Pipfile
\PYG{+w}{    }\PYG{o}{[}\PYG{o}{[}source\PYG{o}{]}\PYG{o}{]}
\PYG{+w}{    }\PYG{n+nv}{url}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}https://pypi.org/simple\PYGZdq{}}
\PYG{+w}{    }\PYG{n+nv}{verify\PYGZus{}ssl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}
\PYG{+w}{    }\PYG{n+nv}{name}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}pypi\PYGZdq{}}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}packages\PYG{o}{]}
\PYG{+w}{    }\PYG{n+nv}{matplotlib}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}dev\PYGZhy{}packages\PYG{o}{]}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{o}{[}requires\PYG{o}{]}
\PYG{+w}{    }\PYG{n+nv}{python\PYGZus{}version}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}3.10\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Содержимое \sphinxcode{\sphinxupquote{Pipfile.lock}} теперь выглядит громоздко, но мы также видим, что там теперь есть информация \sphinxcode{\sphinxupquote{matplotlib}}, после выполнения \sphinxcode{\sphinxupquote{cat Pipfile.lock}}. И содержится вся необходимая информация по зависимостям и их версиям.

\sphinxAtStartPar
Теперь мы можем прописать \sphinxcode{\sphinxupquote{install\_requires}} вручную или загрузить из файла:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{json}
\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{path}

\PYG{n}{here} \PYG{o}{=} \PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{n}{path}\PYG{o}{.}\PYG{n}{dirname}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{here}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{README.rst}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{long\PYGZus{}description} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}dependencies}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{filepath} \PYG{o}{=} \PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{here}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{)}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filepath}\PYG{p}{)} \PYG{k}{as} \PYG{n}{piplock}\PYG{p}{:}
        \PYG{n}{content} \PYG{o}{=} \PYG{n}{json}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{piplock}\PYG{p}{)}
        \PYG{k}{return} \PYG{p}{[}\PYG{n}{dependency} \PYG{k}{for} \PYG{n}{dependency} \PYG{o+ow}{in} \PYG{n}{content}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Также мы можем выполнить перед сборкой другие операции, которые могут проверить аннотацию типов, форматирование кода, валидность кода, собрать документацию и выполнить тесты. Аннотация типов необязательна для Python, но улучшает читаемость кода. Рассмотрим некоторые из операций, остальные будем изучать на отдельных уроках. Начнем с форматирования кода. В Python общепринятым является оформление согласно \sphinxhref{https://peps.python.org/pep-0008/}{PEP8}.

\sphinxAtStartPar
\sphinxstyleemphasis{Примечание: предложение по улучшению языка Python \sphinxhref{https://peps.python.org/pep-0000/}{PEP} (Python Enhancement Proposals) можно считать руководством по хорошим практикам и подходом к решению определенных задач, до которых дошло сообщество Python\sphinxhyphen{}разработчиков. \sphinxstylestrong{PEP} пронумерованы, и \sphinxstylestrong{PEP8} описывает стиль кода на языке Python}.


\paragraph{Немного о форматировании по PEP8}
\label{\detokenize{educational_materials/packaging/content:pep8}}
\sphinxAtStartPar
Здесь мы не будем подробно останавливаться на всех рекомендациях из PEP8, но посмотрим на \sphinxcode{\sphinxupquote{autopep8}}. Этот инструмент поможет нам скорректировать форматирование, например, уберет лишние пробелы или правильно расположит код.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }sample.py\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nv}{foo}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}blah\PYGZsq{}}:\PYG{+w}{ }do\PYGZus{}blah\PYGZus{}thing\PYG{o}{(}\PYG{o}{)}
\PYG{+w}{    }do\PYGZus{}one\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}\PYG{+w}{ }do\PYGZus{}two\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}\PYG{+w}{ }do\PYGZus{}three\PYG{o}{(}\PYG{o}{)}
\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }autopep8\PYG{+w}{ }./sample.py\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{n+nv}{foo}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}blah\PYGZsq{}}:
\PYG{+w}{        }do\PYGZus{}blah\PYGZus{}thing\PYG{o}{(}\PYG{o}{)}
\PYG{+w}{    }do\PYGZus{}one\PYG{o}{(}\PYG{o}{)}
\PYG{+w}{    }do\PYGZus{}two\PYG{o}{(}\PYG{o}{)}
\PYG{+w}{    }do\PYGZus{}three\PYG{o}{(}\PYG{o}{)}
\PYG{+w}{    }
\end{sphinxVerbatim}

\sphinxAtStartPar
Не все, что написано в PEP8, может быть поправлено автоматически, например, \sphinxcode{\sphinxupquote{autopep8}} не поправит неинформативные комментарии.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} line with not usefull comment }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}                 \PYG{c+c1}{\PYGZsh{} Increment x}

\PYG{c+c1}{\PYGZsh{} line with usefull comment }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}                 \PYG{c+c1}{\PYGZsh{} Compensate for border}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }sample.py\PYG{+w}{ }
\PYG{n+nv}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }x\PYG{+w}{ }+\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{         }\PYG{c+c1}{\PYGZsh{} Increment x}
\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }autopep8\PYG{+w}{ }./sample.py\PYG{+w}{ }
\PYG{n+nv}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }x\PYG{+w}{ }+\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{         }\PYG{c+c1}{\PYGZsh{} Increment x}
\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}/tmp\PYGZdl{}\PYG{+w}{ }
\end{sphinxVerbatim}


\paragraph{Возвращаемся в проект}
\label{\detokenize{educational_materials/packaging/content:id4}}
\sphinxAtStartPar
Установим \sphinxcode{\sphinxupquote{autopep8}}, но так как это пакет для сборки, а не зависимость самого кода, сделаем это с флагом \sphinxcode{\sphinxupquote{\sphinxhyphen{}d}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pipenv\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }autopep8
\end{sphinxVerbatim}

\sphinxAtStartPar
Посмотрим файл Pipfile и увидим, что в секции \sphinxcode{\sphinxupquote{{[}dev\sphinxhyphen{}packages{]}}} появилась новая строка:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}dev\PYGZhy{}packages\PYG{o}{]}
\PYG{n+nv}{autopep8}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Также поставим \sphinxcode{\sphinxupquote{pytest}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pipenv\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }pytest
\end{sphinxVerbatim}

\sphinxAtStartPar
Остальные аспекты пока оставим для дальнейших занятий.

\sphinxAtStartPar
Теперь мы готовы написать Make\sphinxhyphen{}файл для сборки своего пакета. Мы использовали \sphinxcode{\sphinxupquote{pipenv shell}}, чтобы активировать окружение и работать в нем, в makefile мы пропишем явно, что команды выполняются в нашем окружении, т.е. вместо \sphinxcode{\sphinxupquote{pytest}} мы напишем \sphinxcode{\sphinxupquote{pipenv run pytest}}, и так далее. В \sphinxcode{\sphinxupquote{makefile}} мы определяем так называемые \sphinxcode{\sphinxupquote{target}} (задачи), которые будут выполняться, когда мы напишем \sphinxcode{\sphinxupquote{make SPECIFY\_TARGET}}. Например, для активации окружения и установки зависимостей мы определяем задачу \sphinxcode{\sphinxupquote{dev}}, и когда мы выполним \sphinxcode{\sphinxupquote{make dev}}, то выполнится все, что относиться к ней, в нашем случае \sphinxcode{\sphinxupquote{pipenv install \sphinxhyphen{}\sphinxhyphen{}dev}}. Чтобы определить зависимость от другой задачи, которая должна выполниться заранее, мы указываем ее имя после двоеточия.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{help}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Make project with following instructions\PYGZdq{}}
\PYG{+w}{	}@cat\PYG{+w}{ }Makefile

\PYG{n+nf}{dev}\PYG{o}{:}
\PYG{+w}{	}pipenv\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}dev

\PYG{n+nf}{test}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{dev}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }pytest\PYG{+w}{ }\PYGZhy{}\PYGZhy{}doctest\PYGZhy{}modules\PYG{+w}{ }\PYGZhy{}\PYGZhy{}junitxml\PYG{o}{=}junit/test\PYGZhy{}results.xml

\PYG{n+nf}{build}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{clean}
\PYG{+w}{	}pipenv\PYG{+w}{ }install\PYG{+w}{ }wheel
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }python\PYG{+w}{ }setup.py\PYG{+w}{ }sdist\PYG{+w}{ }bdist\PYGZus{}wheel

\PYG{n+nf}{clean}\PYG{o}{:}
\PYG{+w}{	}@rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }.pytest\PYGZus{}cache/\PYG{+w}{ }.mypy\PYGZus{}cache/\PYG{+w}{ }junit/\PYG{+w}{ }build/\PYG{+w}{ }dist/\PYG{+w}{ }
\PYG{+w}{	}@find\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}not\PYG{+w}{ }\PYGZhy{}path\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}./.venv*\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}path\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}*/\PYGZus{}\PYGZus{}pycache\PYGZus{}\PYGZus{}*\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}delete
\PYG{+w}{	}@find\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}not\PYG{+w}{ }\PYGZhy{}path\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}./.venv*\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}path\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}*/*.egg\PYGZhy{}info*\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}delete
\end{sphinxVerbatim}

\sphinxAtStartPar
Указав \sphinxcode{\sphinxupquote{test: dev}}, мы сделали опцию \sphinxcode{\sphinxupquote{test}} зависимой от опции \sphinxcode{\sphinxupquote{dev}}, и поэтому выполнится сначала она, а затем уже \sphinxcode{\sphinxupquote{test}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pipenv\PYG{+w}{ }shell\PYG{+w}{ }
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }make\PYG{+w}{ }\PYG{n+nb}{test}
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}e\PYG{+w}{ }.


\PYG{o}{(}base\PYG{o}{)}\PYG{+w}{ }artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pytest\PYG{+w}{ }\PYGZhy{}\PYGZhy{}doctest\PYGZhy{}modules\PYG{+w}{ }\PYGZhy{}\PYGZhy{}junitxml\PYG{o}{=}junit/test\PYGZhy{}results.xml
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }session\PYG{+w}{ }\PYG{n+nv}{starts}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
platform\PYG{+w}{ }linux\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }Python\PYG{+w}{ }\PYG{l+m}{3}.10.9,\PYG{+w}{ }pytest\PYGZhy{}7.2.1,\PYG{+w}{ }pluggy\PYGZhy{}1.0.0
rootdir:\PYG{+w}{ }/home/artem/swdev/gitrepo/edu/toolchain\PYGZus{}proj/mtracker
collected\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }item\PYG{+w}{                                                                 }

test/test\PYGZus{}mtracker.py\PYG{+w}{ }.\PYG{+w}{                                                    }\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]}

\PYGZhy{}\PYG{+w}{ }generated\PYG{+w}{ }xml\PYG{+w}{ }file:\PYG{+w}{ }/home/artem/swdev/gitrepo/edu/toolchain\PYGZus{}proj/mtracker/junit/test\PYGZhy{}results.xml\PYG{+w}{ }\PYGZhy{}
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }passed\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{0}.06s\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\end{sphinxVerbatim}

\sphinxAtStartPar
Мы видим, что тесты проходят, и мы готовы собрать наш проект. Сделаем для начала очистку и посмотрим, какие файлы добавились при сборке.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }make\PYG{+w}{ }clean
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }ls
\PYG{+w}{    }LICENSE\PYG{+w}{   }mtracker\PYG{+w}{  }Pipfile.lock\PYG{+w}{  }requirements.txt\PYG{+w}{  }\PYG{n+nb}{test}
\PYG{+w}{    }Makefile\PYG{+w}{  }Pipfile\PYG{+w}{   }README.md\PYG{+w}{     }setup.py
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }make\PYG{+w}{ }build\PYG{+w}{ }
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }ls
\PYG{+w}{    }build\PYG{+w}{  }LICENSE\PYG{+w}{   }mtracker\PYG{+w}{           }Pipfile\PYG{+w}{       }README.md\PYG{+w}{         }setup.py
\PYG{+w}{    }dist\PYG{+w}{   }Makefile\PYG{+w}{  }mtracker.egg\PYGZhy{}info\PYG{+w}{  }Pipfile.lock\PYG{+w}{  }requirements.txt\PYG{+w}{  }\PYG{n+nb}{test}
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }ls\PYG{+w}{ }dist
\PYG{+w}{    }mtracker\PYGZhy{}1.0\PYGZhy{}py3\PYGZhy{}none\PYGZhy{}any.whl
\end{sphinxVerbatim}

\sphinxAtStartPar
У нас появилось несколько новых каталогов. И наш собранный пакет расположен в \sphinxcode{\sphinxupquote{dist}}. Проверим, что mtracker не установлен в нашем окружении, команда ниже ничего не должна вывести.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }list\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }grep\PYG{+w}{ }mtracker
\end{sphinxVerbatim}

\sphinxAtStartPar
И устанавливаем собранный пакет \sphinxcode{\sphinxupquote{mtracker\sphinxhyphen{}1.0\sphinxhyphen{}py3\sphinxhyphen{}none\sphinxhyphen{}any.whl}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }./dist/*.whl
artem@pc:\PYGZti{}\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }list\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }grep\PYG{+w}{ }mtracker
\PYG{+w}{    }mtracker\PYG{+w}{         }\PYG{l+m}{1}.0
\end{sphinxVerbatim}


\subsection{Публикация в PyPI}
\label{\detokenize{educational_materials/packaging/content:pypi}}
\sphinxAtStartPar
Теперь, когда у нас есть библиотека в собранном виде, мы можем опубликовать ее в PyPI. Чтобы не засорять \sphinxhref{https://pypi.org/}{основной индекс}, можно публиковать в \sphinxhref{https://test.pypi.org/}{тестовом}. Для публикации своей библиотеки мы будем использовать утилиту \sphinxcode{\sphinxupquote{twine}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip\PYG{+w}{ }install\PYG{+w}{ }twine
\end{sphinxVerbatim}

\sphinxAtStartPar
У нас уже есть все для публикации, так как мы уже настроили сборку проекта, и у нас есть как \sphinxcode{\sphinxupquote{bdist}}, так и \sphinxcode{\sphinxupquote{sdist}}. Зарегистрируйтесь в \sphinxhref{https://test.pypi.org/}{тестовом} индексе пакетов и выполните две команды, после чего вам будет предложено ввести логин и пароль, \sphinxstylestrong{не забудьте также проверить, что имя библиотеки не занято}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
twine\PYG{+w}{ }check\PYG{+w}{ }dist/*
twine\PYG{+w}{ }upload\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }testpypi\PYG{+w}{ }dist/*
\end{sphinxVerbatim}

\sphinxAtStartPar
После этого вы (и кто угодно) можете установить библиотеку:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }https://test.pypi.org/simple\PYG{+w}{ }mtracker
\end{sphinxVerbatim}

\sphinxAtStartPar
Параметр \sphinxcode{\sphinxupquote{\sphinxhyphen{}i https://test.pypi.org/simple}} нужен только при использовании тестового индекса пакетов.

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/packaging/exercises:id1}}\label{\detokenize{educational_materials/packaging/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/packaging/exercises:id2}}
\sphinxAtStartPar
Добавьте в makefile задачи для автоматического форматирования кода по \sphinxcode{\sphinxupquote{pep8}}, а также для публикации проекта в PyPI. Добавьте информационное сообщение для каждой задачи в \sphinxcode{\sphinxupquote{makefile}}.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{PACKAGE\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }mtracker
\PYG{n+nv}{PYTHON}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }pipenv\PYG{+w}{ }run\PYG{+w}{ }python

\PYG{n+nf}{.PHONY}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{install} \PYG{n}{test} \PYG{n}{clean} \PYG{n}{package} \PYG{n}{docs} \PYG{n}{publish} \PYG{n}{format} \PYG{n}{build}

\PYG{n+nf}{install}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Setting up pipenv virtual environment...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}dev

\PYG{n+nf}{test}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Running tests...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }pytest

\PYG{n+nf}{clean}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Cleaning up...\PYGZdq{}}
\PYG{+w}{	}rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }dist/\PYG{+w}{ }build/\PYG{+w}{ }*.egg\PYGZhy{}info

\PYG{n+nf}{package}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Packaging the library...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }setup.py\PYG{+w}{ }sdist\PYG{+w}{ }bdist\PYGZus{}wheel

\PYG{n+nf}{docs}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Generating documentation...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }pdoc\PYG{+w}{ }\PYGZhy{}\PYGZhy{}html\PYG{+w}{ }\PYG{k}{\PYGZdl{}(}PACKAGE\PYGZus{}NAME\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}output\PYGZhy{}dir\PYG{+w}{ }docs\PYG{+w}{ }\PYGZhy{}\PYGZhy{}force

\PYG{n+nf}{publish}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{package}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Publishing the package to PyPI...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }twine\PYG{+w}{ }upload\PYG{+w}{ }dist/*

\PYG{n+nf}{format}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Formatting code with autopep8...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }autopep8\PYG{+w}{ }\PYGZhy{}\PYGZhy{}in\PYGZhy{}place\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive\PYG{+w}{ }mtracker\PYG{+w}{ }tests
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/packaging/exercises:id3}}
\sphinxAtStartPar
Прямой вызов \sphinxcode{\sphinxupquote{setup.py}} считается не самым надежным на сегодня способом. Мы написали урок с его использованием для того, чтобы показать явно все шаги. Прочитайте \sphinxhref{https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html}{статью} и замените вызов \sphinxcode{\sphinxupquote{python setup.py}} на \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m build}}.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{PACKAGE\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }mtracker
\PYG{n+nv}{PYTHON}\PYG{+w}{ }\PYG{o}{:=}\PYG{+w}{ }pipenv\PYG{+w}{ }run\PYG{+w}{ }python

\PYG{n+nf}{.PHONY}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{install} \PYG{n}{test} \PYG{n}{clean} \PYG{n}{package} \PYG{n}{docs} \PYG{n}{publish} \PYG{n}{format} \PYG{n}{build}

\PYG{n+nf}{install}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Setting up pipenv virtual environment...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}dev

\PYG{n+nf}{test}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Running tests...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }pytest

\PYG{n+nf}{clean}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Cleaning up...\PYGZdq{}}
\PYG{+w}{	}rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }dist/\PYG{+w}{ }build/\PYG{+w}{ }*.egg\PYGZhy{}info

\PYG{n+nf}{package}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Packaging the library...\PYGZdq{}}
\PYG{+w}{	}\PYG{k}{\PYGZdl{}(}PYTHON\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }build

\PYG{n+nf}{docs}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Generating documentation...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }pdoc\PYG{+w}{ }\PYGZhy{}\PYGZhy{}html\PYG{+w}{ }\PYG{k}{\PYGZdl{}(}PACKAGE\PYGZus{}NAME\PYG{k}{)}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}output\PYGZhy{}dir\PYG{+w}{ }docs\PYG{+w}{ }\PYGZhy{}\PYGZhy{}force

\PYG{n+nf}{publish}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{package}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Publishing the package to PyPI...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }twine\PYG{+w}{ }upload\PYG{+w}{ }dist/*

\PYG{n+nf}{format}\PYG{o}{:}
\PYG{+w}{	}@echo\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Formatting code with autopep8...\PYGZdq{}}
\PYG{+w}{	}pipenv\PYG{+w}{ }run\PYG{+w}{ }autopep8\PYG{+w}{ }\PYGZhy{}\PYGZhy{}in\PYGZhy{}place\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive\PYG{+w}{ }mtracker\PYG{+w}{ }tests
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/packaging/quiz:id1}}\label{\detokenize{educational_materials/packaging/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какова цель упаковки проекта Python?
а) Для увеличения сложности проекта.
б) Чтобы скрыть исходный код от других.
в) Чтобы распространять проект как повторно используемую библиотеку или приложение.
г) Чтобы ограничить использование проекта определенными версиями Python.

\item {} 
\sphinxAtStartPar
Какой файл обычно используется для указания метаданных проекта и зависимостей для пакета Python?
а) requirements.txt
б) metadata.json
в) package.json
г) setup.py

\item {} 
\sphinxAtStartPar
Какая команда используется для создания bdist дистрибутива (wheel)?
а) pip wheel
б) python \sphinxhyphen{}m wheel
в) python \sphinxhyphen{}m build
г) python setup.py bdist\_wheel

\item {} 
\sphinxAtStartPar
Что из следующего является стандартным инструментом для создания и распространения пакетов Python?
а) pyinstaller
б) virtualenv
в) pipenv
г) setuptools

\item {} 
\sphinxAtStartPar
Где при использовании setuptools разработчик указывает метаданные пакета, зависимости и точки входа в пакет?
а) функция setup()
б) package\_info.json
в) requirements.txt
г) модуль distutils

\item {} 
\sphinxAtStartPar
Каков рекомендуемый способ указания зависимостей проекта в пакете Python при использовании setuptools?
а) Непосредственно включить зависимости в основной файл проекта.
б) Вставить зависимости в файл MANIFEST.in.
в) Добавить зависимости в файл requirements.txt.
г) Указать зависимости в файле setup.py.

\item {} 
\sphinxAtStartPar
Какова цель файла \sphinxstylestrong{init}.py пакета Python?
а) Он содержит основной код пакета.
б) Он используется для объявления зависимостей пакетов.
в) Это специальный файл, который может не содержать код, для явного указания на то, что каталог является пакетом Python.
г) Генерируется автоматически в процессе упаковки.

\item {} 
\sphinxAtStartPar
В чем преимущество использования виртуальной среды Python (например, virtualenv или pipenv) для создания пакетов?
а) Позволяет распространять проект в виде одного исполняемого файла.
б) Это гарантирует, что зависимости проекта изолированы от основного системного Python.
в) Он автоматически генерирует файл requirements.txt для проекта.
г) Он включает автоматическую упаковку без необходимости в файле setup.py.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
г)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
г) (также возможен вариант в) при условии, что в ответе будет указано, что зависимости нужно подтянуть в \sphinxcode{\sphinxupquote{setup.py}})

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\end{enumerate}


\chapter{Менеджеры служб и планировщики задач}
\label{\detokenize{index:id16}}
\sphinxstepscope


\section{Менеджеры и планировщики}
\label{\detokenize{educational_materials/managers/content:id1}}\label{\detokenize{educational_materials/managers/content::doc}}
\sphinxAtStartPar
В данном уроке речь пойдет о менеджерах и планировщиках заданий. Они используются для того, чтобы запустить программы, которые написаны нами по расписанию (планировщики), и контролировать запуск/перезапуск приложений\sphinxhyphen{}сервисов (менеджеры).


\subsection{Мотивация}
\label{\detokenize{educational_materials/managers/content:id2}}
\sphinxAtStartPar
Бывает множество случаев, когда нам нужно делать что\sphinxhyphen{}то периодически или обеспечить надежную работу приложений. Задачей, которую можно отнести к периодической, является мониторинг состояния жестких дисков, одной из наименее надежных частей компьютера, и отправка информации пользователю компьютера или системному администратору, если есть вероятность поломки. Задачей, которую можно отнести ко второму типу, является запуск приложения в виде сервиса, который должен быть доступен всегда для других приложений или пользователей, и если сервис «упал», менеджер сервисов должен попытаться перезапустить его.

\sphinxAtStartPar
Планировщик задач можно сравнить с тренером на групповой тренировке, он говорит, что делать в определенные моменты времени, но проследить за правильностью выполнения каждым участником тренировки не может. Так, он запустит задачу, но если она завершится с ошибкой, то это будет не зона ответственности планировщика, а зона ответственность разработчика.

\sphinxAtStartPar
Менеджер сервисов больше похож на индивидуального тренер, который заинтересован не только в запуске задач, но и в отслеживании их правильного выполнения. При этом менеджер сервисов не берет на себя  достижение правильного поведения приложения, это по\sphinxhyphen{}прежнему задача разработчика, но менеджер сервисов может предоставить разработчику инструменты для того, чтобы облегчить запуск (например, только после того как мы подключимся к интернету) и поиск ошибок (например, с помощью журнала логов).


\subsection{Планировщик crontab}
\label{\detokenize{educational_materials/managers/content:crontab}}
\sphinxAtStartPar
В качестве примера планировщика мы будем рассматривать \sphinxcode{\sphinxupquote{crontab}}. Crontab — это утилита\sphinxhyphen{}планировщик командной строки в операционных системах Linux, название означает \sphinxcode{\sphinxupquote{cron table}}. Он используется для создания, управления и поддержки списка запланированных задач, известных как \sphinxcode{\sphinxupquote{cron jobs}}. Задания cron — это автоматизированные задачи, которые выполняются через определенные промежутки времени или в определенное время, не требуя ручного вмешательства. Crontab позволяет пользователям планировать выполнение задач в определенные моменты времени, что делает его мощным инструментом для автоматизации повторяющихся или периодических действий в системе Linux.

\sphinxAtStartPar
Ключевые понятия \sphinxcode{\sphinxupquote{crontab}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
cron job — это отдельная задача или команда, выполнение которой запланировано через определенные промежутки времени. Каждое задание cron определяется как отдельная строка в файле crontab, т.е. в таблице заданий \sphinxcode{\sphinxupquote{cron table}}.

\item {} 
\sphinxAtStartPar
расписание — это таблица, которая определяет, когда будет выполняться задание cron. Формат расписания состоит из пяти полей, представляющих минуты, часы, день месяца, месяц и день недели соответственно. Каждое поле использует определенный синтаксис для определения расписания. Пять звездочек в примере ниже представляют расписание для каждой минуты, каждого часа, каждого дня месяца, каждого месяца и каждого дня недели, \sphinxcode{\sphinxupquote{command\_to\_run}} — это задача, который нужно выполнить. Таким образом, \sphinxcode{\sphinxupquote{command\_to\_run}} будет выполняться каждую минуту без исключений.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{n}{command\PYGZus{}to\PYGZus{}run}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
спецификаторы времени. Вместо использования звездочек для всех полей вы можете указать определенные значения или диапазоны для точной настройки расписания. Например:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{n}{job}          \PYG{n}{запускает} \PYG{n}{команду} \PYG{n}{ежедневно} \PYG{n}{в} \PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mf}{00.}
    \PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{n}{job}        \PYG{n}{будет} \PYG{n}{запускать} \PYG{n}{команду} \PYG{n}{каждые} \PYG{n}{пять} \PYG{n}{минут}\PYG{o}{.}
    \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{o}{*} \PYG{n}{job}        \PYG{n}{будет} \PYG{n}{запускать} \PYG{n}{команду} \PYG{n}{каждую} \PYG{n}{минуту} \PYG{n}{пятого} \PYG{n}{числа} \PYG{n}{каждого} \PYG{n}{месяца}\PYG{o}{.}
    \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4} \PYG{n}{job}        \PYG{n}{будет} \PYG{n}{запускать} \PYG{n}{команду} \PYG{n}{каждую} \PYG{n}{минуту} \PYG{n}{в} \PYG{n}{понедельник} \PYG{n}{и} \PYG{n}{четверг}\PYG{o}{.}
    \PYG{l+m+mi}{15} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{n}{job}        \PYG{n}{будет} \PYG{n}{запускать} \PYG{n}{команду} \PYG{n}{в} \PYG{l+m+mi}{15} \PYG{n}{минут} \PYG{n}{каждого} \PYG{n}{часа} \PYG{n}{с} \PYG{l+m+mi}{01}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{по} \PYG{l+m+mi}{05}\PYG{p}{:}\PYG{l+m+mf}{00.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
user\sphinxhyphen{}specific crontab. Каждый пользователь в системе может иметь свой собственный crontab, который управляется независимо. crontab текущего пользователя можно редактировать с помощью команды \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}e}}, выполненной в \sphinxcode{\sphinxupquote{bash}}.

\item {} 
\sphinxAtStartPar
system\sphinxhyphen{}wide crontab. Помимо пользовательских crontab, существует также общесистемный crontab, который позволяет системным администраторам планировать задачи, влияющие на всю систему и всех пользователей.

\end{itemize}

\sphinxAtStartPar
Пользоваться \sphinxcode{\sphinxupquote{crontab}} очень легко, просто наберите в командной строке Linux \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}e}}:

\sphinxAtStartPar
\sphinxincludegraphics{{corntab_e}.png}

\sphinxAtStartPar
После этого откроется расписание задач, которое можно будет поправить как нужно.

\sphinxAtStartPar
\sphinxincludegraphics{{crontab_schedule}.png}

\sphinxAtStartPar
По умолчанию \sphinxcode{\sphinxupquote{crontab}} не будет будет логировать вывод вашего приложения (это не касается того, что вы сами используете внутри кода, например, с помощью loguru). Для того чтобы записать вывод вашего приложения, можно использовать синтаксис, подобный примеру ниже.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{command} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{logfile}\PYG{o}{.}\PYG{n}{log} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
Если мы вспомним урок про \sphinxcode{\sphinxupquote{bash}}, то не найдем ничего нового: \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{} /path/to/logfile.log}} перенаправляет стандартный поток \sphinxcode{\sphinxupquote{stdout}} в файл, а \sphinxcode{\sphinxupquote{2\textgreater{}\&1}} перенаправляет ошибки \sphinxcode{\sphinxupquote{stderr}} в \sphinxcode{\sphinxupquote{stdout}}, таким образом, мы запишем и ошибки, и простые сообщения.

\sphinxAtStartPar
Типичные варианты использования crontab:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Автоматическое резервное копирование: запланируйте регулярное резервное копирование важных данных, чтобы обеспечить безопасность данных и варианты восстановления. Большие программы, скорее всего, будут иметь встроенный механизм для обеспечения резервного копирования, но \sphinxcode{\sphinxupquote{crontab}} — это универсальный способ, который можно использовать для любой задачи, в том числе для своих проектов.

\item {} 
\sphinxAtStartPar
Обслуживание системы: автоматизируйте рутинные задачи по обслуживанию системы, такие как очистка временных файлов, оптимизация баз данных, зеркалирование данных (например, ночью, когда нет нагрузки на сеть со стороны пользователей) и так далее.

\item {} 
\sphinxAtStartPar
Периодические отчеты: создавайте и отправляйте по электронной почте или в чат\sphinxhyphen{}боте периодические отчеты, содержащие информацию о состоянии системы или статистику использования.

\item {} 
\sphinxAtStartPar
Выполнение сценариев по расписанию: запуск пользовательских сценариев через определенные промежутки времени для различных целей.

\end{itemize}


\subsubsection{Практическое применение crontab}
\label{\detokenize{educational_materials/managers/content:id3}}
\sphinxAtStartPar
Рассмотрим скрипт, которые собирает информацию о месте на диске, которое занимает содержимое директории, и сохраняет эту информацию вместе с временем обращения к директории в файл. Настроим \sphinxcode{\sphinxupquote{crontab}} так, чтобы наш скрипт запускался каждые 5 секунд. Мы будем использовать \sphinxcode{\sphinxupquote{bash}} для написания скрипта, но вы можете написать скрипт на любом языке программирования.

\sphinxAtStartPar
Файл скрипта \sphinxcode{\sphinxupquote{collect\_dir\_space.sh}} будет выглядеть следующим образом:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{n+nv}{target\PYGZus{}directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/tmp/monitored\PYGZus{}directory\PYGZdq{}}

\PYG{n+nv}{log\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/tmp/dir\PYGZus{}space.log\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Collect disk space occupied by the target directory}
\PYG{n+nv}{disk\PYGZus{}space}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}du\PYG{+w}{ }\PYGZhy{}sh\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}target\PYGZus{}directory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}

\PYG{n+nv}{current\PYGZus{}date}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}date\PYG{+w}{ }+\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}Y\PYGZhy{}\PYGZpc{}m\PYGZhy{}\PYGZpc{}d \PYGZpc{}H:\PYGZpc{}M:\PYGZpc{}S\PYGZdq{}}\PYG{k}{)}

\PYG{c+c1}{\PYGZsh{} Log the disk space information with the current date}
\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}current\PYGZus{}date}\PYG{l+s+s2}{ \PYGZhy{} Disk Space Usage: }\PYG{n+nv}{\PYGZdl{}disk\PYGZus{}space}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}log\PYGZus{}file}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь нужно создать директорию, которую нужно мониторить, и сделать так, чтобы скрипт можно было запускать.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir\PYG{+w}{ }/tmp/monitored\PYGZus{}directory
sudo\PYG{+w}{ }chmod\PYG{+w}{ }+x\PYG{+w}{ }collect\PYGZus{}dir\PYGZus{}space.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
И добавим следующую строку в \sphinxcode{\sphinxupquote{crontab}}, для этого выполним команду \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}e}} (см. выше на скриншоте).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }*\PYG{+w}{ }*\PYG{+w}{ }*\PYG{+w}{ }*\PYG{+w}{ }/path/to/collect\PYGZus{}dir\PYGZus{}space.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{crontab_job_installed}.png}

\sphinxAtStartPar
И проверим, что все работает:

\sphinxAtStartPar
\sphinxincludegraphics{{crontab_job_works}.png}

\sphinxAtStartPar
Мы видим, что в файл \sphinxcode{\sphinxupquote{/tmp/dir\_space.log}} добавляется информация о дисковом пространстве, занятом файлами в директории. Между вызовами \sphinxcode{\sphinxupquote{cat /tmp/dir\_space.log}} мы скопировали файл \sphinxcode{\sphinxupquote{a.png}}, который занимает пример 282 кБ.


\subsection{Менеджер systemctl}
\label{\detokenize{educational_materials/managers/content:systemctl}}
\sphinxAtStartPar
Мы будем рассматривать \sphinxcode{\sphinxupquote{systemctl}} — это утилита командной строки, используемая в современных дистрибутивах Linux, которые используют систему инициализации \sphinxcode{\sphinxupquote{systemd}} (отвечает за загрузку системы, управление системными службами/демонами, отслеживание состояния системы и обработку отключений системы.). Хотя \sphinxcode{\sphinxupquote{systemd}} и \sphinxcode{\sphinxupquote{systemctl}} связаны, это не одно и тоже. Для целей освоения этого урока можно считать, что \sphinxcode{\sphinxupquote{systemctl}} предоставляет интерфейс \sphinxcode{\sphinxupquote{systemd}}, который уже отвечает за запуск приложений. \sphinxstyleemphasis{Примечание: правильнее было бы назвать менеджером systemd, но так как мы будем использовать его с помощью systemctl, мы позволили себе такую подмену понятий}.

\sphinxAtStartPar
Он обеспечивает контроль над системными службами, демонами и другими модулями, позволяя пользователям управлять состоянием и поведением системы. Systemd — это система инициализации по умолчанию во многих дистрибутивах Linux, заменяющая традиционную систему инициализации SysV.

\sphinxAtStartPar
Ключевым элементом при работе с systemctl является Unit. Unit’ы могут быть нескольких типов: службы, сокеты, таймеры, точки монтирования и другие системные ресурсы. Каждый unit определяется файлом c конфигурацией, который предоставляет информацию о том, как запускать, останавливать, включать, отключать выполняемую команду и как управляется unit. Например, unit может быть постоянно включен и перезагружаться при падении или стартовать по расписанию (похоже на то, как это делает crontab).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Ниже приведен пример конфигурации для службы/сервиса/демона, т.е. приложения, которое работает в фоне. Большинство строк можно понять интуитивно. `Description` описывает то, что делает приложение. `After` описывает зависимость, т.е. от чего зависит текущая служба, в примере ниже, мы ждем, пока не \PYGZdq{}поднимется\PYGZdq{} сеть. `ExecStart` описывает команду/программу, которая будет запущена. `Restart` описывает, когда нам нужно перезапустить службу, если она упала. [WantedBy](https://unix.stackexchange.com/questions/506347/why\PYGZhy{}do\PYGZhy{}most\PYGZhy{}systemd\PYGZhy{}examples\PYGZhy{}contain\PYGZhy{}wantedby\PYGZhy{}multi\PYGZhy{}user\PYGZhy{}target) и [Type](https://superuser.com/questions/1274901/systemd\PYGZhy{}forking\PYGZhy{}vs\PYGZhy{}simple) определяют состояние операционной системы и различные сценарии использования службы, для целей данного урока они не являются принципиальными, но вы можете изучить их самостоятельно.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{            }\PYG{k}{[Unit]}
\PYG{+w}{            }\PYG{n+na}{Description}\PYG{o}{=}\PYG{l+s}{My Application Service}
\PYG{+w}{            }\PYG{n+na}{After}\PYG{o}{=}\PYG{l+s}{network.target}
\PYG{+w}{            }
\PYG{+w}{            }\PYG{k}{[Service]}
\PYG{+w}{            }\PYG{n+na}{Type}\PYG{o}{=}\PYG{l+s}{simple}
\PYG{+w}{            }\PYG{n+na}{ExecStart}\PYG{o}{=}\PYG{l+s}{python /path/to/my\PYGZus{}script.py param1 param2}
\PYG{+w}{            }\PYG{n+na}{Restart}\PYG{o}{=}\PYG{l+s}{always}
\PYG{+w}{            }
\PYG{+w}{            }\PYG{k}{[Install]}
\PYG{+w}{            }\PYG{n+na}{WantedBy}\PYG{o}{=}\PYG{l+s}{multi\PYGZhy{}user.target}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Ниже приведен пример unit timer, который можно считать заменой `crontab`, но более сложной в конфигурировании. Мы создадим сервис с типом `Type=oneshot` что говорит systemd запустить его лишь один раз, и потом создадим таймер, который будет вызывать сервис по расписанию.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
            \PYG{c+c1}{\PYGZsh{} Service that executed once when called; file my\PYGZus{}service.service}
            \PYG{p}{[}\PYG{n}{Unit}\PYG{p}{]}
            \PYG{n}{Description}\PYG{o}{=}\PYG{n}{My} \PYG{n}{Task}
            
            \PYG{p}{[}\PYG{n}{Service}\PYG{p}{]}
            \PYG{n}{Type}\PYG{o}{=}\PYG{n}{oneshot}
            \PYG{n}{ExecStart}\PYG{o}{=}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{your}\PYG{o}{/}\PYG{n}{script}\PYG{o}{.}\PYG{n}{sh}
            
            \PYG{c+c1}{\PYGZsh{} Timer to call service by schedule; file  my\PYGZus{}service.timer}
            \PYG{p}{[}\PYG{n}{Unit}\PYG{p}{]}
            \PYG{n}{Description}\PYG{o}{=}\PYG{n}{Run} \PYG{n}{My} \PYG{n}{Task} \PYG{n}{Daily}
            
            \PYG{p}{[}\PYG{n}{Timer}\PYG{p}{]}
            \PYG{n}{OnCalendar}\PYG{o}{=}\PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{*} \PYG{l+m+mi}{03}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}
            \PYG{n}{Persistent}\PYG{o}{=}\PYG{n}{true}
            
            \PYG{p}{[}\PYG{n}{Install}\PYG{p}{]}
            \PYG{n}{WantedBy}\PYG{o}{=}\PYG{n}{timers}\PYG{o}{.}\PYG{n}{target}
\end{sphinxVerbatim}


\subsubsection{Практическое применение systemctl}
\label{\detokenize{educational_materials/managers/content:id4}}
\sphinxAtStartPar
Еще одним интересным применением systemctl является мониторинг изменения файлов и отправка уведомлений. Ниже приведен пример сервиса, который будет логировать любую попытку изменения файла (также можно отправлять уведомления на почту или в мессенджер). Создадим файл для службы и сохраним его в файл с названием \sphinxcode{\sphinxupquote{pass\_monitor.service}} в домашней директории.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[Unit]}\PYG{+w}{ }
\PYG{n+na}{Description}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Run script to log pass changed\PYGZdq{}}

\PYG{k}{[Service]}
\PYG{n+na}{ExecStart}\PYG{o}{=}\PYG{l+s}{/bin/bash \PYGZhy{}c \PYGZdq{}echo Changed \PYGZgt{}\PYGZgt{} /tmp/pass\PYGZus{}change.log\PYGZdq{}}

\PYG{k}{[Install]}
\PYG{n+na}{WantedBy}\PYG{o}{=}\PYG{l+s}{multi\PYGZhy{}user.target}
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь создадим \sphinxcode{\sphinxupquote{path unit}}, который будет следит за файлом и вызывать наш сервис логирования. Создайте файл \sphinxcode{\sphinxupquote{pass\_monitor.path}} c содержимым.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[Unit]}
\PYG{n+na}{Description}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}Monitor the /tmp/passwd file for changes\PYGZdq{}}

\PYG{k}{[Path]}
\PYG{n+na}{PathModified}\PYG{o}{=}\PYG{l+s}{/tmp/passwd}
\PYG{n+na}{Unit}\PYG{o}{=}\PYG{l+s}{pass\PYGZus{}monitor.service}

\PYG{k}{[Install]}
\PYG{n+na}{WantedBy}\PYG{o}{=}\PYG{l+s}{multi\PYGZhy{}user.target}
\end{sphinxVerbatim}

\sphinxAtStartPar
Активируем unit’ы:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }\PYG{n+nb}{enable}\PYG{+w}{ }/home/artem/pass\PYGZus{}monitor.service
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }\PYG{n+nb}{enable}\PYG{+w}{ }/home/artem/pass\PYGZus{}monitor.path
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }start\PYG{+w}{ }pass\PYGZus{}monitor.path
\end{sphinxVerbatim}

\sphinxAtStartPar
Проверим, что все работает:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }status\PYG{+w}{ }pass\PYGZus{}monitor.service
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }status\PYG{+w}{ }pass\PYGZus{}monitor.path
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{service_unit_status}.png}
\sphinxincludegraphics{{path_unit_status}.png}

\sphinxAtStartPar
Убедимся, что все работает как задумано:

\sphinxAtStartPar
\sphinxincludegraphics{{pass_change_log}.png}

\sphinxAtStartPar
Как мы видим из примера выше, даже при использовании Unit другого типа (Path, как в примере) нам все равно нужно создать Unit service, который будет управляться Unit’ом другого типа. Мы указывали его как \sphinxcode{\sphinxupquote{Unit=pass\_monitor.service}}.

\sphinxAtStartPar
С помощью systemctl вы можете запускать (\sphinxcode{\sphinxupquote{start}}), останавливать (\sphinxcode{\sphinxupquote{stop}}), перезапускать (\sphinxcode{\sphinxupquote{restart}}), перезагружать (\sphinxcode{\sphinxupquote{reload}}), включать (\sphinxcode{\sphinxupquote{enable}}), отключать (\sphinxcode{\sphinxupquote{disable}}) и проверять состояние (\sphinxcode{\sphinxupquote{status}}).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{enable}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl enable my\sphinxhyphen{}service}} используется для включения Unit. Можно рассматривать enable как функцию, которая регистрирует написанный нами Unit для systemd и включает автоматический запуск при загрузке или при выполнении условий его активации. После выполнения этой команды сервис можно запускать по имени без указания полного пути. Эта команда создает символическую ссылку на конфигурационный файл.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{disable}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl disable my\sphinxhyphen{}service}} используется для отключения Unit’а, предотвращая его автоматический запуск при загрузке или при выполнении условий его активации. Она удаляет символическую ссылку на Unit.

\item {} 
\sphinxAtStartPar
\textasciigrave{}\textasciigrave{}. Команда \sphinxcode{\sphinxupquote{sudo systemctl start my\sphinxhyphen{}service}} запускает работу Unit’а \sphinxcode{\sphinxupquote{my\sphinxhyphen{}service}}. Можно считать, что эта команда используется для ручного запуска Unit’а, например, для проверки работы или после устранения ошибки, которая не дает сервису работать в штатном режиме.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stop}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl stop my\sphinxhyphen{}service}} прекращает работу Unit’а \sphinxcode{\sphinxupquote{my\sphinxhyphen{}service}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restart}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl restrat my\sphinxhyphen{}service}} прекращает и запускает работу Unit’а \sphinxcode{\sphinxupquote{my\sphinxhyphen{}service}} заново.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reload}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl reload my\sphinxhyphen{}service}} используется для перезагрузки конфигурации работающего Unit’а без его остановки. Часто используется, когда службе необходимо принять изменения, внесенные в ее файл конфигурации, без полного перезапуска.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{status}}. Команда \sphinxcode{\sphinxupquote{sudo systemctl status my\sphinxhyphen{}service}} предоставляет информацию о текущем состоянии Unit’а, например, работает служба, или она неактивна, сообщения об ошибках и время последнего запуска.

\end{itemize}

\sphinxAtStartPar
Также удобным инструментом для отслеживания работы службы, в том числе в режиме реального времени, является \sphinxcode{\sphinxupquote{journalctl}}. Его можно использовать как журнал событий, связанных с работой вашего приложения. При этом это универсальный инструмент для систем Linux, который не связан с определенным языком программирования. Он обладает не таким широким функционалом, и его вывод не оптимизирован под конкретный язык, как специализированные библиотеки, его использование в некоторых случаях может быть удобнее.

\sphinxAtStartPar
\sphinxincludegraphics{{journalctl}.png}

\sphinxstepscope


\section{Задачи}
\label{\detokenize{educational_materials/managers/exercises:id1}}\label{\detokenize{educational_materials/managers/exercises::doc}}

\subsection{Задача 1}
\label{\detokenize{educational_materials/managers/exercises:id2}}
\sphinxAtStartPar
Напишите расписание cron, которое позволит запускать задачу:
\begin{itemize}
\item {} 
\sphinxAtStartPar
в 8:30 каждый понедельник.

\item {} 
\sphinxAtStartPar
в 12:00 каждый понедельник, среду и пятницу.

\item {} 
\sphinxAtStartPar
в 15 минут каждого часа в 00:00, 06:00, 12:00 и 18:00.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{30} \PYG{l+m+mi}{8} \PYG{o}{*} \PYG{o}{*} \PYG{l+m+mi}{1}              \PYG{n}{в} \PYG{l+m+mi}{8}\PYG{p}{:}\PYG{l+m+mi}{30} \PYG{n}{каждый} \PYG{n}{понедельник}\PYG{o}{.}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{12} \PYG{o}{*} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}          \PYG{n}{в} \PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{каждый} \PYG{n}{понедельник}\PYG{p}{,} \PYG{n}{среду} \PYG{n}{и} \PYG{n}{пятницу}\PYG{o}{.}
\PYG{l+m+mi}{15} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{18} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}      \PYG{n}{в} \PYG{l+m+mi}{15} \PYG{n}{минут} \PYG{n}{каждого} \PYG{n}{часа} \PYG{n}{в} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{,} \PYG{l+m+mi}{06}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{и} \PYG{l+m+mi}{18}\PYG{p}{:}\PYG{l+m+mf}{00.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
каждые 10 минут в течение часа.

\item {} 
\sphinxAtStartPar
в начале каждого часа с 9:00 до 17:00 с понедельника по пятницу.

\item {} 
\sphinxAtStartPar
в 30 минут каждого часа с 1:00 до 5:00 и с 12:00 до 15:00.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}            \PYG{n}{каждые} \PYG{l+m+mi}{10} \PYG{n}{минут} \PYG{n}{в} \PYG{n}{течение} \PYG{n}{часа}\PYG{o}{.}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{9}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{17} \PYG{o}{*} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}          \PYG{n}{в} \PYG{n}{начале} \PYG{n}{каждого} \PYG{n}{часа} \PYG{n}{с} \PYG{l+m+mi}{9}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{до} \PYG{l+m+mi}{17}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{с} \PYG{n}{понедельника} \PYG{n}{по} \PYG{n}{пятницу}\PYG{o}{.}
\PYG{l+m+mi}{30} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}      \PYG{n}{в} \PYG{l+m+mi}{30} \PYG{n}{минут} \PYG{n}{каждого} \PYG{n}{часа} \PYG{n}{с} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{до} \PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{и} \PYG{n}{с} \PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{до} \PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mf}{00.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
каждые 2 минуты.

\item {} 
\sphinxAtStartPar
каждые 3 минуты с 10:00 до 18:00.

\item {} 
\sphinxAtStartPar
каждые 10 минут в полночь (0:00) по понедельникам.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}             \PYG{n}{каждые} \PYG{l+m+mi}{2} \PYG{n}{минуты}\PYG{o}{.} 
\PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{18} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*}         \PYG{n}{каждые} \PYG{l+m+mi}{3} \PYG{n}{минуты} \PYG{n}{с} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00} \PYG{n}{до} \PYG{l+m+mi}{18}\PYG{p}{:}\PYG{l+m+mf}{00.}
\PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{10} \PYG{l+m+mi}{0} \PYG{o}{*} \PYG{o}{*} \PYG{l+m+mi}{1}            \PYG{n}{каждые} \PYG{l+m+mi}{10} \PYG{n}{минут} \PYG{n}{в} \PYG{n}{полночь} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{)} \PYG{n}{по} \PYG{n}{понедельникам}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Задача 2}
\label{\detokenize{educational_materials/managers/exercises:id3}}
\sphinxAtStartPar
Создайте скрипт и соответствующие unit’ы systemctl для следующей задачи: нужно отследить изменения в файле, и если он содержит подстроку «critical error», отправить сообщение пользователю.

\sphinxAtStartPar
\sphinxstylestrong{Ответ}

\sphinxAtStartPar
Скрипт для проверки \sphinxcode{\sphinxupquote{check\_script.sh}}.

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{n+nv}{file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/path/to/watched/file\PYGZdq{}}
\PYG{n+nv}{substring}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}critical error\PYGZdq{}}

\PYG{k}{if}\PYG{+w}{ }grep\PYG{+w}{ }\PYGZhy{}q\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}substring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}file}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{ }\PYG{k}{then}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Found critical error in }\PYG{n+nv}{\PYGZdl{}file}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{+w}{    }\PYG{c+c1}{\PYGZsh{} Add your notification command here, e.g., sendmail or notify\PYGZhy{}send}
\PYG{k}{else}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{No critical error found in }\PYG{n+nv}{\PYGZdl{}file}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{fi}
\end{sphinxVerbatim}

\sphinxAtStartPar
Конфигурация для Unit service \sphinxcode{\sphinxupquote{check\_critical.service}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[Unit]}
\PYG{n+na}{Description}\PYG{o}{=}\PYG{l+s}{Check File for Critical Error}

\PYG{k}{[Service]}
\PYG{n+na}{Type}\PYG{o}{=}\PYG{l+s}{simple}
\PYG{n+na}{ExecStart}\PYG{o}{=}\PYG{l+s}{/path/to/your/check\PYGZus{}script.sh}
\end{sphinxVerbatim}

\sphinxAtStartPar
Конфигурация для Unit path \sphinxcode{\sphinxupquote{check\_critical.path}}:

\sphinxAtStartPar
(\DUrole{xref,download,myst}{код}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[Unit]}
\PYG{n+na}{Description}\PYG{o}{=}\PYG{l+s}{Watch My File}

\PYG{k}{[Path]}
\PYG{n+na}{PathModified}\PYG{o}{=}\PYG{l+s}{/path/to/watched/file}
\PYG{n+na}{Unit}\PYG{o}{=}\PYG{l+s}{check\PYGZus{}critical.service}

\PYG{k}{[Install]}
\PYG{n+na}{WantedBy}\PYG{o}{=}\PYG{l+s}{multi\PYGZhy{}user.target}
\end{sphinxVerbatim}

\sphinxAtStartPar
Код для активации сервиса:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }chmod\PYG{+w}{ }+x\PYG{+w}{ }check\PYGZus{}script.sh
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }\PYG{n+nb}{enable}\PYG{+w}{ }/path/to/check\PYGZus{}critical.service
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }\PYG{n+nb}{enable}\PYG{+w}{ }/path/to/check\PYGZus{}critical.service
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }start\PYG{+w}{ }pass\PYGZus{}monitor.path
\end{sphinxVerbatim}

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/managers/quiz:id1}}\label{\detokenize{educational_materials/managers/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Какова цель команды \sphinxcode{\sphinxupquote{systemctl start}}?
а) Чтобы служба (Unit) запускалась автоматически при загрузке.
б) Для ручного запуска определенной службы.
в) Перезагрузить конфигурацию работающей служба.
г) Остановить работающую службу.

\item {} 
\sphinxAtStartPar
Какая команда перезапустит работающий модуль, выполнив остановку и запуск?
а) systemctl stop
б) systemctl reload
в) systemctl restart
г) systemctl enable

\item {} 
\sphinxAtStartPar
Что показывает команда systemctl status?
а) Подробную информацию о конфигурации конкретной службы (Unit).
б) Список всех загруженных служб и их текущий статус.
в) Время последнего запуска службы.
г) Журнал логов службы.

\item {} 
\sphinxAtStartPar
Какую команду следует использовать, чтобы включить службу так, чтобы она (служба) автоматически запускалась при загрузке системы?
а) systemctl start
б) systemctl enable
в) systemctl enable \textendash{}now
г) systemctl enable \textendash{}start

\item {} 
\sphinxAtStartPar
Какова цель команды \sphinxcode{\sphinxupquote{systemctl list\sphinxhyphen{}units}}?
а) Включить службу.
б) Отобразить подробную информацию о конкретном блоке.
в) Перечислить все загруженные службы вместе с их текущим статусом и описанием.
г) Перезагрузить конфигурацию работающей службы.

\item {} 
\sphinxAtStartPar
Какая команда отключит устройство, предотвращая его автоматический запуск при загрузке?
а) systemctl disable
б) systemctl stop
в) systemctl disable \textendash{}now
г) systemctl stop \textendash{}disable

\item {} 
\sphinxAtStartPar
Для чего используется \sphinxcode{\sphinxupquote{crontab}} в системах Linux?
а) Управление системными демонами и службами.
б) Автоматизация запуска задач в определенное время или через определенные промежутки времени.
в) Управление сетевыми настройками системы.
г) Установка программных пакетов.

\item {} 
\sphinxAtStartPar
Как вы редактируете расписание запуска задач \sphinxcode{\sphinxupquote{crontab}} для текущего пользователя?
а) crontab \sphinxhyphen{}l
б) crontab \sphinxhyphen{}e
в) crontab \sphinxhyphen{}r
г) crontab \sphinxhyphen{}n

\item {} 
\sphinxAtStartPar
Какая запись \sphinxcode{\sphinxupquote{crontab}} назначает выполнение задачи каждое воскресенье в 14:30?
а) \sphinxcode{\sphinxupquote{30 2 * * 0}}
б) \sphinxcode{\sphinxupquote{30 14 * * 7}}
в) \sphinxcode{\sphinxupquote{2 30 * * 7}}
г) \sphinxcode{\sphinxupquote{14 30 * * 0}}

\item {} 
\sphinxAtStartPar
Что означает символ \sphinxcode{\sphinxupquote{*}} в записи \sphinxcode{\sphinxupquote{crontab}}?
а) Текущий рабочий каталог.
б) Корневой каталог.
в) Любое значение для определенного поля.
г) Предыдущий рабочий каталог.

\item {} 
\sphinxAtStartPar
Как бы вы перечислили все существующие записи \sphinxcode{\sphinxupquote{crontab}} для текущего пользователя?
а) crontab \sphinxhyphen{}l
б) crontab \sphinxhyphen{}e
в) crontab \sphinxhyphen{}r
г) crontab \sphinxhyphen{}n

\item {} 
\sphinxAtStartPar
Какую команду следует использовать, чтобы удалить все записи \sphinxcode{\sphinxupquote{crontab}} для текущего пользователя?
а) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}l}}
б) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}e}}
в) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}r}}
г) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}n}}

\item {} 
\sphinxAtStartPar
Какая строка расписания \sphinxcode{\sphinxupquote{cron}} будет запускать скрипт каждые 10 минут?
а) \sphinxcode{\sphinxupquote{*/10 * * * *}}
б) \sphinxcode{\sphinxupquote{10 * * * *}}
в) \sphinxcode{\sphinxupquote{0\sphinxhyphen{}59/10 * * * *}}
г) \sphinxcode{\sphinxupquote{0/10 * * * *}}

\item {} 
\sphinxAtStartPar
Какова максимальная степень детализации временных интервалов, которую можно установить в \sphinxcode{\sphinxupquote{crontab}}?
а) 1 минута
б) 1 секунда
в) 1 час
г) 1 день

\item {} 
\sphinxAtStartPar
Как указать \sphinxcode{\sphinxupquote{crontab}} конкретного пользователя (user) для редактирования, если у вас есть необходимые разрешения?
а) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}u user}}
б) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}l user}}
в) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}e user}}
г) \sphinxcode{\sphinxupquote{crontab \sphinxhyphen{}r user}}

\item {} 
\sphinxAtStartPar
Какая запись \sphinxcode{\sphinxupquote{crontab}} запускает сценарий в 00:15 1 января и 1 июля каждого года?
а) \sphinxcode{\sphinxupquote{15 0 1 1,7 *}}
б) \sphinxcode{\sphinxupquote{0 15 1 1,7 *}}
в) \sphinxcode{\sphinxupquote{15 0 1 7 *}}
г) \sphinxcode{\sphinxupquote{0 12 1 1,7 *}}

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Ответы}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\item {} 
\sphinxAtStartPar
б)

\item {} 
\sphinxAtStartPar
в)

\item {} 
\sphinxAtStartPar
а)

\end{enumerate}


\chapter{Контейнерезация с Docker}
\label{\detokenize{index:docker}}
\sphinxstepscope


\section{Контейнеризация на примере Docker}
\label{\detokenize{educational_materials/docker_base/content:docker}}\label{\detokenize{educational_materials/docker_base/content::doc}}

\subsection{Введение}
\label{\detokenize{educational_materials/docker_base/content:id1}}
\sphinxAtStartPar
С появлением персональных компьютеров, разработка программного обеспечения (ПО) стала более доступной, однако с появлением новых возможностей также возрастали и потребности. Приложения становились все сложнее, а машины \textendash{} мощнее. Тем не менее, возникал вопрос о ресурсоемкости исполнения приложений и изоляции зависимостей. Первым решением стало появление и развитие виртуальных машин (Virtual machine, VM). Они позволяли создавать изолированные окружения на одной физической машине выделив ресурсы для VM. Это был большой шаг для упрощения разработки ПО и гибкому управлению ресурсов. Использование виртуальных машин позволило выполнять запуск нескольких операционных систем (ОС) на мощностях одного ПК. Это решало многие проблемы, но и создавало новые \textendash{} виртуализация требовала больших ресурсов и замедляла производительность. С ростом сложности и разнообразия современных приложений, стало ясно, что использование только виртуальных машин не всегда оптимально. Они потребляют много ресурсов, так как каждая из них включает полноценную ОС и дополнительные ресурсы для виртуализации. Это может привести к избыточным затратам ресурсов и низкой плотности приложений на серверах.

\sphinxAtStartPar
Так и началось развитие контейнеризации. Вместо виртуальных машин, контейнеры используют общую ОС ПК и разделяют только необходимые ресурсы и библиотеки. Это позволяет достичь более высокой плотности приложений на серверах, экономить ресурсы и ускорять развертывание. Однако контейнеры также сталкиваются с некоторыми ограничениями, например, они могут иметь ограниченный доступ к ресурсам хоста.

\sphinxAtStartPar
С появлением виртуализации, идея контейнеризации была вполне логичной эволюцией, так и появился Docker. Контейнеры позволяют упаковать приложение и его зависимости в изолированный и легкий для перемещения образ, который может быть запущен на любом ПК с Docker. Это значит, что разработчики больше не зависят от окружения, на котором запускается приложение \textendash{} оно будет работать одинаково везде потребляя на порядок меньше ресурсов, чем VM. Однако с появлением множества контейнеров возник вопрос управления ими. В этот момент появляется кластеризация \textendash{} способ управления сетью из множества контейнеров. Это стало ответом на потребность в гибкости, масштабируемости и автоматизации управления развертыванием приложений.

\sphinxAtStartPar
Таким образом, процесс разработки ПО постепенно эволюционировал от огромных машин и долгих циклов разработки к легковесным контейнерам. Это открыло новые горизонты для разработчиков, позволив им создавать, тестировать и масштабировать приложения гораздо эффективнее и быстрее, а также отвечать на постоянно изменяющиеся требования технологических решений.

\sphinxAtStartPar
Во многом это привело к тому, что нас сегодняшний день Docker используют как одного из основных инструментов для организации микросервисной архитектуры, где приложение разбивается на небольшие, независимые контейнеры, каждый из которых отвечает за определенную функциональность. Таким образом, появление Docker и его развитие играет значимую роль разработке ПО и способствовало развитию современных методологий позволивших повысить эффективность разработки.
\begin{quote}

\sphinxAtStartPar
С появлением Docker в 2013 году контейнеризация стала гораздо более доступной и удобной. Docker предоставил унифицированный способ упаковки приложений и их зависимостей в контейнеры, которые могут быть развернуты на любой поддерживаемой платформе. Это позволило разработчикам и инженерам работать с одинаковой средой в разных этапах жизненного цикла приложения, от разработки до развертывания. Крупные компании, такие как Yandex, Sber, Google, Amazon, Microsoft, Netflix и другие, успешно используют Docker для разработки своих продуктов и сервисов.
\end{quote}


\subsection{Рассмотрим пример: как Docker может помочь в разработке ПО}
\label{\detokenize{educational_materials/docker_base/content:id2}}
\sphinxAtStartPar
Представим ситуацию, вы разрабатываете программный модуль, который должен облегчить использование QR\sphinxhyphen{}кодов в чат\sphinxhyphen{}ботах. В качестве языка программирования вы выбрали Python. Спустя некоторое время ваш проект готов, вы провели тесты, и всё работает как часы и вы публикуете его в открытом репозитории, например в GitHub. Но, вскоре вы получаете сообщения от первых пользователей, которые столкнулись с проблемой: их чат\sphinxhyphen{}бот исправно работал на одном сервере, но неожиданно переставал функционировать на других. Оказалось, что источник проблем был некоторых различиях рабочего окружения. В одном случае проблема была в конфигурации операционной системы на VPS. В других случаях — ошибки в зависимостях некоторых модулей Python и различия в версиях используемых библиотек. Что в совокупности приводило к появлению ошибок в процессе функционирования чат\sphinxhyphen{}ботов использующих ваш программный модуль. Такие проблемы совместимости программных пакетов сложно отлавливать в процессе разработки.

\sphinxAtStartPar
Использование Docker может значительно упростить и решить проблему совместимости, с которой вы столкнулись при развертывании вашего программного модуля для работы с QR\sphinxhyphen{}кодами. Вот как вы можете это сделать. Рассмотрим вариант решение данной проблемы используя Docker:

\sphinxAtStartPar
Создадим новый Docker\sphinxhyphen{}образ, в котором будет все, что нужно для работы приложения — код, библиотеки, переменные окружения. Также, в нем будет запускаться ваш экземпляр чат\sphinxhyphen{}бота. Docker обеспечит изоляцию окружения, что позволит вам управлять зависимостями, конфигурацией операционной системы и версиями библиотек внутри контейнера. Затем можно опубликовать Docker\sphinxhyphen{}образ в реестре Docker Hub или на другой подобной платформе. Что позволит другим пользователям легко получить и использовать ваш образ. Пользователи могут легко развернуть ваш Docker\sphinxhyphen{}образ на своих серверах. Образ будет запущен в изолированном контейнере, и все зависимости будут корректно настроены, таким образом, устраняя проблемы совместимости. Так, используя Docker, вы можете унифицировать окружение и избежать проблем совместимости вашего проекта с различными серверами и системами, а также облегчите развертывание и обновление вашего программного модуля.

\sphinxAtStartPar
Как можно подытожить эту историю. Если упростить, то Docker\sphinxhyphen{}образ похож на «компьютер», который может запустить код приложения находящийся в нем. И где бы мы не включили этот «компьютер», в офисе, дома, у заказчиков или у друзей \sphinxhyphen{} он всегда будет работать одинаково. Если ваше приложение использует компоненты операционной системы (ОС), вы можете её установить. Как правило, это Linux.
\begin{quote}

\sphinxAtStartPar
Примечание: В Docker отсутствует поддержка установки в Docker\sphinxhyphen{}образ ОС семейства Windows, и как следствие приложений под эту ОС.
\end{quote}


\subsubsection{Образ и контейнер в Docker}
\label{\detokenize{educational_materials/docker_base/content:id3}}
\sphinxAtStartPar
Выше мы уже говорили об «образах». Что это такое? Хороший вопрос. То, что в терминологии Docker называется «образом», можно сравнить с чертежами, классом из ООП, или с пресс\sphinxhyphen{}формой для чеканки монет. В Docker «контейнер» и «образ» — это две разные вещи  разными целями.

\sphinxAtStartPar
Docker образ — это шаблон, определяющий приложение и его зависимости. Это схема или снимок приложения, доступный только для чтения, который можно использовать для создания контейнеров Docker. Образ создается путем запуска файла Dockerfile, в котором указывается используемый базовый образ, любые зависимости, которые необходимо установить, а также любая пользовательская конфигурация или код. После создания образа его можно распространять и делиться с другими.

\sphinxAtStartPar
Docker контейнер — это работающий экземпляр образа. Его можно рассматривать как легкий автономный исполняемый пакет, включающий все необходимое для запуска приложения, в том числе программный код, среду выполнения, системные инструменты, библиотеки и настройки. Когда контейнер запускается, в верхнюю часть образа добавляется новый доступный для записи слой, позволяющий вносить изменения в работающее приложение.

\sphinxAtStartPar
Несколько контейнеров могут быть созданы из одного и того же образа, каждый со своим отдельным записываемым слоем. Проще говоря, образ — это статический файл, который включает в себя все необходимое для запуска приложения, а контейнер — это работающий экземпляр образа, который можно изменять и с которым можно взаимодействовать.

\sphinxAtStartPar
Давайте разберемся, в чем отличие образа и контейнера. Если сказать в двух словах, то Docker контейнер — это запущенный (активный) образ. Образ в свою очередь — это то, что представляет собой функциональную часть одной или нескольких программ, скриптов, данных и т.д., то, что будет выполняться при запуске образа в контейнере. Образы достаточно просто создаются инструментами Docker. На базовом уровне контейнер представляет собой набор инструкций, который выполняется на некоем процессоре, обрабатывая какие\sphinxhyphen{}то данные.

\sphinxAtStartPar
\sphinxstylestrong{Знакомство с Docker: контейнеры и образы:}

\sphinxAtStartPar
Docker \sphinxhyphen{} это платформа для разработки, доставки и запуска приложений в контейнерах. Контейнеры \sphinxhyphen{} это изолированные среды, которые объединяют приложение и его зависимости, обеспечивая портативность однообразие в разных окружениях. Образы \sphinxhyphen{} это шаблоны для создания контейнеров, содержащие все необходимое для работы приложения. За счет контейнеров и образов Docker упрощает разработку, развертывание и масштабирование приложений.

\sphinxAtStartPar
Основные компоненты Docker:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Engine:} Это основной компонент Docker, который управляет контейнерами и образами. Docker Engine включает в себя Docker Daemon (серверная часть) и Docker CLI (командная строка). Docker Daemon управляет жизненным циклом контейнеров, созданием, запуском и остановкой, а Docker CLI позволяет разработчикам взаимодействовать с Docker Engine с помощью команд.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Images:} Образы Docker \sphinxhyphen{} это основа контейнеров. Они содержат файловую систему, зависимости и настройки приложения. Образы создаются на основе Dockerfile \sphinxhyphen{} текстового файла, который описывает, как создать образ. Образы могут быть сохранены в реестре, таком как Docker Hub или частном реестре, и используются для развертывания контейнеров.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Containers:} Контейнеры \sphinxhyphen{} это экземпляры образов. Каждый контейнер изолирован от других контейнеров и имеет свою собственную файловую систему, зависимости и окружение. Они используют технологии Linux\sphinxhyphen{}контейнеров для обеспечения изоляции, но все же разделяют ядро операционной системы хоста.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Compose:} Этот инструмент позволяет определить и управлять множеством связанных контейнеров в единой конфигурации. С Docker Compose вы можете описать все контейнеры, сети, тома и настройки в файле docker\sphinxhyphen{}compose.yml, что упрощает развертывание и управление многоконтейнерными приложениями.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Swarm:} Docker Swarm \sphinxhyphen{} это инструмент для создания и управления кластерами Docker, позволяющим распределить приложение на несколько узлов (хостов) и обеспечить высокую доступность и масштабируемость.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Docker Hub:} Docker Hub \sphinxhyphen{} это облачный реестр образов Docker, где разработчики могут сохранять и делиться своими образами. Это упрощает распространение приложений и обмен образами между разработчиками.

\end{enumerate}

\sphinxAtStartPar
Все эти компоненты взаимодействуют, чтобы предоставить разработчикам среду для создания, развертывания и управления контейнерами. Docker позволяет упаковать приложения и все их зависимости в контейнеры, что облегчает портирование и запуск приложений на разных окружениях, повышает скорость разработки и обеспечивает изоляцию между приложениями.


\subsection{Концепции Docker}
\label{\detokenize{educational_materials/docker_base/content:id4}}
\sphinxAtStartPar
Несколько контейнеров могут объединяться в сеть и совместно выполнять свою задачу. Например, Контейнер №1 содержит код приложения: Linux, Python, Flask, SQLAlchemy. Контейнер №2 содержит базу данных и выполняет обработку внешних запросов к данным, находящимся в базе данных. Контейнер №3 выполняет мониторинг и анализ данных, формирует отчетность на основе данных из базы данных в контейнере №2 и предоставляет пользователям контейнера №1. Таким образом, каждый контейнер решает отдельную задачу. Физически контейнеры могут находиться в разных помещениях, городах и даже странах. Это и есть возможность масштабирования приложений.


\subsection{Установка и использование}
\label{\detokenize{educational_materials/docker_base/content:id5}}
\sphinxAtStartPar
Установка и настройка Docker \sphinxhyphen{} это первый шаг в изучении контейнеризации и использовании Docker для разработки и развертывания приложений. Этот процесс обеспечивает удобный способ управления окружением и приложениями, что делает Docker популярным инструментом среди разработчиков и операционных команд.


\subsubsection{Установка Докера в Windows}
\label{\detokenize{educational_materials/docker_base/content:windows}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Перейдите на веб\sphinxhyphen{}сайт Docker и загрузите установщик Docker Desktop для Windows.

\item {} 
\sphinxAtStartPar
Запустите программу установки и следуйте инструкциям для завершения установки.

\item {} 
\sphinxAtStartPar
После установки Docker Desktop должен запуститься автоматически. Если это не так, вы можете запустить его из меню «Пуск».

\item {} 
\sphinxAtStartPar
После запуска Docker Desktop вы можете использовать его для создания и запуска контейнеров Docker.

\end{enumerate}


\subsubsection{Установка Докера в Linux}
\label{\detokenize{educational_materials/docker_base/content:linux}}
\sphinxAtStartPar
Точные шаги по установке Docker в Linux зависят от используемого вами дистрибутива. Вот
основные шаги для Ubuntu:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Откройте терминал и выполните следующую команду, чтобы установить зависимости Docker:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo apt\sphinxhyphen{}get update}}}
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo apt\sphinxhyphen{}get install apt\sphinxhyphen{}transport\sphinxhyphen{}https ca\sphinxhyphen{}certificates curl software\sphinxhyphen{}properties\sphinxhyphen{}common}}}

\item {} 
\sphinxAtStartPar
Добавьте ключ Docker GPG в свою систему:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{curl \sphinxhyphen{}fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt\sphinxhyphen{}key add \sphinxhyphen{}}}}

\item {} 
\sphinxAtStartPar
Добавьте репозиторий Docker в ваши источники APT:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo add\sphinxhyphen{}apt\sphinxhyphen{}repository " deb {[}arch=amd64{]} https://download.docker.com/linux/ubuntu \$ (lsb\_release \sphinxhyphen{}cs) stable "}}}

\item {} 
\sphinxAtStartPar
Обновите индекс пакета APT и установите Docker:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo apt\sphinxhyphen{}get update}}}
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo apt\sphinxhyphen{}get install docker\sphinxhyphen{}ce}}}

\item {} 
\sphinxAtStartPar
После установки Docker должен быть запущен в вашей системе. Вы можете проверить это, выполнив следующую команду:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{sudo docker run hello\sphinxhyphen{}world}}}

\end{enumerate}

\sphinxAtStartPar
Это загрузит тестовый образ Docker и запустит его в контейнере. Это основной процесс установки Docker в Linux. Точные шаги могут различаться в зависимости от используемого дистрибутива и версии. Здесь мы исходим из предположения, в соответствии с которым используется образ Docker, основанный на Unix\sphinxhyphen{}подобной ОС. Конечно, тут можно воспользоваться и образом, основанным на Windows, но использование Windows — это менее распространенная практика, работать с такими образами сложнее. В результате, если у вас есть такая возможность, рекомендуем использовать Unix. Однако для выполнения практических примеров можно использовать любую ОС, поскольку мы будем использовать только базовые команды Docker в консольном режиме.


\subsubsection{Быстрый Старт}
\label{\detokenize{educational_materials/docker_base/content:id6}}
\sphinxAtStartPar
Чтобы запустить контейнер Docker, вы можете выполнить следующие общие шаги:

\sphinxAtStartPar
Извлеките образ Docker. Если вы еще этого не сделали, вам потребуется извлечь образ Docker, который вы хотите запустить, из реестра Docker, такого как Docker Hub. Вы можете сделать это с помощью команды \sphinxstylestrong{\sphinxcode{\sphinxupquote{docker pull}}}, за которой следует имя и тег образа.
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker pull \textless{}image\sphinxhyphen{}name\textgreater{}:\textless{}tag\textgreater{}}}}
Например, чтобы получить официальный образ nginx, вы можете использовать:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker pull nginx:latest}}}
Запустите контейнер Docker: получив образ, вы можете запустить контейнер, выполнив команду запуска docker, за которой следует имя образа и любые дополнительные параметры, которые вы хотите указать.
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker run {[}OPTIONS{]} \textless{}image\sphinxhyphen{}name\textgreater{}}}}
Например, чтобы запустить контейнер из образа nginx, вы можете использовать:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker run \sphinxhyphen{}p 8080:80 nginx:latest}}}
В результате выполнения этой команды у нас запустится контейнер с образом nginx. Следует отметить, что мы указали параметр {[}\sphinxhyphen{}p 8080:80{]} для предоставления доступа внешних приложений к нашему запущенному контейнеру, используя порт 8080. Чтобы в этом убедиться, откроем браузер и введем следующий адрес: (http://localhost:8080/). Нам откроется приветственная HTML страница nginx, сообщающая о том, что веб\sphinxhyphen{}сервер nginx успешно запустился. В данном случае мы указали порт 8080 для того, чтобы достучаться до 80 порта внутри нашего контейнера, это очень полезный параметр. Ведь если нам потребуется запустить несколько контейнеров, внутри которых используется стандартный порт, например, 80, то мы не сможем использовать его для отдельного обращения к каждому контейнеру. Эта команда запускает новый контейнер из образа \sphinxcode{\sphinxupquote{nginx:latest}} и сопоставляет порт 80 в контейнере с портом 8080 на хост\sphinxhyphen{}компьютере. Параметр \sphinxcode{\sphinxupquote{\sphinxhyphen{}p}} указывает сопоставление портов. Убедитесь, что контейнер работает, для этого вы можете использовать команду \sphinxcode{\sphinxupquote{docker ps}}.


\paragraph{docker ps}
\label{\detokenize{educational_materials/docker_base/content:docker-ps}}
\sphinxAtStartPar
Эта команда выводит список всех запущенных контейнеров. Если вы не видите свой контейнер в списке, обязательно используйте команду \sphinxcode{\sphinxupquote{docker ps \sphinxhyphen{}a}}, чтобы увидеть все контейнеры (включая остановленные). Чтобы остановить работающий контейнер, вы можете использовать команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{docker stop}}}, за которой следует идентификатор или имя контейнера.
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker stop \textless{}container\sphinxhyphen{}id\textgreater{}}}}
Например, чтобы остановить контейнер с идентификатором \sphinxcode{\sphinxupquote{abc123}}, вы можете использовать:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker stop abc123}}}
Это основные шаги для запуска контейнера Docker. Вы можете найти более расширенное использование Docker с дополнительными параметрами и конфигурациями в документации Docker.


\paragraph{docker run}
\label{\detokenize{educational_materials/docker_base/content:docker-run}}
\sphinxAtStartPar
Команда \sphinxstylestrong{\sphinxcode{\sphinxupquote{docker run}}} имеет ряд опций, которые можно использовать для настройки поведения контейнера во время выполнения. Вот некоторые из наиболее часто используемых
опций:
\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} или \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}detach}}: Запуск контейнера в фоновом режиме (режим отсоединения).
\sphinxcode{\sphinxupquote{\sphinxhyphen{}p}} или \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}publish}}: Публиковать порт(ы) контейнера на хост\sphinxhyphen{}машине.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}v}} или \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}volume}}: Смонтировать каталог хоста в качестве тома данных в контейнере.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} или \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}env}}: Установить переменные окружения для контейнера.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}name}}: Присвоить имя контейнеру.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}restart}}: Задать политику перезапуска для контейнера.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}it}} или \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}interactive}} и \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}tty}}: Запустить интерактивный сеанс с контейнером и выделить
псевдо\sphinxhyphen{}TTY.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}rm}}: Автоматически удалять контейнер при выходе из него.
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}network}}: Подключить контейнер к сети.


\subsection{Файл Dockerfile}
\label{\detokenize{educational_materials/docker_base/content:dockerfile}}
\sphinxAtStartPar
Dockerfile \textendash{} это текстовый файл, который содержит набор инструкций для автоматической сборки Docker\sphinxhyphen{}образа. Этот файл описывает, какие базовые образы использовать, как установить зависимости, куда и какие файлы копировать и как настроить рабочее окружение внутри контейнера. Dockerfile служит для создания образов \textendash{} снимков файловой системы и настроек, необходимых для работы приложения. Он автоматизирует процесс сборки образа и обеспечивает воспроизводимость этого процесса на разных окружениях.

\sphinxAtStartPar
Допустим, вы пишете приложение для обработки QR\sphinxhyphen{}кода. В вашем проекте используются различные модули, сторонние библиотеки, конфигурационные файлы. Для развития проекта нужно наделить  его автономность и средствами мониторинга и диагностики, а также инструментами информирования на тот случай, если потребуется ваше вмешательство. В такой ситуации вам будет удобно использовать инструменты ОС. Например, легковесный дистрибутив линукс \sphinxhref{https://www.alpinelinux.org/}{Alpine}. В этой задаче он будет выбран в качестве «базового образа». Базовый образ это основа (ОС, сборка Python b и т.д.) для вашего проекта, который вы планируете использовать в Docker. Среди популярных официальных базовых образов можно отметить:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxhref{https://hub.docker.com/\_/python}{python},

\item {} 
\sphinxAtStartPar
\sphinxhref{https://hub.docker.com/\_/ubuntu}{ubuntu},

\item {} 
\sphinxAtStartPar
\sphinxhref{https://hub.docker.com/\_/alpine}{alpine}.

\end{enumerate}

\sphinxAtStartPar
Ознакомиться с актуальным списком образов можно на сайте \sphinxhref{https://hub.docker.com/}{docker hub}.

\sphinxAtStartPar
Для того чтоб собрать Docker\sphinxhyphen{}образ, в котором будет всё то что упоминалось выше и используют Dockerfile.

\sphinxAtStartPar
В образ контейнера, поверх базового образа, можно добавлять дополнительные слои (установка библиотек и программ, добавление внешних файлов и т.д.). Делается это в соответствии с инструкциями из Dockerfile. Например, если Dockerfile описывает образ, который планируется использовать для решения задач машинного обучения, то в нем могут быть инструкции для включения в промежуточный слой Docker\sphinxhyphen{}образа библиотек: NumPy, Pandas и Scikit\sphinxhyphen{}learn. Наконец, в Docker\sphinxhyphen{}образе может содержаться, поверх всех остальных, еще один тонкий слой, в котором хранятся данные, поддающиеся изменению. Это небольшой по объему слой, содержащий программу, которую планируется запускать в контейнере. Dockerfile может состоять из одной строки с базовым образом:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{ubuntu:18.04}\PYG{+w}{ }\PYG{c}{\PYGZsh{}  \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Базовый образ Ubuntu}
\end{sphinxVerbatim}

\sphinxAtStartPar
В таком случае из реестра Docker Hub будет скачан этот образ ОС ubuntu версии 18.04 и сформирован в виде нового образа. Для указания базового образа мы использовали команду «FROM». Ниже в таблице представлены основные команды Dockerfile с краткими комментариями:

\sphinxAtStartPar
\sphinxstylestrong{Основные команды Dockerfile:}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Команда
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{FROM}
&
\sphinxAtStartPar
Определяет базовый образ, на котором будет основан создаваемый образ.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{RUN}
&
\sphinxAtStartPar
Выполняет команды внутри контейнера во время сборки образа. Используется для установки программ и зависимостей.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{COPY/ADD}
&
\sphinxAtStartPar
Копирует файлы и папки из хостовой машины в образ. COPY просто копирует файлы, а ADD также может распаковывать архивы и загружать файлы из URL.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{WORKDIR}
&
\sphinxAtStartPar
Устанавливает рабочую директорию внутри контейнера, где будут выполняться команды.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ENV}
&
\sphinxAtStartPar
Устанавливает переменные окружения внутри контейнера.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{EXPOSE}
&
\sphinxAtStartPar
Определяет порты, которые контейнер будет слушать при запуске.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{CMD}
&
\sphinxAtStartPar
Устанавливает команду, которая будет выполнена при запуске контейнера. Если в Dockerfile есть несколько CMD, будет исполнен только последний.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ENTRYPOINT}
&
\sphinxAtStartPar
Определяет команду, которая будет запускаться при запуске контейнера. Может использоваться для создания исполняемых контейнеров.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{VOLUME}
&
\sphinxAtStartPar
Создает точку монтирования для работы с данными между хостовой машиной и контейнером.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ARG}
&
\sphinxAtStartPar
Определяет переменные, которые могут быть переданы при сборке образа, но не сохраняются в окружении контейнера.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Рассмотрим пример Dockerfile.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Python}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9\PYGZhy{}slim}

\PYG{c}{\PYGZsh{} Устанавливаем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}

\PYG{c}{\PYGZsh{} Копируем зависимости}
\PYG{k}{COPY}\PYG{+w}{ }requirements.txt\PYG{+w}{ }.

\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}cache\PYGZhy{}dir\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }requirements.txt

\PYG{c}{\PYGZsh{} Копируем файлы приложения}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }.

\PYG{c}{\PYGZsh{} Устанавливаем команду запуска приложения}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
В названии файла не стоит указывать какое\sphinxhyphen{}либо расширение, название должно содержать только «Dockerfile». В случае проблемы, проверьте, что в настройках директории отсутствует галочка в пункте «скрывать расширения файлов» (например, .doc, .txt, .exe, .pdf).
\end{quote}

\sphinxAtStartPar
Представленный выше Dockerfile содержит инструкции для создания Docker\sphinxhyphen{}образа, который будет содержать, и запускать Python\sphinxhyphen{}приложение. Давайте подробнее разберем каждую строку этого Dockerfile и прокомментируем их содержание:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Python}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9\PYGZhy{}slim}
\end{sphinxVerbatim}

\sphinxAtStartPar
Здесь мы выбираем базовый образ Python версии 3.9 версии (slim). Выбор версии обусловлен совместимостью с нашим приложением и требованиями к окружению.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Устанавливаем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}
\end{sphinxVerbatim}

\sphinxAtStartPar
Устанавливаем рабочую директорию для последующих инструкций. В данном случае, мы устанавливаем \sphinxcode{\sphinxupquote{/app}} как рабочую директорию. Все последующие операции будут выполняться в этой директории.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Копируем зависимости}
\PYG{k}{COPY}\PYG{+w}{ }requirements.txt\PYG{+w}{ }.
\end{sphinxVerbatim}

\sphinxAtStartPar
Копируем файл \sphinxcode{\sphinxupquote{requirements.txt}} из контекста сборки (текущей директории, где находится Dockerfile) в рабочую директорию \sphinxcode{\sphinxupquote{/app}} внутри контейнера. Это позволяет установить зависимости перед запуском приложения.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}cache\PYGZhy{}dir\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }requirements.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
Выполняем установку зависимостей, перечисленных в файле \sphinxcode{\sphinxupquote{requirements.txt}}. Флаг \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}cache\sphinxhyphen{}dir}} используется для установки без кэша, что помогает уменьшить размер образа.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Копируем файлы приложения}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }.
\end{sphinxVerbatim}

\sphinxAtStartPar
Копируем все файлы и директории из контекста сборки (включая все файлы Python\sphinxhyphen{}приложения) в рабочую директорию \sphinxcode{\sphinxupquote{/app}} внутри контейнера.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Устанавливаем команду запуска приложения}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Устанавливаем команду, которая будет выполнена при запуске контейнера. В данном случае, это запуск файла \sphinxcode{\sphinxupquote{app.py}} с помощью интерпретатора Python.

\sphinxAtStartPar
В результате, этот Dockerfile позволит создать Docker\sphinxhyphen{}образ, который включает в себя Python\sphinxhyphen{}приложение, его зависимости и команду для его запуска. Этот образ можно будет запустить как контейнер для работы приложения.

\sphinxAtStartPar
Dockerfile \textendash{} это мощный инструмент для определения структуры и настроек Docker образа. Он позволяет автоматизировать процесс создания образов и обеспечивает воспроизводимость настроек на разных средах. С помощью команд в Dockerfile вы можете определить все, что необходимо для успешного развертывания вашего приложения в контейнере.


\subsubsection{Команды для управления контейнерами}
\label{\detokenize{educational_materials/docker_base/content:id7}}
\sphinxAtStartPar
Таблица с командами для управления Docker контейнерами


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Команда
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Описание
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Пример
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker run}}
&
\sphinxAtStartPar
Создание и запуск нового контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker run \sphinxhyphen{}it ubuntu bash}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker ps}}
&
\sphinxAtStartPar
Просмотр списка активных контейнеров.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker ps}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker ps \sphinxhyphen{}a}}
&
\sphinxAtStartPar
Просмотр списка всех контейнеров (активные и остановленные).
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker ps \sphinxhyphen{}a}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker start}}
&
\sphinxAtStartPar
Запуск остановленного контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker start my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker stop}}
&
\sphinxAtStartPar
Остановка запущенного контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker stop my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker restart}}
&
\sphinxAtStartPar
Перезапуск контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker restart my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker pause}}
&
\sphinxAtStartPar
Приостановка выполнения контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker pause my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker unpause}}
&
\sphinxAtStartPar
Возобновление выполнения приостановленного контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker unpause my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker exec}}
&
\sphinxAtStartPar
Выполнение команды внутри запущенного контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker exec \sphinxhyphen{}it my\_container bash}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker logs}}
&
\sphinxAtStartPar
Просмотр логов контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker logs my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker rm}}
&
\sphinxAtStartPar
Удаление контейнера.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker rm my\_container}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker rmi}}
&
\sphinxAtStartPar
Удаление образа.
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker rmi my\_image}}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{Пример использования команды \sphinxstyleliteralintitle{\sphinxupquote{docker run}} для запуска контейнера}
\label{\detokenize{educational_materials/docker_base/content:id8}}
\sphinxAtStartPar
Ниже представлен пример запуска контейнера с шуточным приложением «cowsay», которое выводит фразу, принятую в качестве аргумента:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }run\PYG{+w}{ }docker/whalesay\PYG{+w}{ }cowsay\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Hello, Docker!\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
В данном примере команда запускает контейнер с образом \sphinxcode{\sphinxupquote{docker/whalesay}} и передает приложению \sphinxcode{\sphinxupquote{cowsay}} фразу «Hello, Docker!», которую оно выводит с использованием анимированного ASCII\sphinxhyphen{}арт. Ссылка на \sphinxhref{https://hub.docker.com/r/docker/whalesay/}{Docker Hub} там же доступен и Dockerfile который можно взять в качестве шаблона для разработки собственной версии приложения.


\subsubsection{Работа с данными}
\label{\detokenize{educational_materials/docker_base/content:id9}}
\sphinxAtStartPar
Рассмотрим процесс работы с данными, в частности, тома Docker. Данные в Docker могут храниться либо временно, либо постоянно. Начнем с временных данных.

\sphinxAtStartPar
Чтобы передать файл с данными в Docker контейнер для обработки, вы можете воспользоваться механизмом монтирования томов или копирования файлов. Вот два основных способа:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Монтирование тома (Volume Mounting):}
Вы можете создать Docker том (volume), который будет связан с файловой системой вашего хоста, и затем монтировать этот том внутрь контейнера. Этот способ позволяет передавать данные между хостом и контейнером в режиме реального времени.

\sphinxAtStartPar
Пример команды для запуска контейнера с монтированием тома:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}v\PYG{+w}{ }/путь/к/локальной/директории:/путь/в/контейнере\PYG{+w}{ }\PYGZhy{}it\PYG{+w}{ }my\PYGZus{}image
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Копирование файлов:}
Вы можете скопировать файлы внутрь контейнера с помощью команды \sphinxcode{\sphinxupquote{docker cp}}. При этом файлы будут скопированы внутрь контейнера, и вы сможете работать с ними внутри него.

\sphinxAtStartPar
Пример команды для копирования файла в контейнер:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }cp\PYG{+w}{ }файл.txt\PYG{+w}{ }контейнер:/путь/в/контейнере/
\end{sphinxVerbatim}

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
Обратите внимание, что выбор способа зависит от того, какой уровень взаимодействия вам нужен между хостом и контейнером. Если вам нужно, чтобы контейнер мог динамически видеть и изменять данные, то монтирование тома будет более удобным. Если же данные нужно скопировать внутрь контейнера только один раз, то копирование файлов будет подходящим вариантом.
\end{quote}


\subsubsection{Контейнер Docker обладает следующими характеристиками:}
\label{\detokenize{educational_materials/docker_base/content:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
В нем можно хранить различные ресурсы: скрипты, исходный код, базу данных, наборы тестов, веб\sphinxhyphen{}формы, модели данных и т.д. Ресурсы могут располагаться как в контейнере, так
и за его пределами (через удаленный доступ в сети, либо используя общее место хранения данных — «Volume»). Его можно переносить. Контейнер Docker можно использовать на
локальном ПК, на ПК, находящемся в рабочей сети, на удаленном облачном сервере (Яндекс.Облако, AWS, Google.Cloud и др).

\item {} 
\sphinxAtStartPar
Удобный и гибкий интерфейс обращения к его содержимому. Механизмы, позволяющие контейнеру взаимодействовать с внешним миром. Например, у контейнера есть порты, которые можно открывать для того, чтобы к приложению, работающему в контейнере, можно было бы обращаться из браузера или по протоколу SSH. Работать с контейнером можно и средствами командной строки.

\item {} 
\sphinxAtStartPar
Образ контейнера хранится в специальном репозитории (Docker\sphinxhyphen{}hub). Если вам нужен некий готовый контейнер, вы можете загрузить из репозитория соответствующий образ и, используя его, этот контейнер создать.

\end{itemize}


\subsubsection{Особенности контейнеров}
\label{\detokenize{educational_materials/docker_base/content:id11}}
\sphinxAtStartPar
Давайте разберемся, в чем отличие образа и контейнера. Если сказать в двух словах, то Docker контейнер — это запущенный (активный) образ. Образ в свою очередь — это то, что
представляет собой функциональную часть одной или нескольких программ, скриптов, данных и т.д., то, что будет выполняться при запуске образа в контейнере. Образы достаточно
просто создаются инструментами Docker. На базовом уровне контейнер представляет собой набор инструкций, который выполняется на некоем процессоре, обрабатывая какие\sphinxhyphen{}то
данные.

\sphinxAtStartPar
\sphinxstylestrong{Что такое контейнеры и почему они важны:}

\sphinxAtStartPar
Контейнеры \sphinxhyphen{} это легковесные и изолированные среды, содержащие приложения и все необходимые для их работы компоненты, такие как библиотеки и зависимости. Контейнеры позволяют упаковывать приложения вместе с их средой выполнения, обеспечивая портативность и надежность. Это важно, потому что контейнеры упрощают процессы разработки, тестирования и развертывания, а также обеспечивают однообразие окружений между разработчиками, тестировщиками и операционными командами.

\sphinxAtStartPar
\sphinxstylestrong{Преимущества и недостатки контейнеризации:}

\sphinxAtStartPar
Преимущества контейнеризации включают:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Легковесность:} Контейнеры используют общую ОС и ресурсы хоста, что делает их более легкими и экономичными по сравнению с виртуальными машинами.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Изоляция:} Каждый контейнер изолирован от других, что обеспечивает безопасность и избегает конфликтов между приложениями.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Портативность:} Контейнеры могут работать на разных платформах и окружениях, что делает их переносимыми и совместимыми.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Быстрое развертывание:} Контейнеры могут быть запущены практически мгновенно, что ускоряет процесс развертывания приложений.

\end{enumerate}

\sphinxAtStartPar
Недостатки контейнеризации:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ограничения ОС:} Контейнеры зависят от хост\sphinxhyphen{}ОС, что может ограничить поддерживаемые платформы.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Сетевая изоляция:} Иногда может возникнуть сложность в обеспечении изоляции контейнеров в сетевом окружении.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Сравнение с виртуализацией и традиционными методами развертывания:}

\sphinxAtStartPar
Контейнеризация отличается от традиционных методов развертывания и виртуализации:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Виртуализация:} Виртуальные машины (ВМ) полностью эмулируют физический компьютер, включая ОС и ресурсы. Контейнеры используют общую ОС хоста и обеспечивают легковесную изоляцию, что делает их более эффективными и быстрыми.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Традиционные методы развертывания:} Раньше развертывание приложений могло быть трудоемким из\sphinxhyphen{}за сложности управления зависимостями и конфигурацией. Контейнеризация решает эту проблему, обеспечивая контролируемое окружение.

\end{enumerate}


\subsection{Практическое задание: Развертывание Python кода в Docker контейнере}
\label{\detokenize{educational_materials/docker_base/content:python-docker}}
\sphinxAtStartPar
\sphinxstylestrong{Цель:} Ознакомиться с процессом развертывания приложения на Python в Docker контейнере.

\sphinxAtStartPar
\sphinxstylestrong{Задачи:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Установка Docker:} Убедитесь, что на вашем компьютере установлен Docker. Если нет, следуйте инструкциям на официальном сайте Docker (https://docs.docker.com/get\sphinxhyphen{}docker/).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание Python приложения:} Создайте простое приложение на Python. Например, это может быть «Hello, World!» приложение.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание Dockerfile:} В папке с вашим Python кодом создайте файл с именем «Dockerfile». В Dockerfile опишите инструкции для создания образа. Например:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Python}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9}

\PYG{c}{\PYGZsh{} Копируем содержимое текущей папки в папку /app в образе}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }/app

\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }/app/requirements.txt

\PYG{c}{\PYGZsh{} Указываем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}

\PYG{c}{\PYGZsh{} Запускаем Python приложение}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание requirements.txt:} Если ваше приложение использует сторонние библиотеки, создайте файл «requirements.txt» и укажите их там.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Сборка Docker образа:} В терминале перейдите в папку с Dockerfile и выполните команду для сборки Docker образа:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{app} \PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Где «my\sphinxhyphen{}python\sphinxhyphen{}app» \sphinxhyphen{} это имя образа, а точка означает текущую директорию.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Запуск контейнера:} После успешной сборки образа, запустите контейнер командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{app}
\end{sphinxVerbatim}

\sphinxAtStartPar
Вы увидите вывод вашего Python приложения в терминале.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Оптимизация Dockerfile:} Попробуйте оптимизировать Dockerfile, чтобы уменьшить размер образа. Например, уберите лишние файлы, используйте более легковесные базовые образы и т.д.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Развертывание приложения:} Попробуйте изменить ваш Python код и повторите шаги 5\sphinxhyphen{}6 для обновления контейнера с новым кодом.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Замечание:} Это задание предполагает базовое понимание Docker и Python. Если вы не знакомы с Docker или Python, рекомендуется пройти соответствующие обучающие курсы.
\end{quote}

\sphinxAtStartPar
В подавляющем большинстве контейнеров на данный момент используются минимальные образы Linux. Одним из таких примеров является проект Alphine. Подобные миниатюрные сборки ОС позволяют организовать удобную среду для мониторинга приложений и управления ими. Помимо прочего, ОС Linux обладает большим набором эффективных и не требовательных к вычислительным ресурсам инструментов для решения широкого спектра задач. Это и является основной причиной ее выбора при разработке отказоустойчивых, гибких и высоконагруженных решений. Программист, конечно, может запустить код на Python в Docker контейнере без использования образа с ОС, но в случае возникновения ошибки в процессе работы программы или сбоя в работе контейнера зафиксировать его и определить причину сбоя будет достаточно сложно, как и корректно перезапустить работу контейнера, избежав потери данных. Подробней познакомимся с тем, как применять ОС Alphine Linux в образах Docker.

\sphinxAtStartPar
\sphinxstylestrong{Практическое задание: Развертывание Python кода в Docker контейнере с использованием образа Alpine}

\sphinxAtStartPar
\sphinxstylestrong{Цель:} Освоить процесс развертывания приложения на Python в Docker контейнере с использованием образа Alpine Linux.

\sphinxAtStartPar
\sphinxstylestrong{Задачи:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Установка Docker:} Убедитесь, что на вашем компьютере установлен Docker. Если нет, следуйте инструкциям на официальном сайте Docker (https://docs.docker.com/get\sphinxhyphen{}docker/).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание Python приложения:} Напишите простое Python приложение, которое будет выводить «Hello, Docker with Alpine!».

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание Dockerfile:} В папке с вашим Python кодом, создайте файл с именем «Dockerfile». В Dockerfile опишите инструкции для создания Docker образа на основе образа Alpine. Пример Dockerfile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Alpine}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9\PYGZhy{}alpine}

\PYG{c}{\PYGZsh{} Копируем содержимое текущей папки в папку /app в образе}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }/app

\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }/app/requirements.txt

\PYG{c}{\PYGZsh{} Указываем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}

\PYG{c}{\PYGZsh{} Запускаем Python приложение}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Создание requirements.txt:} Если ваше приложение использует сторонние библиотеки, создайте файл «requirements.txt» и укажите их там.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Сборка Docker образа:} В терминале, перейдите в папку с Dockerfile и выполните команду для сборки Docker образа:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{app}\PYG{o}{\PYGZhy{}}\PYG{n}{alpine} \PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Где «my\sphinxhyphen{}python\sphinxhyphen{}app\sphinxhyphen{}alpine» \sphinxhyphen{} это имя образа, а точка означает текущую директорию.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Запуск контейнера:} После успешной сборки образа, запустите контейнер командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{n}{my}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{app}\PYG{o}{\PYGZhy{}}\PYG{n}{alpine}
\end{sphinxVerbatim}

\sphinxAtStartPar
Вы увидите вывод «Hello, Docker with Alpine!» в терминале.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Изменение кода:} Измените текст вывода вашего Python приложения на «Hello, Docker with Alpine! This is my Alpine containerized app.»

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Обновление контейнера:} Повторите шаги 5\sphinxhyphen{}6 для обновления контейнера с новым кодом.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Оптимизация Dockerfile:} Попробуйте оптимизировать Dockerfile, чтобы уменьшить размер образа. Уберите лишние файлы и зависимости, используйте более легковесные базовые образы.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Примечание:} Это задание предполагает базовое знание Docker и Python. Если вы не знакомы с Docker или Python, рекомендуется предварительно изучить соответствующие темы.


\subsection{Заключение}
\label{\detokenize{educational_materials/docker_base/content:id12}}
\sphinxAtStartPar
Виртуализация и контейнеризация являются ключевыми компонентами для эффективной разработки, доставки и управления программными приложениями в современных условиях. Эти инструменты существенно ускорили и улучшили процессы разработки, а также позволили быстро адаптироваться к изменяющимся требованиям в IT\sphinxhyphen{}отрасли.

\sphinxAtStartPar
Вместе с виртуализацией и контейнеризацией пришла также потребность в эффективном управлении всей инфраструктурой. Именно здесь на сцену вышли инструменты для автоматизации и управления, такие как оркестровщики и системы управления контейнерами. Оркестровщики, такие как Kubernetes, представляют собой мощное средство для автоматизированного развертывания, управления и масштабирования контейнеризированных приложений. Они позволяют организовывать вычислительные кластеры из контейнеров, управлять ими и обеспечивать доступ к сервисам и приложениям.

\sphinxAtStartPar
Также, появление инструментов для управления конфигурациями, таких как Ansible, позволило автоматизировать процессы установки, настройки и обновления программных компонентов в контейнерах и виртуальных машинах.

\sphinxAtStartPar
Следует также отметить важность DevOps\sphinxhyphen{}подхода в современной разработке. DevOps способствует сближению разработки и операций, позволяя создавать и поддерживать приложения более эффективно и безболезненно. Он базируется на принципах автоматизации, непрерывной интеграции и непрерывного развертывания (CI/CD).

\sphinxAtStartPar
В итоге, эволюция разработки программного обеспечения привела к созданию более эффективных, гибких и автоматизированных инструментов и методологий. Они позволяют командам разработчиков быстро создавать, тестировать, разворачивать и масштабировать приложения в современных динамичных условиях. Все эти инновации существенно повлияли на способы работы IT\sphinxhyphen{}специалистов и дали им новые возможности для творчества, инноваций и быстрой реализации идей.


\subsection{Ссылки на дополнительные материалы по Docker}
\label{\detokenize{educational_materials/docker_base/content:id13}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A Beginner\sphinxhyphen{}Friendly Introduction to Containers, VMs and Docker https://www.freecodecamp.org/news/a\sphinxhyphen{}beginner\sphinxhyphen{}friendly\sphinxhyphen{}introduction\sphinxhyphen{}to\sphinxhyphen{}containers\sphinxhyphen{}vms\sphinxhyphen{}and\sphinxhyphen{}docker\sphinxhyphen{}79a9e3e119b/

\item {} 
\sphinxAtStartPar
Книга «Полная виртуализация» http://onreader.mdl.ru/VirtualizationComplete/content/index.html

\item {} 
\sphinxAtStartPar
Docker: основы работы https://otus.ru/journal/docker\sphinxhyphen{}osnovy\sphinxhyphen{}raboty/

\item {} 
\sphinxAtStartPar
Docker \sphinxhyphen{} устройство и принципы работы https://teletype.in/@it255ru/OuwbmZoHuEu

\item {} 
\sphinxAtStartPar
Часть 1: основы https://habr.com/post/438796/

\item {} 
\sphinxAtStartPar
Часть 2: термины и концепции https://habr.com/post/439978/

\item {} 
\sphinxAtStartPar
Часть 3: файлы Dockerfile https://habr.com/post/439980/

\item {} 
\sphinxAtStartPar
Часть 4: уменьшение размеров образов и ускорение их сборки https://habr.com/post/440658/

\item {} 
\sphinxAtStartPar
Часть 5: команды https://habr.com/post/440660/

\item {} 
\sphinxAtStartPar
Изучаем Docker, часть 6: работа с данными https://habr.com/ru/companies/ruvds/articles/441574/

\end{itemize}

\sphinxstepscope


\section{Практическое задание 1: Развертывание Python кода в Docker контейнере}
\label{\detokenize{educational_materials/docker_base/exercises:python-docker}}\label{\detokenize{educational_materials/docker_base/exercises::doc}}
\sphinxAtStartPar
Цель: Ознакомиться с процессом развертывания приложения на Python в Docker контейнере.

\sphinxAtStartPar
Задачи:

\sphinxAtStartPar
Установка Docker: Убедитесь, что на вашем компьютере установлен Docker. Если нет, следуйте инструкциям на официальном сайте Docker (https://docs.docker.com/get\sphinxhyphen{}docker/).

\sphinxAtStartPar
Создание Python приложения: Создайте простое приложение на Python. Например, это может быть «Hello, World!» приложение.

\sphinxAtStartPar
Создание Dockerfile: В папке с вашим Python кодом создайте файл с именем «Dockerfile». В Dockerfile опишите инструкции для создания образа. Например:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Python}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9}

\PYG{c}{\PYGZsh{} Копируем содержимое текущей папки в папку /app в образе}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }/app

\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }/app/requirements.txt

\PYG{c}{\PYGZsh{} Указываем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}

\PYG{c}{\PYGZsh{} Запускаем Python приложение}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Создание requirements.txt: Если ваше приложение использует сторонние библиотеки, создайте файл «requirements.txt» и укажите их там.

\sphinxAtStartPar
Сборка Docker образа: В терминале перейдите в папку с Dockerfile и выполните команду для сборки Docker образа:

\sphinxAtStartPar
docker build \sphinxhyphen{}t my\sphinxhyphen{}python\sphinxhyphen{}app .
Где «my\sphinxhyphen{}python\sphinxhyphen{}app» \sphinxhyphen{} это имя образа, а точка означает текущую директорию.

\sphinxAtStartPar
Запуск контейнера: После успешной сборки образа, запустите контейнер командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }run\PYG{+w}{ }my\PYGZhy{}python\PYGZhy{}app
\end{sphinxVerbatim}

\sphinxAtStartPar
Вы увидите вывод вашего Python приложения в терминале.

\sphinxAtStartPar
Оптимизация Dockerfile: Попробуйте оптимизировать Dockerfile, чтобы уменьшить размер образа. Например, уберите лишние файлы, используйте более легковесные базовые образы и т.д.

\sphinxAtStartPar
Развертывание приложения: Попробуйте изменить ваш Python код и повторите шаги 5\sphinxhyphen{}6 для обновления контейнера с новым кодом.

\sphinxAtStartPar
Замечание: Это задание предполагает базовое понимание Docker и Python. Если вы не знакомы с Docker или Python, рекомендуется пройти соответствующие обучающие курсы.

\sphinxAtStartPar
В подавляющем большинстве контейнеров на данный момент используются минимальные образы Linux. Одним из таких примеров является проект Alphine. Подобные миниатюрные сборки ОС позволяют организовать удобную среду для мониторинга приложений и управления ими. Помимо прочего, ОС Linux обладает большим набором эффективных и не требовательных к вычислительным ресурсам инструментов для решения широкого спектра задач. Это и является основной причиной ее выбора при разработке отказоустойчивых, гибких и высоконагруженных решений. Программист, конечно, может запустить код на Python в Docker контейнере без использования образа с ОС, но в случае возникновения ошибки в процессе работы программы или сбоя в работе контейнера зафиксировать его и определить причину сбоя будет достаточно сложно, как и корректно перезапустить работу контейнера, избежав потери данных. Подробней познакомимся с тем, как применять ОС Alphine Linux в образах Docker.


\subsection{Практическое задание 2: Развертывание Python кода в Docker контейнере с использованием образа Alpine}
\label{\detokenize{educational_materials/docker_base/exercises:python-docker-alpine}}
\sphinxAtStartPar
Цель: Освоить процесс развертывания приложения на Python в Docker контейнере с использованием образа Alpine Linux.

\sphinxAtStartPar
Задачи:

\sphinxAtStartPar
Установка Docker: Убедитесь, что на вашем компьютере установлен Docker. Если нет, следуйте инструкциям на официальном сайте Docker (https://docs.docker.com/get\sphinxhyphen{}docker/).

\sphinxAtStartPar
Создание Python приложения: Напишите простое Python приложение, которое будет выводить «Hello, Docker with Alpine!».

\sphinxAtStartPar
Создание Dockerfile: В папке с вашим Python кодом, создайте файл с именем «Dockerfile». В Dockerfile опишите инструкции для создания Docker образа на основе образа Alpine. Пример Dockerfile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Используем базовый образ Alpine}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{l+s}{python:3.9\PYGZhy{}alpine}

\PYG{c}{\PYGZsh{} Копируем содержимое текущей папки в папку /app в образе}
\PYG{k}{COPY}\PYG{+w}{ }.\PYG{+w}{ }/app

\PYG{c}{\PYGZsh{} Устанавливаем зависимости}
\PYG{k}{RUN}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }/app/requirements.txt

\PYG{c}{\PYGZsh{} Указываем рабочую директорию}
\PYG{k}{WORKDIR}\PYG{+w}{ }\PYG{l+s}{/app}

\PYG{c}{\PYGZsh{} Запускаем Python приложение}
\PYG{k}{CMD}\PYG{+w}{ }\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}python\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}app.py\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Создание requirements.txt: Если ваше приложение использует сторонние библиотеки, создайте файл «requirements.txt» и укажите их там.

\sphinxAtStartPar
Сборка Docker образа: В терминале, перейдите в папку с Dockerfile и выполните команду для сборки Docker образа:

\sphinxAtStartPar
docker build \sphinxhyphen{}t my\sphinxhyphen{}python\sphinxhyphen{}app\sphinxhyphen{}alpine .
Где «my\sphinxhyphen{}python\sphinxhyphen{}app\sphinxhyphen{}alpine» \sphinxhyphen{} это имя образа, а точка означает текущую директорию.

\sphinxAtStartPar
Запуск контейнера: После успешной сборки образа, запустите контейнер командой:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }run\PYG{+w}{ }my\PYGZhy{}python\PYGZhy{}app\PYGZhy{}alpine
\end{sphinxVerbatim}

\sphinxAtStartPar
Вы увидите вывод \sphinxcode{\sphinxupquote{Hello, Docker with Alpine!}} в терминале.

\sphinxAtStartPar
Изменение кода: Измените текст вывода вашего Python приложения на «Hello, Docker with Alpine! This is my Alpine containerized app.»

\sphinxAtStartPar
Обновление контейнера: Повторите шаги 5\sphinxhyphen{}6 для обновления контейнера с новым кодом.

\sphinxAtStartPar
Оптимизация Dockerfile: Попробуйте оптимизировать Dockerfile, чтобы уменьшить размер образа. Уберите лишние файлы и зависимости, используйте более легковесные базовые образы.

\sphinxAtStartPar
Примечание: Это задание предполагает базовое знание Docker и Python. Если вы не знакомы с Docker или Python, рекомендуется предварительно изучить соответствующие темы.

\sphinxstepscope


\section{Вопросы}
\label{\detokenize{educational_materials/docker_base/quiz:id1}}\label{\detokenize{educational_materials/docker_base/quiz::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Что такое Docker?

\item {} 
\sphinxAtStartPar
В чем разница между виртуализацией и контейнеризацией?

\item {} 
\sphinxAtStartPar
Что такое Docker контейнер и какие у него преимущества?

\item {} 
\sphinxAtStartPar
Что такое Образ Docker?

\item {} 
\sphinxAtStartPar
Объясните архитектуру Docker.

\item {} 
\sphinxAtStartPar
Что такое Docker Hub?

\item {} 
\sphinxAtStartPar
Что такое Dockerfile?

\item {} 
\sphinxAtStartPar
Как создать образ Docker?

\item {} 
\sphinxAtStartPar
Как запустить образ Docker, которого нет на локальном компьютере?

\item {} 
\sphinxAtStartPar
Как запустить программу на Python внутри Docker контейнера?

\item {} 
\sphinxAtStartPar
Какие инструменты могут помочь в автоматизации процесса работы Docker?

\item {} 
\sphinxAtStartPar
Какой командой мы можем отобразить в консоли список всех запущенных контейнеров?

\item {} 
\sphinxAtStartPar
Какие компоненты составляют архитектуру Docker?

\item {} 
\sphinxAtStartPar
Какова роль Docker Image (образа) в процессе создания контейнеров?

\item {} 
\sphinxAtStartPar
Какими способами можно получить Docker Image?

\item {} 
\sphinxAtStartPar
Что такое Dockerfile, и как он используется для создания Docker Image?

\item {} 
\sphinxAtStartPar
Какие базовые команды Docker используются для управления контейнерами?

\item {} 
\sphinxAtStartPar
Как запустить контейнер на основе определенного образа?

\item {} 
\sphinxAtStartPar
Как передать порты из контейнера в хост\sphinxhyphen{}систему?

\item {} 
\sphinxAtStartPar
Как передать данные между контейнерами в Docker?

\item {} 
\sphinxAtStartPar
Как узнать список активных контейнеров на системе?

\item {} 
\sphinxAtStartPar
Как остановить и удалить контейнер в Docker?

\item {} 
\sphinxAtStartPar
Как работает Docker Volume, и зачем он нужен?

\item {} 
\sphinxAtStartPar
Как просматривать логи контейнеров в Docker?

\item {} 
\sphinxAtStartPar
Как присваивать имена контейнерам в Docker?

\item {} 
\sphinxAtStartPar
Какие сетевые режимы поддерживает Docker, и что они обозначают?

\item {} 
\sphinxAtStartPar
Какие есть методы для сохранения изменений в контейнере (persisting data)?

\item {} 
\sphinxAtStartPar
Что такое Docker Hub и как его использовать для обмена Docker Image с другими?

\end{enumerate}


\chapter{Дополнительные материалы}
\label{\detokenize{index:id17}}

\chapter{Работа с сетью в Docker}
\label{\detokenize{index:id18}}
\sphinxstepscope


\section{Концепция сети в Docker}
\label{\detokenize{educational_materials/docker_network/content:docker}}\label{\detokenize{educational_materials/docker_network/content::doc}}

\subsection{Познакомимся с тем, как объединять несколько контейнеров в сеть Docker}
\label{\detokenize{educational_materials/docker_network/content:id1}}
\sphinxAtStartPar
Сеть Docker в основном используется для установки связи между контейнерами Docker и внешним миром через хост\sphinxhyphen{}машину. Также можно сказать, что это коммуникационный канал, через который все изолированные контейнеры взаимодействуют друг с другом в различных ситуациях для выполнения необходимых действий.

\sphinxAtStartPar
Перед тем как приступить к основной части материала, закрепим некоторые базовые принципы, термины и определения относительно работы сетей, чтобы избежать противоречий и ошибочного восприятия.


\subsection{Сети: вводная часть}
\label{\detokenize{educational_materials/docker_network/content:id2}}

\subsubsection{Что такое сеть?}
\label{\detokenize{educational_materials/docker_network/content:id3}}
\sphinxAtStartPar
Локальная сеть (Local Area Network, LAN) — объединение компьютеров, сосредоточенных на небольшой территории. В общем случае локальная сеть представляет собой коммуникационную систему, принадлежащую одной организации: школа, университет, больница, банк и т.д. При построении сети используют следующие компоненты:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Оконечные узлы: устройства, которые передают и/или принимают какие\sphinxhyphen{}либо данные. Это могут быть смартфоны, компьютеры, телевизоры, сервера, различные терминалы приема оплаты. Например: метро, сотовая связь, услуги ЖКХ и и т.д.

\item {} 
\sphinxAtStartPar
Промежуточные устройства: это устройства, которые соединяют оконечные узлы между собой. Сюда можно отнести коммутаторы, концентраторы, модемы, маршрутизаторы, точки доступа Wi\sphinxhyphen{}Fi, базовые станции мобильных операторов.

\item {} 
\sphinxAtStartPar
Сетевые среды: это те среды, в которых происходит непосредственная передача данных. Сюда относятся проводные кабели (например, Ethernet), сетевая карта вашего компьютера. Если это кабель, то передача данных осуществляется при помощи электрических сигналов. У оптоволоконных кабелей, при помощи световых импульсов, и радиоволны в случае использования беспроводной среды (WiFi, Bluetooth, LoRa и др.).

\end{enumerate}

\sphinxAtStartPar
Следующее, что нам надо знать — это \sphinxcode{\sphinxupquote{порт}} и \sphinxcode{\sphinxupquote{протокол}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Порт — это цифра. Например, 21, 22, 25, 80, 433, 8080. Это число записывается в заголовках протоколов транспортного уровня (об этом ниже). Порт указывает, для какой программы предназначен тот или иной пакет (информация, передаваемая одним приложением другому). Например, http\sphinxhyphen{}сервер работает через порт 80. Когда вы открываете браузер, вы отправляете запрос на веб\sphinxhyphen{}сервер через 80 порт, и сервер понимает, что это http\sphinxhyphen{}запрос и вам нужен сервер, который передаст вам страницу в формате html (ответ сервера).

\item {} 
\sphinxAtStartPar
Протокол. Например, TCP/IP — это адрес узла (компьютера) с указанием порта и передаваемых данных. Чтобы передать информацию по протоколу TCP/IP, нужно указать следующие данные:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Адрес} \PYG{n}{отправителя} \PYG{p}{(}\PYG{n}{Source} \PYG{n}{address}\PYG{p}{)}\PYG{p}{:}
\PYG{n}{IP}\PYG{p}{:} \PYG{l+m+mf}{82.146}\PYG{l+m+mf}{.49}\PYG{l+m+mf}{.11}
\PYG{n}{Port}\PYG{p}{:} \PYG{l+m+mi}{2049}

\PYG{n}{Адрес} \PYG{n}{получателя} \PYG{p}{(}\PYG{n}{Destination} \PYG{n}{address}\PYG{p}{)}\PYG{p}{:}
\PYG{n}{IP}\PYG{p}{:} \PYG{l+m+mf}{195.34}\PYG{l+m+mf}{.32}\PYG{l+m+mf}{.111}
\PYG{n}{Port}\PYG{p}{:} \PYG{l+m+mi}{53}
\PYG{n}{Данные} \PYG{n}{пакета}\PYG{p}{:}
\PYG{n}{Send} \PYG{n}{test} \PYG{n}{message} 
\end{sphinxVerbatim}

\sphinxAtStartPar
Благодаря этим данным информация будет передана на нужный узел. По такому принципу формируется клиент\sphinxhyphen{}серверная передача данных.

\sphinxAtStartPar
Клиент — это модуль, предназначенный для формирования и передачи сообщений\sphinxhyphen{}запросов к ресурсам удаленного компьютера от разных приложений с последующим приемом результатов из сети и передачей их соответствующим приложениям.

\sphinxAtStartPar
Сервер — это модуль, который постоянно ожидает прихода из сети запросов от клиентов и, приняв запрос, пытается его обслужить, как правило, с участием локальной ОС; один сервер может обслуживать запросы сразу нескольких клиентов (поочередно или одновременно).

\sphinxAtStartPar
\sphinxincludegraphics{{sample_docker_network}.png}


\subsubsection{Объяснение работы сетей в контейнерах Docker}
\label{\detokenize{educational_materials/docker_network/content:id4}}\begin{quote}

\sphinxAtStartPar
В зависимости от установленных версий Docker и операционной системы (ОС) на вашем компьютере, в редких случаях работа с сетью может отличаться. Рекомендуем использовать Docker последней стабильной версии, чтобы избежать возможных ошибок. Все команды, перечисленные в текущем документе, протестированы в ОС Linux дистрибутива Ubuntu с правами root (суперпользователь).
\end{quote}

\sphinxAtStartPar
Для управления сетевыми операциями, такими как создание новой сети, подключение контейнера к сети, отключение контейнера от сети, перечисление доступных сетей, удаление сетей и т. д., мы используем следующую команду: \sphinxcode{\sphinxupquote{docker network}}.

\sphinxAtStartPar
\sphinxincludegraphics{{docker_network_command_terminal}.png}


\subsubsection{Типы сетевых драйверов Docker}
\label{\detokenize{educational_materials/docker_network/content:id5}}
\sphinxAtStartPar
Чтобы получить список всех ваших сетей, запустите \sphinxcode{\sphinxupquote{docker network ls}}.

\sphinxAtStartPar
\sphinxincludegraphics{{docker_network_ls}.png}

\sphinxAtStartPar
Кратко познакомимся с их описанием.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bridge network}: при запуске Docker автоматически создается сеть типа мост по умолчанию. Недавно запущенные контейнеры будут автоматически подключаться к нему. Вы также можете создавать пользовательские настраиваемые мостовые сети. Пользовательские мостовые сети превосходят сетевые мосты по умолчанию.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Host network}: удаляет сетевую изоляцию между контейнером и хостом Docker и напрямую использует сеть хоста. Если вы запускаете контейнер, который привязывается к порту 80, и вы используете хост\sphinxhyphen{}сеть, приложение контейнера доступно через порт 80 по IP\sphinxhyphen{}адресу хоста. Это означает, что вы не сможете запускать несколько веб\sphinxhyphen{}контейнеров на одном хосте, на одном и том же порту, так как порт теперь является общим для всех контейнеров в сети хоста.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{None network}: в сети такого типа контейнеры не подключены ни к одной сети и не имеют доступа к внешней сети или другим контейнерам. Итак, эта сеть используется, когда вы хотите полностью отключить сетевой стек в контейнере.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Overlay network}: создает внутреннюю частную сеть, которая охватывает все узлы, участвующие в кластере swarm. Таким образом, оверлейные сети облегчают обмен данными между сервисом \sphinxstylestrong{Docker Swarm} и автономным контейнером или между двумя автономными контейнерами на разных демонах Docker.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Macvlan network}: некоторые приложения, особенно устаревшие приложения, отслеживающие сетевой трафик, ожидают прямого подключения к физической сети. В такой ситуации вы можете использовать сетевой драйвер \sphinxstyleemphasis{Macvlan} для назначения MAC\sphinxhyphen{}адреса виртуальному сетевому интерфейсу каждого контейнера, что делает его физическим сетевым интерфейсом, напрямую подключенным к физической сети.

\end{enumerate}


\subsection{Познакомимся с сетями \sphinxstylestrong{Bridge} и \sphinxstylestrong{Host} на практике}
\label{\detokenize{educational_materials/docker_network/content:bridge-host}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сеть типа \sphinxstylestrong{Bridge}
Будем использовать два контейнера с ОС Alpine для объяснения этого типа сети. Для удобства в качестве имен контейнеров будем использовать короткие названия.

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Первый контейнер назовем: \sphinxstylestrong{C1}.

\item {} 
\sphinxAtStartPar
Второй контейнер назовем: \sphinxstylestrong{C2}.

\end{itemize}

\sphinxAtStartPar
Чтобы запустить наши тестовые Docker контейнеры с образом Alpine, используем следующие команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} docker run \PYGZhy{}it \PYGZhy{}d \PYGZhy{}\PYGZhy{}name c1 alpine ash}
\PYG{c+c1}{\PYGZsh{} docker run \PYGZhy{}it \PYGZhy{}d \PYGZhy{}\PYGZhy{}name c2 alpine ash}
\end{sphinxVerbatim}

\sphinxAtStartPar
Далее давайте выясним IP\sphinxhyphen{}адреса этих запущенных контейнеров. Для этого выполним следующие команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} docker exec \PYGZhy{}it c1 sh \textendash{}c “ip a”}
\PYG{c+c1}{\PYGZsh{} docker exec \PYGZhy{}it c2 sh \textendash{}c “ip a”}
\end{sphinxVerbatim}

\sphinxAtStartPar
Результаты выполнения первой и второй команды представлены на рисунках.

\sphinxAtStartPar
\sphinxincludegraphics{{docker_network_command_list_networks_terminal}.png}

\sphinxAtStartPar
Рисунок 1 — Отображение IP\sphinxhyphen{}адреса первого контейнера С1

\sphinxAtStartPar
\sphinxincludegraphics{{docker_network_command_show_ip_address_networks_terminal}.png}
Рисунок 2 — Отображение IP\sphinxhyphen{}адреса первого контейнера С1

\sphinxAtStartPar
Как видите, IP\sphinxhyphen{}адрес контейнера C1 — \sphinxstylestrong{172.17.0.2}, а IP\sphinxhyphen{}адрес C2 — \sphinxstylestrong{172.17.0.3}.
Теперь продолжим наше знакомство с сетевыми утилитами и попытаемся проверить их связь друг с другом. Для этого будем использовать команду \sphinxstylestrong{ping}, чтобы убедиться в том, что они могут обращаться друг к другу. Для начала подключимся к контейнеру \sphinxstylestrong{C1} командой \sphinxcode{\sphinxupquote{docker attach c1}} и проверим связь с контейнером \sphinxstylestrong{C2}. Для этого выполним команды:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} docker attach c1}
\PYG{c+c1}{\PYGZsh{} Ping \textendash{}c 2 172.17.0.3}
\end{sphinxVerbatim}

\sphinxAtStartPar
Как вы можете видеть на скриншотах, показанных выше, происходит коннекшн между контейнерами в одной сети. Мы также можем проверить сеть типа мост с помощью команды: \sphinxcode{\sphinxupquote{docker network inspect bridge}}. Приведенная команда отобразит всю информацию о сети, такую как тип сети, подсеть, шлюз, имя контейнера и IP\sphinxhyphen{}адрес и т.д.


\subsubsection{Создание пользовательской Bridge сети}
\label{\detokenize{educational_materials/docker_network/content:bridge}}
\sphinxAtStartPar
При запуске Docker автоматически создается сеть bridge по умолчанию. Все вновь запущенные контейнеры будут автоматически подключаться к ней. Однако вы также можете создавать пользовательские мостовые сети. Чтобы создать новый сетевой драйвер, просто запустите: \sphinxcode{\sphinxupquote{docker network create my\_net}} или \sphinxcode{\sphinxupquote{docker network create \sphinxhyphen{}\sphinxhyphen{}driver bridge dhruv\_net}}.

\sphinxAtStartPar
Обе команды будут выполнять одинаковую работу. Если вы не укажете имя драйвера, сеть будет создана в сетевом драйвере по умолчанию, т.е. bridge.

\sphinxAtStartPar
В пользовательских сетях, таких как dhruv\_net, контейнеры могут не только связываться по IP\sphinxhyphen{}адресу, но также могут преобразовывать имя контейнера в IP\sphinxhyphen{}адрес. Эта возможность называется автоматическим обнаружением службы.

\sphinxAtStartPar
Чтобы убедиться, что контейнеры могут взаимодействовать друг с другом, давайте запустим три alpine контейнера, а именно, A1, A2 и A3 в сети dhruv\_net, которую мы создали ранее.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}it\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }A1\PYG{+w}{ }\PYGZhy{}\PYGZhy{}network\PYG{+w}{ }dhruv\PYGZus{}net\PYG{+w}{ }alpine\PYG{+w}{ }ash
docker\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}it\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }A2\PYG{+w}{ }\PYGZhy{}\PYGZhy{}network\PYG{+w}{ }dhruv\PYGZus{}net\PYG{+w}{ }alpine\PYG{+w}{ }ash
docker\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}it\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }A3\PYG{+w}{ }\PYGZhy{}\PYGZhy{}network\PYG{+w}{ }dhruv\PYGZus{}net\PYG{+w}{ }alpine\PYG{+w}{ }ash
\end{sphinxVerbatim}

\sphinxAtStartPar
Теперь попробуйте подключиться к любому из контейнеров и пропинговать два других, используя имя контейнера.

\sphinxAtStartPar
Из приведенных выше снимков экрана доказано, что контейнеры могут общаться друг с другом.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Хостовая Сеть
Мы запускаем контейнер, который привязывается к порту 80, используя хост\sphinxhyphen{}сеть, приложение контейнера доступно через порт 80 по IP\sphinxhyphen{}адресу хоста.

\end{enumerate}

\sphinxAtStartPar
Сеть типа Host нужна только тогда, когда вы запускаете программы с очень специфической сетью.

\sphinxAtStartPar
Приложения, работающие внутри контейнера Docker, выглядят так, как будто они работают на самом хосте с точки зрения сети.
Это позволяет контейнеру получить больший доступ к сети, чем он может получить.

\sphinxAtStartPar
Здесь мы использовали команду \sphinxcode{\sphinxupquote{netstat \sphinxhyphen{}ntlp}} для отображения порта прослушивания на сервере.

\sphinxAtStartPar
Мы рассмотрели только основы сетевых концепций Docker. Для более подробной информации предлагаем вам заглянуть в руководство по работе с сетями Docker, которое прилагается ниже.
https://docs.docker.com/v17.09/engine/userguide/networking/\#exposing\sphinxhyphen{}and\sphinxhyphen{}publishing\sphinxhyphen{}ports


\chapter{Реестр Docker}
\label{\detokenize{index:id19}}
\sphinxstepscope


\section{Реестр Docker}
\label{\detokenize{educational_materials/docker_hub/content:docker}}\label{\detokenize{educational_materials/docker_hub/content::doc}}
\sphinxAtStartPar
В предыдущем разделе мы уже познакомились с технологией Docker и узнали, что такое Docker контейнер, Docker образ, как связаны эти сущности и как мы можем их использовать. Теперь пришло время познакомиться с таким понятием, как Docker Registry (реестр Docker).
\sphinxincludegraphics{{dockerhub_logo}.png}

\sphinxAtStartPar
В этом разделе мы познакомимся с сервисом \sphinxstylestrong{«Docker Hub»}, узнаем о его возможностях, как использовать его для поиска Docker образов, созданных сторонними разработчиками, опубликовавшими свои проекты в виде образа.
Рассмотрим все этапы работы с сервисом \sphinxstylestrong{«Docker Hub»}. Узнаем как скачать и загрузить образ в \sphinxstylestrong{«Docker Hub»}. Создадим там собственный репозиторий, который позволит делиться созданными нами Docker образами.
\begin{quote}

\sphinxAtStartPar
Вам требуется базовое понимание Docker, знакомство с окружением Windows и Linux. В этом руководстве будет использоваться инструмент Docker Desktop для выполнения текущих упражнений, т.е. для создания и передачи образа в Docker Hub.
\end{quote}

\sphinxAtStartPar
Хотя образы Docker легко создаются, и разработчикам удобно работать с простыми и портативными образами Docker, быстро обнаружилось, что управлять тысячами образов Docker довольно трудно. Решить эту проблему позволяет реестр Docker. Реестр Docker — это стандартный способ хранения и распространения образов Docker. Реестр — это репозиторий с открытым исходным кодом, имеющий разрешительную лицензию Apache.

\sphinxAtStartPar
Реестр Docker также помогает улучшить управление правами доступа и безопасность образов Docker, хранящихся в его репозитории. Он управляет распространением образов, а также может интегрироваться с рабочими процессами разработки приложений. Разработчики могут настроить собственный реестр Docker или использовать сервис размещения, например, Docker Hub, Oracle Container Registry, Azure Container Registry и т.д.

\sphinxAtStartPar
\sphinxincludegraphics{{docker_flow}.png}
\sphinxhyphen{}Docker Flow \sphinxhyphen{} процесс работы
Рисунок 1. Docker Flow — процесс работы

\sphinxAtStartPar
Docker Hub — это размещенный реестр Docker, управляемый Docker. Docker Hub содержит более 100 000 образов контейнеров от поставщиков программного обеспечения, а также проекты с открытым исходным кодом и сообщества. Docker Hub содержит программное обеспечение и приложения из официальных репозиториев, таких как NGINX, Apache, MySQL, Ubuntu, Python, Flask и т.д.

\sphinxAtStartPar
Он позволяет нам извлекать и добавлять Doсker образы в Docker Hub.
Его также можно сравнить с GitHub, где мы получаем и отправляем наш исходный код, но в случае Docker Hub мы работаем с образами Docker контейнеров.

\sphinxAtStartPar
Облачный онлайн\sphinxhyphen{}репозиторий «Docker Hub» использует два типа репозиториев:
\begin{itemize}
\item {} 
\sphinxAtStartPar
общедоступный репозиторий;

\item {} 
\sphinxAtStartPar
частный репозиторий.

\end{itemize}

\sphinxAtStartPar
Общедоступные репозитории доступны всем пользователям сервиса Docker Hub, в то время как частный репозиторий доступен только его владельцу (аналогично репозиториям на GitHub).

\sphinxAtStartPar
При запуске контейнера Docker по умолчанию автоматически извлекает соответствующий образ из общедоступного Docker Hub, если он недоступен локально. Вы также можете создавать собственные образы и отправлять их в Docker Hub в общедоступный или частный репозиторий.

\sphinxAtStartPar
\sphinxincludegraphics{{dockerhub_registry_explorer}.png}

\sphinxAtStartPar
Рисунок 2. Снимок экрана реестра Docker


\subsection{Создание первого Docker репозитория}
\label{\detokenize{educational_materials/docker_hub/content:id1}}
\sphinxAtStartPar
Первым делом требуется авторизоваться в Docker Hub, используя ваши учетные данные. Если у вас нет учетной записи, вы можете создать ее, нажав кнопку Register (Регистрация) на странице «https://hub.docker.com». После того как вы авторизовались на сервисе, вы можете создать репозиторий, нажав на кнопку «Create repository» (Создать репозиторий).

\sphinxAtStartPar
\sphinxincludegraphics{{dockerhub_create_repository}.png}

\sphinxAtStartPar
Рисунок 3. Создание Docker Hub репозитория

\sphinxAtStartPar
Откроется окно, в котором предлагается заполнить краткую информацию о новом репозитории. В качестве примера создадим открытый (публичный) репозиторий с названием «\sphinxstylestrong{my\_web\_service}».
\begin{quote}

\sphinxAtStartPar
Docker Hub предоставляет нам только один частный репозиторий бесплатно. Если нам нужно больше частных репозиториев, мы можем обновить нашу учетную запись до платной.
\end{quote}

\sphinxAtStartPar
\sphinxincludegraphics{{dockerhub_create_repository_stage_2}.png}

\sphinxAtStartPar
Рисунок 4. Параметры нового репозитория Docker Hub

\sphinxAtStartPar
Как только все будет сделано, нажмите Создать (Create).
Поздравляем! Вы создали свой первый репозиторий, который будут выглядеть следующим образом.

\sphinxAtStartPar
\sphinxincludegraphics{{dockerhub_view_new_repository}.png}

\sphinxAtStartPar
Рисунок 5. Созданный репозиторий Docker Hub

\sphinxAtStartPar
Теперь откройте приложение Docker Desktop tool или консоль (terminal) Docker и войдите в Docker Hub с помощью команды \sphinxcode{\sphinxupquote{docker login}}.


\subsection{Поиск Docker образа}
\label{\detokenize{educational_materials/docker_hub/content:id2}}
\sphinxAtStartPar
Для поиска образа на Docker Hub нам доступны 2 способа:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Поиск на веб\sphinxhyphen{}сайте Docker Hub через браузер. Для этого надо перейти в раздел «Explore» в верхнем меню Docker Hub.

\item {} 
\sphinxAtStartPar
Через командную строку (терминал). В таком случае, если мы хотим найти образ Flask, мы можем воспользоваться следующей командой: \sphinxcode{\sphinxupquote{docker search mysql}}.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{dokerhub_search_image}.PNG}

\sphinxAtStartPar
Преимуществом поиска Docker образа в веб\sphinxhyphen{}браузере является возможность поиска по ключевым словам и выбора наиболее подходящего образа. Есть возможность ознакомиться с его описанием, документацией и содержимым, а также скопировать команду для загрузки найденного Docker образа на свой компьютер (Docker Pull Command).

\sphinxAtStartPar
\sphinxincludegraphics{{dockerhub_overview_flask_image_description}.PNG}


\subsection{Загрузка Docker образа из реестра Docker Hub}
\label{\detokenize{educational_materials/docker_hub/content:docker-docker-hub}}
\sphinxAtStartPar
Чтобы загрузить Docker образ из Docker Hub, нужно использовать команду \sphinxstylestrong{\sphinxcode{\sphinxupquote{pull}}} следующим образом: \sphinxstylestrong{\sphinxcode{\sphinxupquote{docker pull \textless{}image\_name\textgreater{}}}}. Например, если требуется скачать последнюю стабильную версию Docker образа \sphinxstylestrong{MySQL}, можно использовать следующую команду:
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker pull mysql}}}

\sphinxAtStartPar
Если образ mysql уже есть на нашем компьютере, то приведенная выше команда автоматически обновит образ до последней версии. Здесь нужно помнить одну вещь: если мы выполним поиск на Docker Hub, нам отобразится список различных образов MySQL. Нам нужно найти подходящий вариант в зависимости от решаемой задачи. Допустим, мы хотим получить образ bitnami/mysql.
\sphinxcode{\sphinxupquote{docker pull bitnami/mysql}}


\subsection{Создание Docker образа}
\label{\detokenize{educational_materials/docker_hub/content:id3}}
\sphinxAtStartPar
Этот процесс требует Dockerfile. Мы можем рассматривать Dockerfile как руководство по эксплуатации, которое говорит Docker, что собирать (подобие requirements.txt в venv для python). Проще говоря, это файл конфигурации, в котором хранится инструкция по сборке.


\subsection{Как это работает?}
\label{\detokenize{educational_materials/docker_hub/content:id4}}
\sphinxAtStartPar
Docker читает инструкцию из Dockerfile и автоматически создает образы. Образ Docker является многоуровневой файловой системой и состоит из нескольких слоев, доступных только для чтения, и каждый слой образа Docker представляет инструкции файла Docker. Давайте выполним следующие шаги, чтобы создать образ с помощью Dockerfile.


\subsection{Создайте Dockerfile, который определяет конфигурацию нашего приложения}
\label{\detokenize{educational_materials/docker_hub/content:dockerfile}}
\sphinxAtStartPar
sudo vim Dockerfile
*Примечание. Имя файла должно быть \sphinxstylestrong{\sphinxcode{\sphinxupquote{Dockerfile}}} с большой латинской буквы D.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FROM ubuntu:16.04
MAINTAINER someuser@somedomain.com
RUN apt\PYGZhy{}get update
RUN apt\PYGZhy{}get install \textendash{}y mysql
CMD echo \PYGZdq{}My first image created.
\end{sphinxVerbatim}

\sphinxAtStartPar
Давайте посмотрим на некоторые важные ключевые слова, используемые в \sphinxstylestrong{\sphinxcode{\sphinxupquote{Dockerfile}}}

\sphinxAtStartPar
Мы можем использовать символы \#, чтобы добавить комментарий в \sphinxstylestrong{\sphinxcode{\sphinxupquote{Dockerfile}}}
Ключевое слово \sphinxcode{\sphinxupquote{FROM}} определяет базовый образ, которое будет использоваться.
Ключевое слово \sphinxcode{\sphinxupquote{MAINTAINER}} — это пользователь, который будет поддерживать этот образ.
Ключевое слово \sphinxcode{\sphinxupquote{RUN}} используется для запуска инструкции, приведенной для образа. В нашем случае сначала обновите систему, а затем установите MySQL.
Ключевое слово \sphinxcode{\sphinxupquote{CMD}} используется для выполнения команды после запуска контейнера.
Ключевое слово \sphinxcode{\sphinxupquote{COPY}} можно использовать для копирования файла из нашей хост операционной системы в док\sphinxhyphen{}контейнер.
Ключевое слово \sphinxcode{\sphinxupquote{EXPOSE}} используется для указания номера порта, на котором контейнер будет выполнять свой процесс.
Запустите команду ниже, чтобы создать наш образ Docker.
Синтаксис
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker build \sphinxhyphen{}t /repo\sphinxhyphen{}name}}}

\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{docker build \sphinxhyphen{}t \textless{}user\_name\textgreater{}/\textless{}repo\_name\textgreater{} .}}}
В приведенной выше команде имя изображения и символ точка « . » указывает текущий рабочий каталог. Это означает, что Docker ищет текущий каталог файла Docker. Опция \sphinxcode{\sphinxupquote{\sphinxhyphen{}t}} используется для обозначения образа.

\sphinxAtStartPar
Вывод будет похож на:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker build}}

\sphinxAtStartPar
Теперь давайте проверим наш образ, запустив его с помощью команды запуска docker.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker run asadali08527/first\sphinxhyphen{}repo}}

\sphinxAtStartPar
Выполнение вышеупомянутой команды попросит ваш \sphinxstylestrong{\sphinxcode{\sphinxupquote{Dockerfile}}} образ успешно установить MySQL на ваш компьютер со всеми необходимыми обновлениями, и, наконец, он также отобразит сообщение.

\sphinxAtStartPar
Заливаем образ на Docker Hub. Как только наш образ был успешно создан и запущен, мы можем отправить его в Docker Hub с помощью команды push.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{docker push asadali08527/first\sphinxhyphen{}repo}}

\sphinxAtStartPar
Мы можем проверить теги образа и статус на Docker Hub, который будет выглядеть примерно так.

\sphinxAtStartPar
\sphinxincludegraphics{{docker_search}.png}


\subsection{Образ на Docker Hub}
\label{\detokenize{educational_materials/docker_hub/content:docker-hub}}
\sphinxAtStartPar
Что такое DOCKER CERTIFIED образы?
Это официальные образы поставщиков или участников. Образ может быть сертифицирован Docker Hub, только если его содержимое соответствует правилам, стандартам и законам, предусмотренным Docker Hub. Проще говоря, этот образ должен пройти определенные базовые тесты.

\sphinxAtStartPar
Docker Hub предоставляет инструмент inspectDockerImage, с помощью которого поставщик может самостоятельно сертифицировать образы и плагины (обычно поставщик или участник публикует свои плагины для регистрации томов и сетей).
\begin{quote}

\sphinxAtStartPar
Примечание:
Чтобы опубликовать наш образ в качестве сертифицированного Docker образа, сначала мы должны самостоятельно сертифицировать и протестировать наш образ и плагин с помощью инструмента inspectDockerImage. После того как мы сертифицировали и успешно протестировали, после отправки Docker Hub подтвердит его. Если наш контент требует несертифицированной среды, он не может быть опубликован как сертифицированный ни при каких обстоятельствах.
\end{quote}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Рекомендации}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ищите конкретную версию Docker образа, используя теги, в основном последние. Это необходимо, чтобы избежать возможных конфликтов и сбоев в случае несовместимости пакетов в вашем проекте и библиотек, модулей в составе Docker образа.

\item {} 
\sphinxAtStartPar
Выберите тот, который имеет максимальные загрузки и звезды.

\item {} 
\sphinxAtStartPar
Проверьте его обновления (когда он был обновлен последний раз).

\item {} 
\sphinxAtStartPar
Если возможно, проверьте его тип: проверенный издатель или официальный (Docker Certified).

\end{itemize}
\end{quote}



\renewcommand{\indexname}{Алфавитный указатель}
\printindex
\end{document}